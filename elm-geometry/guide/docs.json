[{"name":"Arc.SweptAngle","comment":" When constructing circular or elliptical arcs, it is sometimes necessary to\nspecify which of several possible arcs you want. For example, if you ask for a\ncircular arc from the point (1, 0) to the point (0, 1) with a radius of 1, there\nare four possible solutions:\n\n  - An arc with a swept angle of 90 degrees, with center point at (0, 0)\n  - An arc with a swept angle of -270 degrees, with center point at (0, 0)\n  - An arc with a swept angle of -90 degrees, with center point at (1, 1)\n  - An Arc with a swept angle of 270 degrees, with center point at (1, 1)\n\nThe `SweptAngle` type is used in these cases to specify which arc you want.\n\n@docs SweptAngle\n@docs smallPositive, smallNegative, largePositive, largeNegative\n\n","unions":[],"aliases":[{"name":"SweptAngle","comment":" Indicate which of four possible arcs you would like to construct. Used by\n[`Arc2d.withRadius`](Arc2d#withRadius) and [`EllipticalArc2d.fromEndpoints`](EllipticalArc2d#fromEndpoints).\n","args":[],"type":"Geometry.Types.SweptAngle"}],"values":[{"name":"largeNegative","comment":" Construct a clockwise arc with a swept angle between -180 and -360 degrees.\n","type":"Arc.SweptAngle.SweptAngle"},{"name":"largePositive","comment":" Construct a counterclockwise arc with a swept angle between 180 and 360\ndegrees.\n","type":"Arc.SweptAngle.SweptAngle"},{"name":"smallNegative","comment":" Construct a clockwise arc with a swept angle between 0 and -180 degrees.\n","type":"Arc.SweptAngle.SweptAngle"},{"name":"smallPositive","comment":" Construct a counterclockwise arc with a swept angle between 0 and 180\ndegrees.\n","type":"Arc.SweptAngle.SweptAngle"}],"binops":[]},{"name":"Arc2d","comment":" An `Arc2d` is a section of a circle, defined by its center point, start\r\npoint and swept angle (the counterclockwise angle from the start point to the\r\nend point). This module includes functionality for\r\n\r\n  - Constructing arcs through given points and/or with a given radius\r\n  - Scaling, rotating, translating and mirroring arcs\r\n  - Converting arcs between different coordinate systems\r\n\r\n@docs Arc2d\r\n\r\n\r\n# Constructors\r\n\r\n@docs from, with, sweptAround, throughPoints, withRadius\r\n\r\n\r\n# Properties\r\n\r\n@docs centerPoint, radius, startPoint, endPoint, sweptAngle\r\n\r\n\r\n# Evaluation\r\n\r\n@docs pointOn, pointsAt\r\n@docs Nondegenerate, nondegenerate, fromNondegenerate\r\n@docs tangentDirection, tangentDirectionsAt, sample, samplesAt\r\n\r\n\r\n# Linear approximation\r\n\r\n@docs toPolyline\r\n\r\n\r\n# Transformations\r\n\r\n@docs reverse, scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n\r\n# Differentiation\r\n\r\nYou are unlikely to need to use these functions directly, but they are useful if\r\nyou are writing low-level geometric algorithms.\r\n\r\n@docs firstDerivative, firstDerivativesAt\r\n\r\n","unions":[{"name":"Nondegenerate","comment":" If a curve has zero length (consists of just a single point), then we say\r\nthat it is 'degenerate'. Some operations such as computing tangent directions\r\nare not defined on degenerate curves.\r\n\r\nA `Nondegenerate` value represents an arc that is definitely not degenerate. It\r\nis used as input to functions such as `Arc2d.tangentDirection` and can be\r\nconstructed using `Arc2d.nondegenerate`.\r\n\r\n","args":["units","coordinates"],"cases":[]}],"aliases":[{"name":"Arc2d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Arc2d units coordinates"}],"values":[{"name":"centerPoint","comment":" Get the center point of an arc.\r\n\r\n    Arc2d.centerPoint exampleArc\r\n    --> Point2d.fromCoordinates ( 1, 1 )\r\n\r\n","type":"Arc2d.Arc2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"endPoint","comment":" Get the end point of an arc.\r\n\r\n    Arc2d.endPoint exampleArc\r\n    --> Point2d.fromCoordinates ( 1, 3 )\r\n\r\n","type":"Arc2d.Arc2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"firstDerivative","comment":" Get the first derivative of an arc at a given parameter value:\r\n\r\n    Arc2d.firstDerivative exampleArc ParameterValue.zero\r\n    --> Vector2d.fromComponents ( 0, 3.1416 )\r\n\r\n    Arc2d.firstDerivative exampleArc ParameterValue.half\r\n    --> Vector2d.fromComponents ( -2.2214, 2.2214 )\r\n\r\n    Arc2d.firstDerivative exampleArc ParameterValue.one\r\n    --> Vector2d.fromComponents ( -3.1416, 0 )\r\n\r\n","type":"Arc2d.Arc2d units coordinates -> Curve.ParameterValue.ParameterValue -> Vector2d.Vector2d units coordinates"},{"name":"firstDerivativesAt","comment":" Evaluate the first derivative of an arc at a given set of parameter values:\r\n\r\n    exampleArc\r\n        |> Arc2d.firstDerivativesAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Vector2d.fromComponents ( 0, 3.1416 )\r\n    --> , Vector2d.fromComponents ( -2.2214, 2.2214 )\r\n    --> , Vector2d.fromComponents ( -3.1416, 0 )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> Arc2d.Arc2d units coordinates -> List.List (Vector2d.Vector2d units coordinates)"},{"name":"from","comment":" Construct an arc with from the first given point to the second, with the\r\ngiven swept angle.\r\n\r\n    p1 =\r\n        Point2d.fromCoordinates ( 2, 1 )\r\n\r\n    p2 =\r\n        Point2d.fromCoordinates ( 1, 2 )\r\n\r\n    arc1 =\r\n        Arc2d.from p1 p2 (degrees 90)\r\n\r\n    Arc2d.centerPoint arc1\r\n    --> Point2d.fromCoordinates ( 1, 1 )\r\n\r\n    arc2 =\r\n        Arc2d.from p1 p2 (degrees -90)\r\n\r\n    Arc2d.centerPoint arc2\r\n    --> Point2d.fromCoordinates ( 2, 2 )\r\n\r\n    arc3 =\r\n        Arc2d.from p1 p2 (degrees 180)\r\n\r\n    Arc2d.centerPoint arc3\r\n    --> Point2d.fromCoordinates ( 1.5, 1.5 )\r\n\r\n    arc4 =\r\n        Arc2d.from p1 p2 (degrees -180)\r\n\r\n    Arc2d.centerPoint arc4\r\n    --> Point2d.fromCoordinates ( 1.5, 1.5 )\r\n\r\n    arc5 =\r\n        Arc2d.from p1 p2 (degrees 45)\r\n\r\n    Arc2d.centerPoint arc5\r\n    --> Point2d.fromCoordinates ( 0.2929, 0.2929 )\r\n\r\n","type":"Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> Angle.Angle -> Arc2d.Arc2d units coordinates"},{"name":"fromNondegenerate","comment":" Convert a nondegenerate arc back to a general `Arc2d`.\r\n\r\n    Arc2d.fromNondegenerate nondegenerateExampleArc\r\n    --> exampleArc\r\n\r\n","type":"Arc2d.Nondegenerate units coordinates -> Arc2d.Arc2d units coordinates"},{"name":"mirrorAcross","comment":" Mirror an arc across a given axis.\r\n\r\n    Arc2d.mirrorAcross Axis2d.y exampleArc\r\n    --> Point2d.fromCoordinates ( -3, 1 )\r\n    -->     |> Arc2d.sweptAround\r\n    -->         (Point2d.fromCoordinates ( -1, 1 ))\r\n    -->         (degrees -90)\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> Arc2d.Arc2d units coordinates -> Arc2d.Arc2d units coordinates"},{"name":"nondegenerate","comment":" Attempt to construct a nondegenerate arc from a general `Arc2d`. If the arc\r\nis in fact degenerate (consists of a single point), returns an `Err` with that\r\npoint.\r\n\r\n    Arc2d.nondegenerate exampleArc\r\n    --> Ok nondegenerateExampleArc\r\n\r\n","type":"Arc2d.Arc2d units coordinates -> Result.Result (Point2d.Point2d units coordinates) (Arc2d.Nondegenerate units coordinates)"},{"name":"placeIn","comment":" Take an arc considered to be defined in local coordinates relative to a\r\ngiven reference frame, and return that arc expressed in global coordinates.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    Arc2d.placeIn localFrame exampleArc\r\n    --> Point2d.fromCoordinates ( 4, 3 )\r\n    -->     |> Arc2d.sweptAround\r\n    -->         (Point2d.fromCoordinates ( 2, 3 ))\r\n    -->         (degrees 90)\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> Arc2d.Arc2d units localCoordinates -> Arc2d.Arc2d units globalCoordinates"},{"name":"pointOn","comment":" Get the point along an arc at a given parameter value:\r\n\r\n    Arc2d.pointOn exampleArc ParameterValue.zero\r\n    --> Point2d.fromCoordinates ( 3, 1 )\r\n\r\n    Arc2d.pointOn exampleArc ParameterValue.half\r\n    --> Point2d.fromCoordinates ( 2.4142, 2.4142 )\r\n\r\n    Arc2d.pointOn exampleArc ParameterValue.one\r\n    --> Point2d.fromCoordinates ( 1, 3 )\r\n\r\n","type":"Arc2d.Arc2d units coordinates -> Curve.ParameterValue.ParameterValue -> Point2d.Point2d units coordinates"},{"name":"pointsAt","comment":" Get points along an arc at a given set of parameter values:\r\n\r\n    exampleArc |> Arc2d.pointsAt (ParameterValue.steps 2)\r\n    --> [ Point2d.fromCoordinates ( 3, 1 )\r\n    --> , Point2d.fromCoordinates ( 2.4142, 2.4142 )\r\n    --> , Point2d.fromCoordinates ( 1, 3 )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> Arc2d.Arc2d units coordinates -> List.List (Point2d.Point2d units coordinates)"},{"name":"radius","comment":" Get the radius of an arc.\r\n\r\n    Arc2d.radius exampleArc\r\n    --> 2\r\n\r\n","type":"Arc2d.Arc2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"relativeTo","comment":" Take an arc defined in global coordinates, and return it expressed in local\r\ncoordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    Arc2d.relativeTo localFrame exampleArc\r\n    --> Point2d.fromCoordinates ( 2, -1 )\r\n    -->     |> Arc2d.sweptAround\r\n    -->         (Point2d.fromCoordinates ( 0, -1 ))\r\n    -->         (degrees 90)\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> Arc2d.Arc2d units globalCoordinates -> Arc2d.Arc2d units localCoordinates"},{"name":"reverse","comment":" Reverse the direction of an arc, so that the start point becomes the end\r\npoint and vice versa.\r\n\r\n    Arc2d.reverse exampleArc\r\n    --> Point2d.fromCoordinates ( 1, 3 )\r\n    -->     |> Arc2d.sweptAround\r\n    -->         (Point2d.fromCoordinates ( 1, 1 ))\r\n    -->         (degrees -90)\r\n\r\n","type":"Arc2d.Arc2d units coordinates -> Arc2d.Arc2d units coordinates"},{"name":"rotateAround","comment":" Rotate an arc around a given point by a given angle.\r\n\r\n    Arc2d.rotateAround Point2d.origin (degrees 90)\r\n    --> Point2d.fromCoordinates ( -1, 3 )\r\n    -->     |> Arc2d.sweptAround\r\n    -->         (Point2d.fromCoordinates ( -1, 1 ))\r\n    -->         (degrees 90)\r\n\r\n","type":"Point2d.Point2d units coordinates -> Angle.Angle -> Arc2d.Arc2d units coordinates -> Arc2d.Arc2d units coordinates"},{"name":"sample","comment":" Get both the point and tangent direction of a nondegenerate arc at a given\r\nparameter value:\r\n\r\n    Arc2d.sample nondegenerateExampleArc\r\n        ParameterValue.zero\r\n    --> ( Point2d.fromCoordinates ( 3, 1 )\r\n    --> , Direction2d.fromAngle (degrees 90)\r\n    --> )\r\n\r\n    Arc2d.sample nondegenerateExampleArc\r\n        ParameterValue.half\r\n    --> ( Point2d.fromCoordinates ( 2.4142, 2.4142 )\r\n    --> , Direction2d.fromAngle (degrees 135)\r\n    --> )\r\n\r\n    Arc2d.sample nondegenerateExampleArc\r\n        ParameterValue.one\r\n    --> ( Point2d.fromCoordinates ( 1, 3 )\r\n    --> , Direction2d.fromAngle (degrees 180)\r\n    --> )\r\n\r\n","type":"Arc2d.Nondegenerate units coordinates -> Curve.ParameterValue.ParameterValue -> ( Point2d.Point2d units coordinates, Direction2d.Direction2d coordinates )"},{"name":"samplesAt","comment":" Get points and tangent directions of a nondegenerate arc at a given set of\r\nparameter values:\r\n\r\n    nondegenerateExampleArc\r\n        |> Arc2d.samplesAt (ParameterValue.steps 2)\r\n    --> [ ( Point2d.fromCoordinates ( 3, 1 )\r\n    -->   , Direction2d.fromAngle (degrees 90)\r\n    -->   )\r\n    --> , ( Point2d.fromCoordinates ( 2.4142, 2.4142 )\r\n    -->   , Direction2d.fromAngle (degrees 135)\r\n    -->   )\r\n    --> , ( Point2d.fromCoordinates ( 1, 3 )\r\n    -->   , Direction2d.fromAngle (degrees 180)\r\n    -->   )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> Arc2d.Nondegenerate units coordinates -> List.List ( Point2d.Point2d units coordinates, Direction2d.Direction2d coordinates )"},{"name":"scaleAbout","comment":" Scale an arc about a given point by a given scale.\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 0, 1 )\r\n\r\n    Arc2d.scaleAbout point 2 exampleArc\r\n    --> Point2d.fromCoordinates ( 6, 1 )\r\n    -->     |> Arc2d.sweptAround\r\n    -->         (Point2d.fromCoordinates ( 2, 1 ))\r\n    -->         (degrees 90)\r\n\r\n","type":"Point2d.Point2d units coordinates -> Basics.Float -> Arc2d.Arc2d units coordinates -> Arc2d.Arc2d units coordinates"},{"name":"startPoint","comment":" Get the start point of an arc.\r\n\r\n    Arc2d.startPoint exampleArc\r\n    --> Point2d.fromCoordinates ( 3, 1 )\r\n\r\n","type":"Arc2d.Arc2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"sweptAngle","comment":" Get the swept angle of an arc in radians.\r\n\r\n    Arc2d.sweptAngle exampleArc\r\n    --> 1.5708\r\n\r\nThe result will be positive for a counterclockwise arc and negative for a\r\nclockwise one.\r\n\r\n","type":"Arc2d.Arc2d units coordinates -> Angle.Angle"},{"name":"sweptAround","comment":" Construct an arc by sweeping (rotating) a given start point around a given\r\ncenter point by a given angle. The center point to sweep around is given first\r\nand the start point to be swept is given last.\r\n\r\n    exampleArc =\r\n        Point2d.fromCoordinates ( 3, 1 )\r\n            |> Arc2d.sweptAround\r\n                (Point2d.fromCoordinates ( 1, 1 ))\r\n                (degrees 90)\r\n\r\n    Arc2d.endPoint exampleArc\r\n    --> Point2d.fromCoordinates ( 1, 3 )\r\n\r\nNote that the 'actual' form of this function is\r\n\r\n    arc =\r\n        Arc2d.sweptAround centerPoint sweptAngle startPoint\r\n\r\nbut it is generally written using the pipe operator `|>` (as in the first\r\nexample) to improve readability:\r\n\r\n    arc =\r\n        startPoint\r\n            |> Arc2d.sweptAround centerPoint sweptAngle\r\n\r\nA positive swept angle means that the arc is formed by rotating the start point\r\ncounterclockwise around the center point. A negative swept angle results in\r\na clockwise arc instead.\r\n\r\n","type":"Point2d.Point2d units coordinates -> Angle.Angle -> Point2d.Point2d units coordinates -> Arc2d.Arc2d units coordinates"},{"name":"tangentDirection","comment":" Get the tangent direction to a nondegenerate arc at a given parameter\r\nvalue:\r\n\r\n    Arc2d.tangentDirection nondegenerateExampleArc\r\n        ParameterValue.zero\r\n    --> Direction2d.fromAngle (degrees 90)\r\n\r\n    Arc2d.tangentDirection nondegenerateExampleArc\r\n        ParameterValue.half\r\n    --> Direction2d.fromAngle (degrees 135)\r\n\r\n    Arc2d.tangentDirection nondegenerateExampleArc\r\n        ParameterValue.one\r\n    --> Direction2d.fromAngle (degrees 180)\r\n\r\n","type":"Arc2d.Nondegenerate units coordinates -> Curve.ParameterValue.ParameterValue -> Direction2d.Direction2d coordinates"},{"name":"tangentDirectionsAt","comment":" Get tangent directions to a nondegenerate arc at a given set of parameter\r\nvalues:\r\n\r\n    nondegenerateExampleArc\r\n        |> Arc2d.tangentDirectionsAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Direction2d.fromAngle (degrees 90)\r\n    --> , Direction2d.fromAngle (degrees 135)\r\n    --> , Direction2d.fromAngle (degrees 180)\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> Arc2d.Nondegenerate units coordinates -> List.List (Direction2d.Direction2d coordinates)"},{"name":"throughPoints","comment":" Attempt to construct an arc that starts at the first given point, passes\r\nthrough the second given point and ends at the third given point:\r\n\r\n    Arc2d.throughPoints\r\n        Point2d.origin\r\n        (Point2d.fromCoordinates ( 1, 0 ))\r\n        (Point2d.fromCoordinates ( 0, 1 ))\r\n    --> Just\r\n    -->     (Point2d.origin\r\n    -->         |> Arc2d.sweptAround\r\n    -->             (Point2d.fromCoordinates ( 0.5, 0.5 ))\r\n    -->             (degrees 270)\r\n    -->     )\r\n\r\n    Arc2d.throughPoints\r\n        (Point2d.fromCoordinates ( 1, 0 ))\r\n        Point2d.origin\r\n        (Point2d.fromCoordinates ( 0, 1 ))\r\n    --> Just\r\n    -->     (Point2d.fromCoordinates ( 1, 0 )\r\n    -->         |> Arc2d.sweptAround\r\n    -->             (Point2d.fromCoordinates ( 0.5, 0.5 ))\r\n    -->             (degrees -180)\r\n    -->     )\r\n\r\nIf the three points are collinear, returns `Nothing`:\r\n\r\n    Arc2d.throughPoints\r\n        Point2d.origin\r\n        (Point2d.fromCoordinates ( 1, 0 ))\r\n        (Point2d.fromCoordinates ( 2, 0 ))\r\n    --> Nothing\r\n\r\n    Arc2d.throughPoints\r\n        Point2d.origin\r\n        Point2d.origin\r\n        (Point2d.fromCoordinates ( 1, 0 ))\r\n    --> Nothing\r\n\r\n","type":"Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> Maybe.Maybe (Arc2d.Arc2d units coordinates)"},{"name":"toPolyline","comment":" Approximate an arc as a polyline, within a given tolerance:\r\n\r\n    exampleArc |> Arc2d.toPolyline { maxError = 0.1 }\r\n    --> Polyline2d.fromVertices\r\n    -->     [ Point2d.fromCoordinates ( 3, 1 )\r\n    -->     , Point2d.fromCoordinates ( 2.732, 2 )\r\n    -->     , Point2d.fromCoordinates ( 2, 2.732 )\r\n    -->     , Point2d.fromCoordinates ( 1, 3 )\r\n    -->     ]\r\n\r\nIn this example, every point on the returned polyline will be within 0.1 units\r\nof the original arc.\r\n\r\n","type":"{ maxError : Quantity.Quantity Basics.Float units } -> Arc2d.Arc2d units coordinates -> Polyline2d.Polyline2d units coordinates"},{"name":"translateBy","comment":" Translate an arc by a given displacement.\r\n\r\n    displacement =\r\n        Vector2d.fromComponents ( 2, 3 )\r\n\r\n    Arc2d.translateBy displacement exampleArc\r\n    --> Point2d.fromCoordinates ( 5, 4 )\r\n    -->     |> Arc2d.sweptAround\r\n    -->         (Point2d.fromCoordinates ( 3, 4 ))\r\n    -->         (degrees 90)\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Arc2d.Arc2d units coordinates -> Arc2d.Arc2d units coordinates"},{"name":"translateIn","comment":" Translate an arc in a given direction by a given distance;\r\n\r\n    Arc2d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    Arc2d.translateBy\r\n        (Vector2d.withLength distance direction)\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Quantity.Quantity Basics.Float units -> Arc2d.Arc2d units coordinates -> Arc2d.Arc2d units coordinates"},{"name":"with","comment":" Construct an arc with the given center point, radius, start angle and swept\r\nangle:\r\n\r\n    arc =\r\n        Arc2d.with\r\n            { centerPoint =\r\n                Point2d.fromCoordinates ( 2, 0 )\r\n            , radius = 1\r\n            , startAngle = degrees 45\r\n            , sweptAngle = degrees -90\r\n            }\r\n\r\n    Arc2d.startPoint arc\r\n    --> Point2d.fromCoordinates ( 2.7071, 0.7071 )\r\n\r\n    Arc2d.endPoint arc\r\n    --> Point2d.fromCoordinates ( 2.7071, -0.7071 )\r\n\r\n","type":"{ centerPoint : Point2d.Point2d units coordinates, radius : Quantity.Quantity Basics.Float units, startAngle : Angle.Angle, sweptAngle : Angle.Angle } -> Arc2d.Arc2d units coordinates"},{"name":"withRadius","comment":" Attempt to construct an arc with the given radius between the given start\r\nand end points. Note that this is only possible if the given radius is large\r\nenough! For any given valid radius, start point and end point, there are four\r\npossible results, so the [`SweptAngle`](Arc-SweptAngle) argument is used to\r\nspecify which arc to create. For example:\r\n\r\n    p1 =\r\n        Point2d.fromCoordinates ( 1, 0 )\r\n\r\n    p2 =\r\n        Point2d.fromCoordinates ( 0, 1 )\r\n\r\n    Arc2d.withRadius 1 SweptAngle.smallPositive p1 p2\r\n    --> Just\r\n    -->     (Point2d.fromCoordinates ( 1, 0 )\r\n    -->         |> Arc2d.sweptAround Point2d.origin\r\n    -->             (degrees 90)\r\n    -->     )\r\n\r\n    Arc2d.withRadius 1 SweptAngle.smallNegative p1 p2\r\n    --> Just\r\n    -->     (Point2d.fromCoordinates ( 1, 0 )\r\n    -->         |> Arc2d.sweptAround\r\n    -->             (Point2d.fromCoordinates ( 1, 1 ))\r\n    -->             (degrees -90)\r\n    -->     )\r\n\r\n    Arc2d.withRadius 1 SweptAngle.largePositive p1 p2\r\n    --> Just\r\n    -->     (Point2d.fromCoordinates ( 1, 0 )\r\n    -->         |> Arc2d.sweptAround\r\n    -->             (Point2d.fromCoordinates ( 1, 1 ))\r\n    -->             (degrees 270)\r\n    -->     )\r\n\r\n    Arc2d.withRadius 1 SweptAngle.largeNegative p1 p2\r\n    --> Just\r\n    -->     (Point2d.fromCoordinates ( 1, 0 )\r\n    -->         |> Arc2d.sweptAround Point2d.origin\r\n    -->             (degrees -270)\r\n    -->     )\r\n\r\n    Arc2d.withRadius 2 SweptAngle.smallPositive p1 p2\r\n    --> Just\r\n    -->     (Point2d.fromCoordinates ( 1, 0 )\r\n    -->         |> Arc2d.sweptAround\r\n    -->             (Point2d.fromCoordinates\r\n    -->                 ( -0.8229, -0.8229 )\r\n    -->             )\r\n    -->             (degrees 41.4096)\r\n    -->     )\r\n\r\nIf the start and end points are coincident or the distance between them is more\r\nthan twice the given radius, returns `Nothing`:\r\n\r\n    -- p1 and p2 are too far apart to be connected by an\r\n    -- arc of radius 0.5\r\n    Arc2d.withRadius 0.5 SweptAngle.smallPositive p1 p2\r\n    --> Nothing\r\n\r\nNote that this means it is dangerous to use this function to construct 180\r\ndegree arcs (half circles), since in this case due to numerical roundoff the\r\ndistance between the two given points may appear to be slightly more than twice\r\nthe given radius. In this case it is safer to use `Arc2d.from`, such as (for a\r\ncounterclockwise arc):\r\n\r\n    halfCircle =\r\n        Arc2d.from firstPoint secondPoint (degrees 180)\r\n\r\n(Use `degrees -180` for a clockwise arc.)\r\n\r\n","type":"Quantity.Quantity Basics.Float units -> Arc.SweptAngle.SweptAngle -> Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> Maybe.Maybe (Arc2d.Arc2d units coordinates)"}],"binops":[]},{"name":"Arc3d","comment":" An `Arc3d` is a section of a circle in 3D, defined by its central axis,\r\nstart point and swept angle (the counterclockwise angle around the axis from the\r\nstart point to the arc's end point). This module includes functionality for\r\n\r\n  - Constructing arcs through given points\r\n  - Scaling, rotating, translating and mirroring arcs\r\n  - Converting arcs between different coordinate systems\r\n\r\n@docs Arc3d\r\n\r\n\r\n# Constructors\r\n\r\n@docs on, sweptAround, throughPoints\r\n\r\n\r\n# Properties\r\n\r\n@docs axialDirection, axis, centerPoint, radius, startPoint, endPoint, sweptAngle\r\n\r\n\r\n# Evaluation\r\n\r\n@docs pointOn, pointsAt\r\n@docs Nondegenerate, nondegenerate, fromNondegenerate\r\n@docs tangentDirection, tangentDirectionsAt, sample, samplesAt\r\n\r\n\r\n# Linear approximation\r\n\r\n@docs toPolyline\r\n\r\n\r\n# Transformations\r\n\r\n@docs reverse, scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross, projectInto\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n\r\n# Differentiation\r\n\r\nYou are unlikely to need to use these functions directly, but they are useful if\r\nyou are writing low-level geometric algorithms.\r\n\r\n@docs firstDerivative, firstDerivativesAt\r\n\r\n","unions":[{"name":"Nondegenerate","comment":" If a curve has zero length (consists of just a single point), then we say\r\nthat it is 'degenerate'. Some operations such as computing tangent directions\r\nare not defined on degenerate curves.\r\n\r\nA `Nondegenerate` value represents an arc that is definitely not degenerate. It\r\nis used as input to functions such as `Arc3d.tangentDirection` and can be\r\nconstructed using `Arc3d.nondegenerate`.\r\n\r\n","args":["units","coordinates"],"cases":[]}],"aliases":[{"name":"Arc3d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Arc3d units coordinates"}],"values":[{"name":"axialDirection","comment":" Get the axial direction of an arc.\r\n\r\n    Arc3d.axialDirection exampleArc\r\n    --> Direction3d.z\r\n\r\n","type":"Arc3d.Arc3d units coordinates -> Direction3d.Direction3d coordinates"},{"name":"axis","comment":" Get the central axis of an arc. The origin point of the axis will be equal\r\nto the center point of the arc.\r\n\r\n    Arc3d.axis exampleArc\r\n    --> Axis3d.z\r\n\r\n","type":"Arc3d.Arc3d units coordinates -> Axis3d.Axis3d units coordinates"},{"name":"centerPoint","comment":" Get the center point of an arc.\r\n\r\n    Arc3d.centerPoint exampleArc\r\n    --> Point3d.origin\r\n\r\n","type":"Arc3d.Arc3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"endPoint","comment":" Get the end point of an arc.\r\n\r\n    Arc3d.endPoint exampleArc\r\n    --> Point3d.fromCoordinates ( -1, 1, 0 )\r\n\r\n","type":"Arc3d.Arc3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"firstDerivative","comment":" Get the first derivative of an arc at a given parameter value.\r\n\r\n    Arc3d.firstDerivative exampleArc ParameterValue.zero\r\n    --> Vector3d.fromComponents ( -1.5708, 1.5708, 0 )\r\n\r\n    Arc3d.firstDerivative exampleArc ParameterValue.one\r\n    --> Vector3d.fromComponents ( -1.5708, -1.5708, 0 )\r\n\r\n","type":"Arc3d.Arc3d units coordinates -> Curve.ParameterValue.ParameterValue -> Vector3d.Vector3d units coordinates"},{"name":"firstDerivativesAt","comment":" Evaluate the first derivative of an arc at a range of parameter values.\r\n\r\n    exampleArc\r\n        |> Arc3d.firstDerivativesAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Vector3d ( -1.5708, 1.5708, 0 )\r\n    --> , Vector3d ( -2.2214, 0, 0 )\r\n    --> , Vector3d ( -1.5708, -1.5708, 0 )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> Arc3d.Arc3d units coordinates -> List.List (Vector3d.Vector3d units coordinates)"},{"name":"fromNondegenerate","comment":" Convert a nondegenerate arc back to a general `Arc3d`.\r\n\r\n    Arc3d.fromNondegenerate nondegenerateExampleArc\r\n    --> exampleArc\r\n\r\n","type":"Arc3d.Nondegenerate units coordinates -> Arc3d.Arc3d units coordinates"},{"name":"mirrorAcross","comment":" Mirror an arc across a given plane.\r\n\r\n    Arc3d.mirrorAcross Plane3d.xy exampleArc\r\n    --> Arc3d.sweptAround (Axis3d.reverse Axis3d.z)\r\n    -->     (degrees -90)\r\n    -->     (Point3d.fromCoordinates ( 1, 1, 0 ))\r\n\r\nNote that this flips the sign of the arc's swept angle.\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> Arc3d.Arc3d units coordinates -> Arc3d.Arc3d units coordinates"},{"name":"nondegenerate","comment":" Attempt to construct a nondegenerate arc from a general `Arc3d`. If the arc\r\nis in fact degenerate (consists of a single point), returns an `Err` with that\r\npoint.\r\n\r\n    Arc3d.nondegenerate exampleArc\r\n    --> Ok nondegenerateExampleArc\r\n\r\n","type":"Arc3d.Arc3d units coordinates -> Result.Result (Point3d.Point3d units coordinates) (Arc3d.Nondegenerate units coordinates)"},{"name":"on","comment":" Construct a 3D arc lying _on_ a sketch plane by providing a 2D arc specified\r\nin XY coordinates _within_ the sketch plane.\r\n\r\n    arc =\r\n        Arc3d.on SketchPlane3d.xz\r\n            (Point2d.fromCoordinates ( 3, 1 )\r\n                |> Arc2d.sweptAround\r\n                    (Point2d.fromCoordinates ( 1, 1 )\r\n                    (degrees 90)\r\n            )\r\n\r\n    Arc3d.centerPoint arc\r\n    --> Point3d.fromCoordinates ( 1, 0, 1 )\r\n\r\n    Arc3d.radius arc\r\n    --> 2\r\n\r\n    Arc3d.startPoint arc\r\n    --> Point3d.fromCoordinates ( 3, 0, 1 )\r\n\r\n    Arc3d.endPoint arc\r\n    --> Point3d.fromCoordinates ( 1, 0, 3 )\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates3d coordinates2d -> Arc2d.Arc2d units coordinates2d -> Arc3d.Arc3d units coordinates3d"},{"name":"placeIn","comment":" Take an arc considered to be defined in local coordinates relative to a\r\ngiven reference frame, and return that arc expressed in global coordinates.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    Arc3d.placeIn localFrame exampleArc\r\n    --> Arc3d.sweptAround\r\n    -->     (Axis3d.withDirection Direction3d.z\r\n    -->         (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n    -->     )\r\n    -->     (degrees 90)\r\n    -->     (Point3d.fromCoordinates ( 2, 3, 3 ))\r\n\r\n","type":"Frame3d.Frame3d units globalCoordinates localCoordinates -> Arc3d.Arc3d units localCoordinates -> Arc3d.Arc3d units globalCoordinates"},{"name":"pointOn","comment":" Get the point along an arc at a given parameter value:\r\n\r\n    Arc3d.pointOn exampleArc ParameterValue.half\r\n    --> Point3d.fromCoordinates ( 0, 1.4142, 0 )\r\n\r\n","type":"Arc3d.Arc3d units coordinates -> Curve.ParameterValue.ParameterValue -> Point3d.Point3d units coordinates"},{"name":"pointsAt","comment":" Get points along an arc at a given set of parameter values.\r\n\r\n    exampleArc |> Arc3d.pointsAt (ParameterValue.steps 2)\r\n    --> [ Point3d ( 1, 1, 0 )\r\n    --> , Point3d ( 0, 1.4142, 0 )\r\n    --> , Point3d ( -1, 1, 0 )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> Arc3d.Arc3d units coordinates -> List.List (Point3d.Point3d units coordinates)"},{"name":"projectInto","comment":" Project an arc into a sketch plane.\r\n\r\n    axis : Axis3d\r\n    axis =\r\n        Axis3d.through\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n            (Direction3d.fromAzimuthAndElevation\r\n                (degrees 0)\r\n                (degrees 45)\r\n            )\r\n\r\n    arc : Arc3d\r\n    arc =\r\n        Arc3d.sweptAround axis\r\n            (degrees 45)\r\n            (Point3d.fromCoordinates ( 1, 4, 3 ))\r\n\r\n    Arc3d.projectInto SketchPlane3d.xy arc\r\n    --> EllipticalArc2d.with\r\n    -->     { centerPoint =\r\n    -->         Point2d.fromCoordinates ( 1, 2 )\r\n    -->     , xDirection = Direction2d.y\r\n    -->     , xRadius = 2\r\n    -->     , yRadius = 1.4142\r\n    -->     , startAngle = degrees 0\r\n    -->     , sweptAngle = degrees 45\r\n    -->     }\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates3d coordinates2d -> Arc3d.Arc3d units coordinates3d -> Geometry.Types.EllipticalArc2d units coordinates2d"},{"name":"radius","comment":" Get the radius of an arc.\r\n\r\n    Arc3d.radius exampleArc\r\n    --> 1.4142\r\n\r\n","type":"Arc3d.Arc3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"relativeTo","comment":" Take an arc defined in global coordinates, and return it expressed in local\r\ncoordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    Arc3d.relativeTo localFrame exampleArc\r\n    --> Arc3d.sweptAround\r\n    -->     (Axis3d.withDirection Direction3d.z\r\n    -->         (Point3d ( -1, -2, -3 ))\r\n    -->     )\r\n    -->     (degrees 90)\r\n    -->     (Point3d.fromCoordinates ( 0, -1, -3 ))\r\n\r\n","type":"Frame3d.Frame3d units globalCoordinates localCoordinates -> Arc3d.Arc3d units globalCoordinates -> Arc3d.Arc3d units localCoordinates"},{"name":"reverse","comment":" Reverse the direction of an arc, so that the start point becomes the end\r\npoint and vice versa. The resulting arc will have the same axis as the original\r\nbut a swept angle with the opposite sign.\r\n\r\n    Arc3d.reverse exampleArc\r\n    --> Arc3d.sweptAround Axis3d.z\r\n    -->     (degrees -90)\r\n    -->     (Point3d.fromCoordinates ( -1, 1, 0 ))\r\n\r\n","type":"Arc3d.Arc3d units coordinates -> Arc3d.Arc3d units coordinates"},{"name":"rotateAround","comment":" Rotate an arc around a given axis by a given angle (in radians).\r\n\r\n    Arc3d.rotateAround Axis3d.x (degrees 90) exampleArc\r\n    --> Arc3d.sweptAround (Axis3d.reverse Axis3d.y)\r\n    -->     (degrees 90)\r\n    -->     (Point3d.fromCoordinates ( 1, 0, 1 ))\r\n\r\n","type":"Axis3d.Axis3d units coordinates -> Angle.Angle -> Arc3d.Arc3d units coordinates -> Arc3d.Arc3d units coordinates"},{"name":"sample","comment":" Get both the point and tangent direction of a nondegenerate arc at a given\r\nparameter value:\r\n\r\n    Arc3d.sample nondegenerateExampleArc\r\n        ParameterValue.zero\r\n    --> ( Point3d.fromCoordinates ( 1, 1, 0 )\r\n    --> , Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 135)\r\n    -->     (degrees 0)\r\n    --> )\r\n\r\n    Arc3d.sample nondegenerateExampleArc\r\n        ParameterValue.half\r\n    --> ( Point3d.fromCoordinates ( 0, 1.4142, 0 )\r\n    --> , Direction3d.negativeX\r\n    --> )\r\n\r\n    Arc3d.sample nondegenerateExampleArc\r\n        ParameterValue.one\r\n    --> ( Point3d.fromCoordinates ( -1, 1, 0 )\r\n    --> , Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 225)\r\n    -->     (degrees 0)\r\n    --> )\r\n\r\n","type":"Arc3d.Nondegenerate units coordinates -> Curve.ParameterValue.ParameterValue -> ( Point3d.Point3d units coordinates, Direction3d.Direction3d coordinates )"},{"name":"samplesAt","comment":" Get points and tangent directions of a nondegenerate arc at a given set of\r\nparameter values:\r\n\r\n    nondegenerateExampleArc\r\n        |> Arc3d.samplesAt (ParameterValue.steps 2)\r\n    --> [ ( Point3d.fromCoordinates ( 1, 1, 0 )\r\n    -->   , Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 135)\r\n    -->         (degrees 0)\r\n    -->   )\r\n    --> , ( Point3d.fromCoordinates ( 0, 1.4142, 0 )\r\n    -->   , Direction3d.negativeX\r\n    -->   )\r\n    --> , ( Point3d.fromCoordinates ( -1, 1, 0 )\r\n    -->   , Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 225)\r\n    -->         (degrees 0)\r\n    -->   )\r\n    --> ]\r\n\r\nIf the arc is degenerate (start point and end point are equal), returns an\r\nempty list.\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> Arc3d.Nondegenerate units coordinates -> List.List ( Point3d.Point3d units coordinates, Direction3d.Direction3d coordinates )"},{"name":"scaleAbout","comment":" Scale an arc about the given center point by the given scale.\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 0, -1, 0 )\r\n\r\n    Arc3d.scaleAbout point 2 exampleArc\r\n    --> Arc3d.sweptAround\r\n    -->     (Axis3d.withDirection Direction3d.z\r\n    -->         (Point3d.fromCoordinates ( 0, 1, 0 ))\r\n    -->     )\r\n    -->     (degrees 90)\r\n    -->     (Point3d.fromCoordinates ( 2, 3, 0 ))\r\n\r\n","type":"Point3d.Point3d units coordinates -> Basics.Float -> Arc3d.Arc3d units coordinates -> Arc3d.Arc3d units coordinates"},{"name":"startPoint","comment":" Get the start point of an arc.\r\n\r\n    Arc3d.startPoint exampleArc\r\n    --> Point3d.fromCoordinates ( 1, 1, 0 )\r\n\r\n","type":"Arc3d.Arc3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"sweptAngle","comment":" Get the swept angle of an arc in radians.\r\n\r\n    Arc3d.sweptAngle exampleArc\r\n    --> 1.5708\r\n\r\nA positive swept angle means that the arc is formed by rotating the given start\r\npoint counterclockwise around the central axis, and vice versa for a negative\r\nangle.\r\n\r\n","type":"Arc3d.Arc3d units coordinates -> Angle.Angle"},{"name":"sweptAround","comment":" Construct an arc by sweeping the given point around the given axis by the\r\ngiven angle:\r\n\r\n    exampleArc =\r\n        Point3d.fromCoordinates ( 1, 1, 0 )\r\n            |> Arc3d.sweptAround Axis3d.z (degrees 90)\r\n\r\n    Arc3d.centerPoint exampleArc\r\n    --> Point3d.origin\r\n\r\n    Arc3d.endPoint exampleArc\r\n    --> Point3d.fromCoordinates ( -1, 1, 0 )\r\n\r\nPositive swept angles result in a counterclockwise (right-handed) rotation\r\naround the given axis and vice versa for negative swept angles. The center point\r\nof the returned arc will lie on the given axis.\r\n\r\n","type":"Axis3d.Axis3d units coordinates -> Angle.Angle -> Point3d.Point3d units coordinates -> Arc3d.Arc3d units coordinates"},{"name":"tangentDirection","comment":" Get the tangent direction to a nondegenerate arc at a given parameter\r\nvalue:\r\n\r\n    Arc3d.tangentDirection nondegenerateExampleArc\r\n        ParameterValue.zero\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 135)\r\n    -->     (degrees 0)\r\n\r\n    Arc3d.tangentDirection nondegenerateExampleArc\r\n        ParameterValue.half\r\n    --> Direction3d.negativeX\r\n\r\n    Arc3d.tangentDirection nondegenerateExampleArc\r\n        ParameterValue.zero\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 225)\r\n    -->     (degrees 0)\r\n\r\n","type":"Arc3d.Nondegenerate units coordinates -> Curve.ParameterValue.ParameterValue -> Direction3d.Direction3d coordinates"},{"name":"tangentDirectionsAt","comment":" Get tangent directions to a nondegenerate arc at a given set of parameter\r\nvalues:\r\n\r\n    nondegenerateExampleArc\r\n        |> Arc3d.tangentDirectionsAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 135)\r\n    -->     (degrees 0)\r\n    --> , Direction3d.negativeX\r\n    --> , Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 225)\r\n    -->     (degrees 0)\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> Arc3d.Nondegenerate units coordinates -> List.List (Direction3d.Direction3d coordinates)"},{"name":"throughPoints","comment":" Attempt to construct an arc that starts at the first given point, passes\r\nthrough the second given point and ends at the third given point. If the three\r\npoints are collinear, returns `Nothing`.\r\n\r\n    p1 =\r\n        Point3d.fromCoordinates ( 0, 0, 1 )\r\n\r\n    p2 =\r\n        Point3d.origin\r\n\r\n    p3 =\r\n        Point3d.fromCoordinates ( 0, 1, 0 )\r\n\r\n    Arc3d.throughPoints p1 p2 p3\r\n    --> Just\r\n    -->     (Arc3d.on SketchPlane3d.yz\r\n    -->         Point2d.fromCoordinates ( 0, 1 )\r\n    -->             |> Arc2d.sweptAround\r\n    -->                 (Point2d.fromCoordinates\r\n    -->                     ( 0.5, 0.5 )\r\n    -->                 )\r\n    -->                 (degrees 180)\r\n    -->     )\r\n\r\n","type":"Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> Maybe.Maybe (Arc3d.Arc3d units coordinates)"},{"name":"toPolyline","comment":" Approximate an arc as a polyline, within a given tolerance:\r\n\r\n    exampleArc |> Arc3d.toPolyline { maxError = 0.1 }\r\n    --> Polyline3d.fromVertices\r\n    -->     [ Point3d.fromCoordinates ( 1, 1, 0 )\r\n    -->     , Point3d.fromCoordinates ( 0.366, 1.366, 0 )\r\n    -->     , Point3d.fromCoordinates ( -0.366, 1.366, 0 )\r\n    -->     , Point3d.fromCoordinates ( -1, 1, 0 )\r\n    -->     ]\r\n\r\nIn this example, every point on the returned polyline will be within 0.1 units\r\nof the original arc.\r\n\r\n","type":"{ maxError : Quantity.Quantity Basics.Float units } -> Arc3d.Arc3d units coordinates -> Polyline3d.Polyline3d units coordinates"},{"name":"translateBy","comment":" Translate an arc by a given displacement.\r\n\r\n    displacement =\r\n        Vector3d.fromComponents ( 2, 1, 3 )\r\n\r\n    Arc3d.translateBy displacement exampleArc\r\n    --> Arc3d.sweptAround\r\n    -->     (Axis3d.withDirection Direction3d.z\r\n    -->         (Point3d ( 2, 1, 3 ))\r\n    -->     )\r\n    -->     (degrees 90)\r\n    -->     (Point3d.fromCoordinates ( 3, 2, 3 ))\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Arc3d.Arc3d units coordinates -> Arc3d.Arc3d units coordinates"},{"name":"translateIn","comment":" Translate an arc in a given direction by a given distance;\r\n\r\n    Arc3d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    Arc3d.translateBy\r\n        (Vector3d.withLength distance direction)\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Quantity.Quantity Basics.Float units -> Arc3d.Arc3d units coordinates -> Arc3d.Arc3d units coordinates"}],"binops":[]},{"name":"Axis2d","comment":" An `Axis2d` represents an infinitely long straight line in 2D and is defined\r\nby an origin point and direction. Axes have several uses, such as:\r\n\r\n  - Mirroring across the axis\r\n  - Projecting onto the axis\r\n  - Measuring distance along the axis from the origin point\r\n\r\n@docs Axis2d\r\n\r\n\r\n# Constants\r\n\r\n@docs x, y\r\n\r\n\r\n# Constructors\r\n\r\n@docs through, withDirection\r\n\r\n\r\n# Properties\r\n\r\n@docs originPoint, direction\r\n\r\n\r\n# Transformations\r\n\r\n@docs reverse, moveTo, rotateAround, translateBy, translateIn, mirrorAcross\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n","unions":[],"aliases":[{"name":"Axis2d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Axis2d units coordinates"}],"values":[{"name":"direction","comment":" Get the direction of an axis.\r\n\r\n    Axis2d.direction exampleAxis\r\n    --> Direction2d.fromAngle (degrees 30)\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> Direction2d.Direction2d coordinates"},{"name":"mirrorAcross","comment":" Mirror one axis across another. The axis to mirror across is given first and\r\nthe axis to mirror is given second.\r\n\r\n    Axis2d.mirrorAcross Axis2d.x exampleAxis\r\n    --> Axis2d.through (Point2d.fromCoordinates ( 1, -3 ))\r\n    -->     (Direction2d.fromAngle (degrees -30))\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> Axis2d.Axis2d units coordinates -> Axis2d.Axis2d units coordinates"},{"name":"moveTo","comment":" Move an axis so that it has the given origin point but unchanged direction.\r\n\r\n    newOrigin =\r\n        Point2d.fromCoordinates ( 4, 5 )\r\n\r\n    Axis2d.moveTo newOrigin exampleAxis\r\n    --> Axis2d.through (Point2d.fromCoordinates ( 4, 5 ))\r\n    -->     (Direction2d.fromAngle (degrees 30))\r\n\r\n","type":"Point2d.Point2d units coordinates -> Axis2d.Axis2d units coordinates -> Axis2d.Axis2d units coordinates"},{"name":"originPoint","comment":" Get the origin point of an axis.\r\n\r\n    Axis2d.originPoint exampleAxis\r\n    --> Point2d.fromCoordinates ( 1, 3 )\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"placeIn","comment":" Take an axis defined in local coordinates relative to a given reference\r\nframe, and return that axis expressed in global coordinates.\r\n\r\n    frame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 2, 3 ))\r\n\r\n    Axis2d.placeIn frame exampleAxis\r\n    --> Axis2d.through (Point2d.fromCoordinates ( 3, 6 ))\r\n    -->     (Direction2d.fromAngle (degrees 30))\r\n\r\n","type":"Geometry.Types.Frame2d units globalCoordinates localCoordinates -> Axis2d.Axis2d units localCoordinates -> Axis2d.Axis2d units globalCoordinates"},{"name":"relativeTo","comment":" Take an axis defined in global coordinates, and return it expressed in local\r\ncoordinates relative to a given reference frame.\r\n\r\n    frame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 2, 3 ))\r\n\r\n    Axis2d.relativeTo frame exampleAxis\r\n    --> Axis2d.through (Point2d.fromCoordinates ( -1, 0 ))\r\n    -->     (Direction2d.fromAngle (degrees 30))\r\n\r\n","type":"Geometry.Types.Frame2d units globalCoordinates localCoordinates -> Axis2d.Axis2d units globalCoordinates -> Axis2d.Axis2d units localCoordinates"},{"name":"reverse","comment":" Reverse the direction of an axis while keeping the same origin point.\r\n\r\n    Axis2d.reverse exampleAxis\r\n    --> Axis2d.through (Point2d.fromCoordinates ( 1, 3 ))\r\n    -->     (Direction2d.fromAngle (degrees -150))\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> Axis2d.Axis2d units coordinates"},{"name":"rotateAround","comment":" Rotate an axis around a given center point by a given angle. Rotates the\r\naxis' origin point around the given point by the given angle and the axis'\r\ndirection by the given angle.\r\n\r\n    exampleAxis\r\n        |> Axis2d.rotateAround Point2d.origin (degrees 90)\r\n    --> Axis2d.through (Point2d.fromCoordinates ( -3, 1 ))\r\n    -->     (Direction2d.fromAngle (degrees 120))\r\n\r\n","type":"Point2d.Point2d units coordinates -> Angle.Angle -> Axis2d.Axis2d units coordinates -> Axis2d.Axis2d units coordinates"},{"name":"through","comment":" Construct an axis through the given origin point with the given direction.\r\n\r\n    exampleAxis =\r\n        Axis2d.through (Point2d.fromCoordinates ( 1, 3 ))\r\n            (Direction2d.fromAngle (degrees 30))\r\n\r\n","type":"Point2d.Point2d units coordinates -> Direction2d.Direction2d coordinates -> Axis2d.Axis2d units coordinates"},{"name":"translateBy","comment":" Translate an axis by a given displacement. Applies the given displacement to\r\nthe axis' origin point and leaves the direction unchanged.\r\n\r\n    displacement =\r\n        Vector2d.fromComponents ( 2, 3 )\r\n\r\n    Axis2d.translateBy displacement exampleAxis\r\n    --> Axis2d.through (Point2d.fromCoordinates ( 3, 6 ))\r\n    -->     (Direction2d.fromAngle (degrees 30))\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Axis2d.Axis2d units coordinates -> Axis2d.Axis2d units coordinates"},{"name":"translateIn","comment":" Translate an axis in a given direction by a given distance;\r\n\r\n    Axis2d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    Axis2d.translateBy\r\n        (Vector2d.withLength distance direction)\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Quantity.Quantity Basics.Float units -> Axis2d.Axis2d units coordinates -> Axis2d.Axis2d units coordinates"},{"name":"withDirection","comment":" Construct an axis with the given direction, through the given origin point.\r\nFlipped version of `through`. Having both versions allow you to do different\r\nthings with partial application:\r\n\r\n    -- A list of axes in different directions all passing\r\n    -- through the same origin point\r\n    List.map (Axis2d.through point) directions\r\n\r\n    -- A list of parallel axes (all having the same\r\n    -- direction) through different points\r\n    List.map (Axis2d.withDirection direction) points\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Point2d.Point2d units coordinates -> Axis2d.Axis2d units coordinates"},{"name":"x","comment":" The global X axis.\r\n\r\n    Axis2d.x\r\n    --> Axis2d.through Point2d.origin Direction2d.x\r\n\r\n","type":"Axis2d.Axis2d units coordinates"},{"name":"y","comment":" The global Y axis.\r\n\r\n    Axis2d.y\r\n    --> Axis2d.through Point2d.origin Direction2d.y\r\n\r\n","type":"Axis2d.Axis2d units coordinates"}],"binops":[]},{"name":"Axis3d","comment":" An `Axis3d` represents an infinitely long straight line in 3D and is defined\r\nby an origin point and direction. Axes have several uses, such as:\r\n\r\n  - Rotating around the axis\r\n  - Projecting onto the axis\r\n  - Measuring distance along the axis from the origin point\r\n\r\n@docs Axis3d\r\n\r\n\r\n# Constants\r\n\r\n@docs x, y, z\r\n\r\n\r\n# Constructors\r\n\r\n@docs through, withDirection, on\r\n\r\n\r\n# Properties\r\n\r\n@docs originPoint, direction\r\n\r\n\r\n# Transformations\r\n\r\n@docs reverse, moveTo, rotateAround, translateBy, translateIn, mirrorAcross, projectOnto\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn, projectInto\r\n\r\n","unions":[],"aliases":[{"name":"Axis3d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Axis3d units coordinates"}],"values":[{"name":"direction","comment":" Get the direction of an axis.\r\n\r\n    Axis3d.direction exampleAxis\r\n    --> Direction3d.y\r\n\r\n","type":"Axis3d.Axis3d units coordinates -> Direction3d.Direction3d coordinates"},{"name":"mirrorAcross","comment":" Mirror an axis across a plane.\r\n\r\n    Axis3d.mirrorAcross Plane3d.xy exampleAxis\r\n    --> Axis3d.withDirection Direction3d.y\r\n    -->     (Point3d.fromCoordinates ( 1, 2, -3 ))\r\n\r\n","type":"Geometry.Types.Plane3d units coordinates -> Axis3d.Axis3d units coordinates -> Axis3d.Axis3d units coordinates"},{"name":"moveTo","comment":" Move an axis so that it has the given origin point but unchanged direction.\r\n\r\n    newOrigin =\r\n        Point3d.fromCoordinates ( 3, 4, 5 )\r\n\r\n    Axis3d.moveTo newOrigin exampleAxis\r\n    --> Axis3d.withDirection Direction3d.y\r\n    -->     (Point3d.fromCoordinates ( 3, 4, 5 ))\r\n\r\n","type":"Point3d.Point3d units coordinates -> Axis3d.Axis3d units coordinates -> Axis3d.Axis3d units coordinates"},{"name":"on","comment":" Construct a 3D axis lying _on_ a sketch plane by providing a 2D axis\r\nspecified in XY coordinates _within_ the sketch plane.\r\n\r\n    axis2d =\r\n        Axis2d.through (Point2d.fromCoordinates ( 1, 3 ))\r\n            (Direction2d.fromAngle (degrees 30))\r\n\r\n    Axis3d.on SketchPlane3d.xy axis2d\r\n    --> Axis3d.through\r\n    -->     (Point3d.fromCoordinates ( 1, 3, 0 ))\r\n    -->     (Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 30)\r\n    -->         (degrees 0)\r\n    -->     )\r\n\r\n    Axis3d.on SketchPlane3d.zx axis2d\r\n    --> Axis3d.through\r\n    -->     (Point3d.fromCoordinates ( 3, 0, 1 ))\r\n    -->     (Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 0)\r\n    -->         (degrees 60)\r\n    -->     )\r\n\r\n","type":"Geometry.Types.SketchPlane3d units coordinates3d coordinates2d -> Axis2d.Axis2d units coordinates2d -> Axis3d.Axis3d units coordinates3d"},{"name":"originPoint","comment":" Get the origin point of an axis.\r\n\r\n    Axis3d.originPoint exampleAxis\r\n    --> Point3d.fromCoordinates ( 1, 2, 3 )\r\n\r\n","type":"Axis3d.Axis3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"placeIn","comment":" Take an axis defined in local coordinates relative to a given reference\r\nframe, and return that axis expressed in global coordinates.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 3, 3, 3 ))\r\n\r\n    Axis3d.placeIn localFrame exampleAxis\r\n    --> Axis3d.withDirection Direction3d.y\r\n    -->     (Point3d.fromCoordinates ( 4, 5, 6 ))\r\n\r\n","type":"Geometry.Types.Frame3d units globalCoordinates localCoordinates -> Axis3d.Axis3d units localCoordinates -> Axis3d.Axis3d units globalCoordinates"},{"name":"projectInto","comment":" Project an axis into a given sketch plane. Conceptually, this finds the\r\n[orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof the axis onto the plane and then expresses the projected axis in 2D sketch\r\ncoordinates.\r\n\r\nThis is only possible if the axis is not perpendicular to the sketch\r\nplane; if it is perpendicular, `Nothing` is returned.\r\n\r\n    Axis3d.projectInto SketchPlane3d.xy exampleAxis\r\n    --> Just\r\n    -->     (Axis2d.withDirection Direction2d.y\r\n    -->         (Point2d.fromCoordinates ( 1, 2 ))\r\n    -->     )\r\n\r\n    -- The global Y direction is the X direction of the\r\n    -- YZ plane:\r\n    Axis3d.projectInto SketchPlane3d.yz exampleAxis\r\n    --> Just\r\n    -->     (Axis2d.withDirection Direction2d.x\r\n    -->         (Point2d.fromCoordinates ( 2, 3 ))\r\n    -->     )\r\n\r\n    Axis3d.projectInto SketchPlane3d.xz exampleAxis\r\n    --> Nothing\r\n\r\n","type":"Geometry.Types.SketchPlane3d units coordinates3d coordinates2d -> Axis3d.Axis3d units coordinates3d -> Maybe.Maybe (Axis2d.Axis2d units coordinates2d)"},{"name":"projectOnto","comment":" Find the [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof an axis onto a plane. If the given axis is exactly perpendicular to the given\r\nplane, returns `Nothing`.\r\n\r\n    Axis3d.projectOnto Plane3d.xy exampleAxis\r\n    --> Just\r\n    -->     (Axis3d.withDirection Direction3d.y\r\n    -->         (Point3d.fromCoordinates ( 1, 2, 0 ))\r\n    -->     )\r\n\r\n    Axis3d.projectOnto Plane3d.xy Axis3d.z\r\n    --> Nothing\r\n\r\n","type":"Geometry.Types.Plane3d units coordinates -> Axis3d.Axis3d units coordinates -> Maybe.Maybe (Axis3d.Axis3d units coordinates)"},{"name":"relativeTo","comment":" Take an axis defined in global coordinates, and return it expressed in local\r\ncoordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 3, 3, 3 ))\r\n\r\n    Axis3d.relativeTo localFrame exampleAxis\r\n    --> Axis3d.withDirection Direction3d.y\r\n    -->     (Point3d.fromCoordinates ( -2, -1, 0 ))\r\n\r\n","type":"Geometry.Types.Frame3d units globalCoordinates localCoordinates -> Axis3d.Axis3d units globalCoordinates -> Axis3d.Axis3d units localCoordinates"},{"name":"reverse","comment":" Reverse the direction of an axis while keeping the same origin point.\r\n\r\n    Axis3d.reverse exampleAxis\r\n    --> Axis3d.withDirection Direction3d.negativeY\r\n    -->     (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n","type":"Axis3d.Axis3d units coordinates -> Axis3d.Axis3d units coordinates"},{"name":"rotateAround","comment":" Rotate an axis around another axis by a given angle. The axis to rotate\r\naround is given first and the axis to rotate is given last.\r\n\r\n    Axis3d.rotateAround Axis3d.z (degrees 90) exampleAxis\r\n    --> Axis3d.withDirection Direction3d.negativeX\r\n    -->     (Point3d.fromCoordinates ( -2, 1, 3 ))\r\n\r\n","type":"Axis3d.Axis3d units coordinates -> Angle.Angle -> Axis3d.Axis3d units coordinates -> Axis3d.Axis3d units coordinates"},{"name":"through","comment":" Construct an axis through the given point, with the given direction.\r\n\r\n    exampleAxis =\r\n        Axis3d.through\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n            Direction3d.y\r\n\r\n","type":"Point3d.Point3d units coordinates -> Direction3d.Direction3d coordinates -> Axis3d.Axis3d units coordinates"},{"name":"translateBy","comment":" Translate an axis by a given displacement. Applies the given displacement to\r\nthe axis' origin point and leaves the direction unchanged.\r\n\r\n    displacement =\r\n        Vector3d.fromComponents ( 3, 3, 3 )\r\n\r\n    Axis3d.translateBy displacement exampleAxis\r\n    --> Axis3d.withDirection Direction3d.y\r\n    -->     (Point3d.fromCoordinates ( 4, 5, 6 ))\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Axis3d.Axis3d units coordinates -> Axis3d.Axis3d units coordinates"},{"name":"translateIn","comment":" Translate an axis in a given direction by a given distance;\r\n\r\n    Axis3d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    Axis3d.translateBy\r\n        (Vector3d.withLength distance direction)\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Quantity.Quantity Basics.Float units -> Axis3d.Axis3d units coordinates -> Axis3d.Axis3d units coordinates"},{"name":"withDirection","comment":" Construct an axis with the given directoin, through the given point. Flipped\r\nversion of `through`. Having both versions allow you to do different\r\nthings with partial application:\r\n\r\n    -- A list of axes in different directions all passing\r\n    -- through the same origin point\r\n    List.map (Axis3d.through point) directions\r\n\r\n    -- A list of parallel axes (all having the same\r\n    -- direction) through different points\r\n    List.map (Axis3d.withDirection direction) points\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Point3d.Point3d units coordinates -> Axis3d.Axis3d units coordinates"},{"name":"x","comment":" The global X axis.\r\n\r\n    Axis3d.x\r\n    --> Axis3d.through Point3d.origin Direction3d.x\r\n\r\n","type":"Axis3d.Axis3d units coordinates"},{"name":"y","comment":" The global Y axis.\r\n\r\n    Axis3d.y\r\n    --> Axis3d.through Point3d.origin Direction3d.y\r\n\r\n","type":"Axis3d.Axis3d units coordinates"},{"name":"z","comment":" The global Z axis.\r\n\r\n    Axis3d.z\r\n    --> Axis3d.through Point3d.origin Direction3d.z\r\n\r\n","type":"Axis3d.Axis3d units coordinates"}],"binops":[]},{"name":"BoundingBox2d","comment":" A `BoundingBox2d` is a rectangular box in 2D defined by its minimum and\r\nmaximum X and Y values. It is possible to generate bounding boxes for most\r\ngeometric objects; for example, [`Triangle2d.boundingBox`](Triangle2d#boundingBox)\r\ntakes a `Triangle2d` and returns a `BoundingBox2d` that contains that triangle.\r\nThere are several use cases where it is more efficient to deal with the bounding\r\nbox of an object than the object itself, such as:\r\n\r\n  - Intersection checking: If (for example) the bounding boxes of a line segment\r\n    and a triangle do not overlap, then the line segment and triangle cannot\r\n    possibly intersect each other. Expensive intersection checking therefore\r\n    only has to be performed for line segments and triangles whose bounding\r\n    boxes _do_ overlap.\r\n  - 2D rendering: When rendering a 2D scene, any object whose bounding box does\r\n    not overlap the viewing area must itself be completely outside the viewing\r\n    area, and therefore does not have to be drawn. This provides a simple form\r\n    of culling.\r\n\r\n@docs BoundingBox2d\r\n\r\n\r\n# Constructors\r\n\r\n@docs fromExtrema, singleton, from, hull, intersection, aggregate, containingPoints\r\n\r\n\r\n# Properties\r\n\r\n@docs extrema, minX, maxX, minY, maxY, dimensions, midX, midY, centerPoint\r\n\r\n\r\n# Queries\r\n\r\n@docs contains, isContainedIn, intersects, overlappingBy, separatedBy\r\n\r\n\r\n# Transformations\r\n\r\n@docs scaleAbout, translateBy, translateIn, expandBy, offsetBy\r\n\r\n","unions":[],"aliases":[{"name":"BoundingBox2d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.BoundingBox2d units coordinates"}],"values":[{"name":"aggregate","comment":" Construct a bounding box containing all bounding boxes in the given list. If\r\nthe list is empty, returns `Nothing`.\r\n\r\n    singletonBox =\r\n        BoundingBox2d.singleton\r\n            (Point2d.fromCoordinates ( 1, 3 ))\r\n\r\n    BoundingBox2d.aggregate [ exampleBox, singletonBox ]\r\n    --> Just\r\n    -->     (BoundingBox2d.fromExtrema\r\n    -->         { minX = 1,\r\n    -->         , maxX = 8\r\n    -->         , minY = 2\r\n    -->         , maxY = 6\r\n    -->         }\r\n    -->     )\r\n\r\n    BoundingBox2d.aggregate [ exampleBox ]\r\n    --> Just exampleBox\r\n\r\n    BoundingBox2d.aggregate []\r\n    --> Nothing\r\n\r\nIf you have exactly two bounding boxes, you can use [`BoundingBox2d.hull`](#hull)\r\ninstead (which returns a `BoundingBox2d` instead of a `Maybe BoundingBox2d`).\r\n\r\n","type":"List.List (BoundingBox2d.BoundingBox2d units coordinates) -> Maybe.Maybe (BoundingBox2d.BoundingBox2d units coordinates)"},{"name":"centerPoint","comment":" Get the point at the center of a bounding box.\r\n\r\n    BoundingBox2d.centerPoint exampleBox\r\n    --> Point2d.fromCoordinates ( 5.5, 4 )\r\n\r\n","type":"BoundingBox2d.BoundingBox2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"containingPoints","comment":" Construct a bounding box containing all points in the given list. If the\r\nlist is empty, returns `Nothing`.\r\n\r\n    BoundingBox2d.containingPoints\r\n        [ Point2d.fromCoordinates ( 2, 3 )\r\n        , Point2d.fromCoordinates ( -1, 5 )\r\n        , Point2d.fromCoordinates ( 6, 4 )\r\n        ]\r\n    --> Just <|\r\n    -->     BoundingBox2d.fromExtrema\r\n    -->         { minX = -1\r\n    -->         , maxX = 6\r\n    -->         , minY = 3\r\n    -->         , maxY = 5\r\n    -->         }\r\n\r\n    BoundingBox2d.containingPoints []\r\n    --> Nothing\r\n\r\n","type":"List.List (Point2d.Point2d units coordinates) -> Maybe.Maybe (BoundingBox2d.BoundingBox2d units coordinates)"},{"name":"contains","comment":" Check if a bounding box contains a particular point.\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 4, 3 )\r\n\r\n    BoundingBox2d.contains point exampleBox\r\n    --> True\r\n\r\n    BoundingBox2d.contains Point2d.origin exampleBox\r\n    --> False\r\n\r\n","type":"Point2d.Point2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates -> Basics.Bool"},{"name":"dimensions","comment":" Get the X and Y dimensions (width and height) of a bounding box.\r\n\r\n\r\n    ( width, height ) =\r\n        BoundingBox2d.dimensions exampleBox\r\n\r\n    --> width = 5\r\n    --> height = 4\r\n\r\n","type":"BoundingBox2d.BoundingBox2d units coordinates -> ( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units )"},{"name":"expandBy","comment":" Expand the given bounding box in all directions by the given offset:\r\n\r\n    BoundingBox2d.expandBy 3 exampleBox\r\n    --> BoundingBox2d.fromExtrema\r\n    -->     { minX = 0\r\n    -->     , maxX = 11\r\n    -->     , minY = -1\r\n    -->     , maxY = 9\r\n    -->     }\r\n\r\nNegative offsets will be treated as positive (the absolute value will be used),\r\nso the resulting box will always be at least as large as the original. If you\r\nneed to be able to contract a bounding box, use\r\n[`offsetBy`](BoundingBox2d#offsetBy) instead.\r\n\r\n","type":"Quantity.Quantity Basics.Float units -> BoundingBox2d.BoundingBox2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates"},{"name":"extrema","comment":" Get the minimum and maximum X and Y values of a bounding box in a single\r\nrecord.\r\n\r\n    BoundingBox2d.extrema exampleBox\r\n    --> { minX = 3\r\n    --> , maxX = 8\r\n    --> , minY = 2\r\n    --> , maxY = 6\r\n    --> }\r\n\r\nCan be useful when combined with record destructuring, for example\r\n\r\n\r\n    { minX, maxX, minY, maxY } =\r\n        BoundingBox2d.extrema exampleBox\r\n\r\n    --> minX = 3\r\n    --> maxX = 8\r\n    --> minY = 2\r\n    --> maxY = 6\r\n\r\n","type":"BoundingBox2d.BoundingBox2d units coordinates -> { minX : Quantity.Quantity Basics.Float units, maxX : Quantity.Quantity Basics.Float units, minY : Quantity.Quantity Basics.Float units, maxY : Quantity.Quantity Basics.Float units }"},{"name":"from","comment":" Construct a bounding box with the two given points as two of its corners.\r\nThe points can be given in any order and don't have to represent the 'primary'\r\ndiagonal of the bounding box.\r\n\r\n    firstPoint =\r\n        Point2d.fromCoordinates ( 2, 3 )\r\n\r\n    secondPoint =\r\n        Point2d.fromCoordinates ( -1, 5 )\r\n\r\n    BoundingBox2d.from firstPoint secondPoint\r\n    --> BoundingBox2d.fromExtrema\r\n    -->     { minX = -1\r\n    -->     , maxX = 2\r\n    -->     , minY = 3\r\n    -->     , maxY = 5\r\n    -->     }\r\n\r\n","type":"Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates"},{"name":"fromExtrema","comment":" Construct a bounding box from its minimum and maximum X and Y values:\r\n\r\n    exampleBox =\r\n        BoundingBox2d.fromExtrema\r\n            { minX = 3\r\n            , maxX = 8\r\n            , minY = 2\r\n            , maxY = 6\r\n            }\r\n\r\nIf the minimum and maximum values are provided in the wrong order (for example\r\nif <code>minX&nbsp;>&nbsp;maxX</code>), then they will be swapped so that the\r\nresulting bounding box is valid.\r\n\r\n","type":"{ minX : Quantity.Quantity Basics.Float units, maxX : Quantity.Quantity Basics.Float units, minY : Quantity.Quantity Basics.Float units, maxY : Quantity.Quantity Basics.Float units } -> BoundingBox2d.BoundingBox2d units coordinates"},{"name":"hull","comment":" Build a bounding box that contains both given bounding boxes.\r\n\r\n    firstBox =\r\n        BoundingBox2d.fromExtrema\r\n            { minX = 1\r\n            , maxX = 4\r\n            , minY = 2\r\n            , maxY = 3\r\n            }\r\n\r\n    secondBox =\r\n        BoundingBox2d.fromExtrema\r\n            { minX = -2\r\n            , maxX = 2\r\n            , minY = 4\r\n            , maxY = 5\r\n            }\r\n\r\n    BoundingBox2d.hull firstBox secondBox\r\n    --> BoundingBox2d.fromExtrema\r\n    -->     { minX = -2\r\n    -->     , maxX = 4\r\n    -->     , minY = 2\r\n    -->     , maxY = 5\r\n    -->     }\r\n\r\n","type":"BoundingBox2d.BoundingBox2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates"},{"name":"intersection","comment":" Attempt to build a bounding box that contains all points common to both\r\ngiven bounding boxes. If the given boxes do not intersect, returns `Nothing`.\r\n\r\n    firstBox =\r\n        BoundingBox2d.fromExtrema\r\n            { minX = 1\r\n            , maxX = 4\r\n            , minY = 2\r\n            , maxY = 3\r\n            }\r\n\r\n    secondBox =\r\n        BoundingBox2d.fromExtrema\r\n            { minX = 2\r\n            , maxX = 5\r\n            , minY = 1\r\n            , maxY = 4\r\n            }\r\n\r\n    thirdBox =\r\n        BoundingBox2d.fromExtrema\r\n            { minX = 1\r\n            , maxX = 4\r\n            , minY = 4\r\n            , maxY = 5\r\n            }\r\n\r\n    BoundingBox2d.intersection firstBox secondBox\r\n    --> Just\r\n    -->     (BoundingBox2d.fromExtrema\r\n    -->         { minX = 2\r\n    -->         , maxX = 4\r\n    -->         , minY = 2\r\n    -->         , maxY = 3\r\n    -->         }\r\n    -->     )\r\n\r\n    BoundingBox2d.intersection firstBox thirdBox\r\n    --> Nothing\r\n\r\nIf two boxes just touch along an edge or at a corner, they are still considered\r\nto have an intersection, even though that intersection will have zero area (at\r\nleast one of its dimensions will be zero):\r\n\r\n    firstBox =\r\n        BoundingBox2d.fromExtrema\r\n            { minX = 0\r\n            , maxX = 1\r\n            , minY = 0\r\n            , maxY = 2\r\n            }\r\n\r\n    secondBox =\r\n        BoundingBox2d.fromExtrema\r\n            { minX = 1\r\n            , maxX = 2\r\n            , minY = 1\r\n            , maxY = 3\r\n            }\r\n\r\n    BoundingBox2d.intersection firstBox secondBox\r\n    --> Just\r\n    -->     (BoundingBox2d.fromExtrema\r\n    -->         { minX = 1\r\n    -->         , maxX = 1\r\n    -->         , minY = 1\r\n    -->         , maxY = 2\r\n    -->         }\r\n    -->     )\r\n\r\n","type":"BoundingBox2d.BoundingBox2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates -> Maybe.Maybe (BoundingBox2d.BoundingBox2d units coordinates)"},{"name":"intersects","comment":" Test if two boxes touch or overlap at all (have any points in common);\r\n\r\n    BoundingBox2d.intersects firstBox secondBox\r\n\r\nis equivalent to\r\n\r\n    BoundingBox2d.intersection firstBox secondBox\r\n        /= Nothing\r\n\r\nbut is more efficient.\r\n\r\n    firstBox =\r\n        BoundingBox2d.fromExtrema\r\n            { minX = 0\r\n            , maxX = 3\r\n            , minY = 0\r\n            , maxY = 2\r\n            }\r\n\r\n    secondBox =\r\n        BoundingBox2d.fromExtrema\r\n            { minX = 0\r\n            , maxX = 3\r\n            , minY = 1\r\n            , maxY = 4\r\n            }\r\n\r\n    thirdBox =\r\n        BoundingBox2d.fromExtrema\r\n            { minX = 0\r\n            , maxX = 3\r\n            , minY = 4\r\n            , maxY = 5\r\n            }\r\n\r\n    BoundingBox2d.intersects firstBox secondBox\r\n    --> True\r\n\r\n    BoundingBox2d.intersects firstBox thirdBox\r\n    --> False\r\n\r\n","type":"BoundingBox2d.BoundingBox2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates -> Basics.Bool"},{"name":"isContainedIn","comment":" Test if the second given bounding box is fully contained within the first\r\n(is a subset of it).\r\n\r\n    outerBox =\r\n        BoundingBox2d.fromExtrema\r\n            { minX = 0\r\n            , maxX = 10\r\n            , minY = 0\r\n            , maxY = 10\r\n            }\r\n\r\n    innerBox =\r\n        BoundingBox2d.fromExtrema\r\n            { minX = 1\r\n            , maxX = 5\r\n            , minY = 3\r\n            , maxY = 9\r\n            }\r\n\r\n    overlappingBox =\r\n        BoundingBox2d.fromExtrema\r\n            { minX = 1\r\n            , maxX = 5\r\n            , minY = 3\r\n            , maxY = 12\r\n            }\r\n\r\n    BoundingBox2d.isContainedIn outerBox innerBox\r\n    --> True\r\n\r\n    BoundingBox2d.isContainedIn outerBox overlappingBox\r\n    --> False\r\n\r\n","type":"BoundingBox2d.BoundingBox2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates -> Basics.Bool"},{"name":"maxX","comment":" Get the maximum X value of a bounding box.\r\n\r\n    BoundingBox2d.maxX exampleBox\r\n    --> 8\r\n\r\n","type":"BoundingBox2d.BoundingBox2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"maxY","comment":" Get the maximum Y value of a bounding box.\r\n\r\n    BoundingBox2d.maxY exampleBox\r\n    --> 6\r\n\r\n","type":"BoundingBox2d.BoundingBox2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"midX","comment":" Get the median X value of a bounding box.\r\n\r\n    BoundingBox2d.midX exampleBox\r\n    --> 5.5\r\n\r\n","type":"BoundingBox2d.BoundingBox2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"midY","comment":" Get the median Y value of a bounding box.\r\n\r\n    BoundingBox2d.midY exampleBox\r\n    --> 4\r\n\r\n","type":"BoundingBox2d.BoundingBox2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"minX","comment":" Get the minimum X value of a bounding box.\r\n\r\n    BoundingBox2d.minX exampleBox\r\n    --> 3\r\n\r\n","type":"BoundingBox2d.BoundingBox2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"minY","comment":" Get the minimum Y value of a bounding box.\r\n\r\n    BoundingBox2d.minY exampleBox\r\n    --> 2\r\n\r\n","type":"BoundingBox2d.BoundingBox2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"offsetBy","comment":" Expand or shrink the given bounding box in all the directions by the given\r\ndistance. A positive offset will cause the bounding box to expand and a negative\r\nvalue will cause it to shrink.\r\n\r\n    BoundingBox2d.offsetBy 2 exampleBox\r\n    --> Just <|\r\n    -->     BoundingBox2d.fromExtrema\r\n    -->         { minX = 1\r\n    -->         , maxX = 10\r\n    -->         , minY = 0\r\n    -->         , maxY = 8\r\n    -->         }\r\n\r\n    BoundingBox2d.offsetBy -1 exampleBox\r\n    --> Just <|\r\n    -->     BoundingBox2d.fromExtrema\r\n    -->         { minX = 4\r\n    -->         , maxX = 7\r\n    -->         , minY = 3\r\n    -->         , maxY = 5\r\n    -->         }\r\n\r\nReturns `Nothing` if the offset is negative and large enough to cause the\r\nbounding box to vanish (that is, if the offset is larger than half the height or\r\nhalf the width of the bounding box, whichever is less):\r\n\r\n    BoundingBox2d.offsetBy -3 exampleBox\r\n    --> Nothing\r\n\r\nIf you only want to expand a bounding box, you can use\r\n[`expandBy`](BoundingBox2d#expandBy) instead (which does not return a `Maybe`).\r\n\r\n","type":"Quantity.Quantity Basics.Float units -> BoundingBox2d.BoundingBox2d units coordinates -> Maybe.Maybe (BoundingBox2d.BoundingBox2d units coordinates)"},{"name":"overlappingBy","comment":" Check if one box overlaps another by less than, greater than or equal to a\r\ngiven amount. For example, you could implement a tolerant collision check (one\r\nthat only returns true if the boxes overlap by at least some small finite\r\namount, and ignores boxes that just barely touch each other) as\r\n\r\n    boxesCollide box1 box2 =\r\n        BoundingBox2d.overlappingBy GT 0.001 box1 box2\r\n\r\nThis can be read as \"`box1` and `box2` are overlapping by greater than 0.001\r\nunits\". (The [`Order`](https://package.elm-lang.org/packages/elm/core/latest/Basics#Order)\r\ntype and its three values `LT`, `GT` and `EQ` are defined in Elm's `Basics`\r\nmodule so are available by default in any Elm program.)\r\n\r\nOverlap is defined as the _minimum_ distance one box would have to move so that\r\nit did not touch the other, and is always positive for any two overlapping\r\nboxes.\r\n\r\nBoxes that just touch are considered to have an overlap of zero, which is\r\ndistinct from 'no overlap'. Boxes that do not touch or overlap at all are\r\nconsidered to have an overlap which is less than zero but not comparable to any\r\nnegative number.\r\n\r\n\r\n### Less than\r\n\r\n  - `overlappingBy LT 1e-3` will return true if the two boxes overlap by less\r\n    than 0.001 units or if they do not overlap at all (false if they overlap by\r\n    more than 0.001 units).\r\n  - `overlappingBy LT 0` will return true only if the two boxes don't touch or\r\n    overlap at all.\r\n  - `overlappingBy LT -1e-3` will always return false! If you care about _how\r\n    much_ two boxes are separated by, use `separatedBy` instead.\r\n\r\n\r\n### Greater than\r\n\r\n  - `overlappingBy GT 1e-3` will return true if the two boxes overlap by at\r\n    least 0.001 units (false if they overlap by less than that or do not overlap\r\n    at all).\r\n  - `overlappingBy GT 0` will return true if the two boxes overlap by any\r\n    non-zero amount (false if they just touch or do not overlap at all).\r\n  - `overlappingBy GT -1e-3` doesn't make a lot of sense but will return true if\r\n    the boxes touch or overlap at all (false if they don't overlap, regardless\r\n    of how close they are to overlapping). In this case, though, it would make\r\n    more sense to just user `intersects` instead.\r\n\r\n\r\n### Equal to\r\n\r\nChecking whether two boxes overlap by exactly a given amount is pretty weird and\r\nvulnerable to floating-point roundoff, but is defined as follows:\r\n\r\n  - `overlappingBy EQ 1e-3` will return true if the two boxes overlap by exactly\r\n    0.001 units.\r\n  - `overlappingBy EQ 0` will return true if and only if the boxes just touch\r\n    each other.\r\n  - `overlappingBy EQ -1e-3` will always return false.\r\n\r\n","type":"Basics.Order -> Quantity.Quantity Basics.Float units -> BoundingBox2d.BoundingBox2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates -> Basics.Bool"},{"name":"scaleAbout","comment":" Scale a bounding box about a given point by a given scale.\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 4, 4 )\r\n\r\n    BoundingBox2d.scaleAbout point 2 exampleBox\r\n    --> BoundingBox2d.fromExtrema\r\n    -->     { minX = 2\r\n    -->     , maxX = 12\r\n    -->     , minY = 0\r\n    -->     , maxY = 8\r\n    -->     }\r\n\r\n","type":"Point2d.Point2d units coordinates -> Basics.Float -> BoundingBox2d.BoundingBox2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates"},{"name":"separatedBy","comment":" Check if one box is separated from another by less than, greater than or\r\nequal to a given amount. For example, to perform clash detection between some\r\nobjects, you could use `separatedBy` on those objects' bounding boxes as a quick\r\ncheck to see if the objects had a gap of at least 1 cm between them:\r\n\r\n    safelySeparated box1 box2 =\r\n        BoundingBox2d.separatedBy GT 0.01 box1 box2\r\n\r\nThis can be read as \"`box1` and `box2` are separated by greater than 0.01\r\nunits\". (The [`Order`](https://package.elm-lang.org/packages/elm/core/latest/Basics#Order)\r\ntype and its three values `LT`, `GT` and `EQ` are defined in Elm's `Basics`\r\nmodule so are available by default in any Elm program.)\r\n\r\nSeparation is defined as the _minimum_ distance one box would have to move\r\nso that it touched the other, and is always positive for any two boxes that do\r\nnot touch.\r\n\r\nBoxes that just touch are considered to have a separation of zero, which is\r\ndistinct from 'no separation'. 'No separation' (overlap) is considered to be\r\nless than zero but not comparable to any negative number.\r\n\r\n\r\n### Less than\r\n\r\n  - `separatedBy LT 1e-3` will return true if the two boxes are separated by\r\n    less than 0.001 units or if they touch or overlap (false if they are\r\n    separated by at least 0.001 units).\r\n  - `separatedBy LT 0` will return true only if the boxes overlap by some\r\n    non-zero amount.\r\n  - `separatedBy LT -1e-3` will always return false! If you care about _how\r\n    much_ two boxes overlap by, use `overlappingBy` instead.\r\n\r\n\r\n### Greater than\r\n\r\n  - `separatedBy GT 1e-3` will return true if the two boxes are separated by at\r\n    least 0.001 units (false if they are separated by less than that or if they\r\n    touch or overlap).\r\n  - `separatedBy GT 0` will return true if the two boxes are separated by any\r\n    non-zero amount (false if they touch or overlap).\r\n  - `separatedBy GT -1e-3` doesn't make a lot of sense but will return true if\r\n    the boxes just touch or are separated by any amount (false if they overlap\r\n    by any non-zero amount).\r\n\r\n\r\n### Equal to\r\n\r\nChecking whether two boxes are separated by exactly a given amount is pretty\r\nweird and vulnerable to floating-point roundoff, but is defined as follows:\r\n\r\n  - `separatedBy EQ 1e-3` will return true if the two boxes are separated by\r\n    exactly 0.001 units.\r\n  - `separatedBy EQ 0` will return true if and only if the boxes just touch each\r\n    other.\r\n  - `separatedBy EQ -3` will always return false.\r\n\r\n","type":"Basics.Order -> Quantity.Quantity Basics.Float units -> BoundingBox2d.BoundingBox2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates -> Basics.Bool"},{"name":"singleton","comment":" Construct a zero-width bounding box containing a single point.\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 2, 3 )\r\n\r\n    BoundingBox2d.singleton point\r\n    --> BoundingBox2d.fromExtrema\r\n    -->     { minX = 2\r\n    -->     , maxX = 2\r\n    -->     , minY = 3\r\n    -->     , maxY = 3\r\n    -->     }\r\n\r\n","type":"Point2d.Point2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates"},{"name":"translateBy","comment":" Translate a bounding box by a given displacement.\r\n\r\n    displacement =\r\n        Vector2d.fromComponents ( 2, -3 )\r\n\r\n    BoundingBox2d.translateBy displacement exampleBox\r\n    --> BoundingBox2d.fromExtrema\r\n    -->     { minX = 5\r\n    -->     , maxX = 10\r\n    -->     , minY = -1\r\n    -->     , maxY = 3\r\n    -->     }\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates"},{"name":"translateIn","comment":" Translate a bounding box in a given direction by a given distance;\r\n\r\n    BoundingBox2d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    BoundingBox2d.translateBy\r\n        (Vector2d.withLength distance direction)\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Quantity.Quantity Basics.Float units -> BoundingBox2d.BoundingBox2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates"}],"binops":[]},{"name":"BoundingBox3d","comment":" A `BoundingBox3d` is a rectangular box in 3D defined by its minimum and\r\nmaximum X, Y and Z values. It is possible to generate bounding boxes for most\r\ngeometric objects; for example, [`Triangle3d.boundingBox`](Triangle3d#boundingBox)\r\ntakes a `Triangle3d` and returns a `BoundingBox3d` that contains that triangle.\r\nThere are several use cases where it is more efficient to deal with the bounding\r\nbox of an object than the object itself, such as:\r\n\r\n  - Intersection checking: If (for example) the bounding boxes of a line segment\r\n    and a triangle do not overlap, then the line segment and triangle cannot\r\n    possibly intersect each other. Expensive intersection checking therefore\r\n    only has to be performed for line segments and triangles whose bounding\r\n    boxes _do_ overlap.\r\n  - 3D rendering: When rendering a 3D scene, any object whose bounding box is\r\n    not visible must itself be not visible, and therefore does not have to be\r\n    drawn. This provides a simple form of culling.\r\n\r\n@docs BoundingBox3d\r\n\r\n\r\n# Constructors\r\n\r\n@docs fromExtrema, singleton, from, hull, intersection, aggregate, containingPoints\r\n\r\n\r\n# Properties\r\n\r\n@docs extrema, minX, maxX, minY, maxY, minZ, maxZ, dimensions, midX, midY, midZ, centerPoint\r\n\r\n\r\n# Queries\r\n\r\n@docs contains, isContainedIn, intersects, overlappingBy, separatedBy\r\n\r\n\r\n# Transformations\r\n\r\n@docs scaleAbout, translateBy, translateIn, offsetBy, expandBy\r\n\r\n","unions":[],"aliases":[{"name":"BoundingBox3d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.BoundingBox3d units coordinates"}],"values":[{"name":"aggregate","comment":" Construct a bounding box containing all bounding boxes in the given list. If\r\nthe list is empty, returns `Nothing`.\r\n\r\n    singletonBox =\r\n        BoundingBox3d.singleton\r\n            (Point3d.fromCoordinates ( 2, 1, 0 ))\r\n\r\n    BoundingBox3d.aggregate [ exampleBox, singletonBox ]\r\n    --> Just\r\n    -->     (BoundingBox3d.fromExtrema\r\n    -->         { minX = -2,\r\n    -->         , maxX = 2\r\n    -->         , minY = 1\r\n    -->         , maxY = 5\r\n    -->         , minZ = 0\r\n    -->         , maxZ = 4\r\n    -->         }\r\n    -->     )\r\n\r\n    BoundingBox3d.aggregate [ exampleBox ]\r\n    --> Just exampleBox\r\n\r\n    BoundingBox3d.aggregate []\r\n    --> Nothing\r\n\r\nIf you have exactly two bounding boxes, you can use [`BoundingBox3d.hull`](#hull)\r\ninstead (which returns a `BoundingBox3d` instead of a `Maybe BoundingBox3d`).\r\n\r\n","type":"List.List (BoundingBox3d.BoundingBox3d units coordinates) -> Maybe.Maybe (BoundingBox3d.BoundingBox3d units coordinates)"},{"name":"centerPoint","comment":" Get the point at the center of a bounding box.\r\n\r\n    BoundingBox3d.centerPoint exampleBox\r\n    --> Point3d.fromCoordinates ( 0, 3.5, 3.5 )\r\n\r\n","type":"BoundingBox3d.BoundingBox3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"containingPoints","comment":" Construct a bounding box containing all points in the given list. If the\r\nlist is empty, returns `Nothing`.\r\n\r\n    BoundingBox3d.containingPoints\r\n        [ Point3d.fromCoordinates ( 2, 1, 3 )\r\n        , Point3d.fromCoordinates ( -1, 5, -2 )\r\n        , Point3d.fromCoordinates ( 6, 4, 2 )\r\n        ]\r\n    --> Just <|\r\n    -->     BoundingBox3d.fromExtrema\r\n    -->         { minX = -1\r\n    -->         , maxX = 6\r\n    -->         , minY = 1\r\n    -->         , maxY = 5\r\n    -->         , minZ = -2\r\n    -->         , maxZ = 3\r\n    -->         }\r\n\r\n    BoundingBox3d.containingPoints []\r\n    --> Nothing\r\n\r\n","type":"List.List (Point3d.Point3d units coordinates) -> Maybe.Maybe (BoundingBox3d.BoundingBox3d units coordinates)"},{"name":"contains","comment":" Check if a bounding box contains a particular point.\r\n\r\n    firstPoint =\r\n        Point3d.fromCoordinates ( 1, 4, 3 )\r\n\r\n    secondPoint =\r\n        Point3d.fromCoordinates ( 3, 4, 5 )\r\n\r\n    BoundingBox3d.contains firstPoint exampleBox\r\n    --> True\r\n\r\n    BoundingBox3d.contains secondPoint exampleBox\r\n    --> False\r\n\r\n","type":"Point3d.Point3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates -> Basics.Bool"},{"name":"dimensions","comment":" Get the X, Y and Z dimensions (widths) of a bounding box.\r\n\r\n    BoundingBox3d.dimensions exampleBox\r\n    --> ( 4, 3, 1 )\r\n\r\n","type":"BoundingBox3d.BoundingBox3d units coordinates -> ( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units )"},{"name":"expandBy","comment":" Expand the given bounding box in all directions by the given offset:\r\n\r\n    BoundingBox3d.expandBy 3 exampleBox\r\n    --> BoundingBox3d.fromExtrema\r\n    -->     { minX = -5\r\n    -->     , maxX = 5\r\n    -->     , minY = -1\r\n    -->     , maxY = 8\r\n    -->     , minZ = 0\r\n    -->     , maxZ = 7\r\n    -->     }\r\n\r\nNegative offsets will be treated as positive (the absolute value will be used),\r\nso the resulting box will always be at least as large as the original. If you\r\nneed to be able to contract a bounding box, use\r\n[`offsetBy`](BoundingBox3d#offsetBy) instead.\r\n\r\n","type":"Quantity.Quantity Basics.Float units -> BoundingBox3d.BoundingBox3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates"},{"name":"extrema","comment":" Get the minimum and maximum X, Y and Z values of a bounding box in a single\r\nrecord.\r\n\r\n    BoundingBox3d.extrema exampleBox\r\n    --> { minX = -2\r\n    --> , maxX = 2\r\n    --> , minY = 2\r\n    --> , maxY = 5\r\n    --> , minZ = 3\r\n    --> , maxZ = 4\r\n    --> }\r\n\r\nCan be useful when combined with record destructuring, for example\r\n\r\n\r\n    { minX, maxX, minY, maxY, minZ, maxZ } =\r\n        BoundingBox3d.extrema exampleBox\r\n\r\n    --> minX = -2\r\n    --> maxX = 2\r\n    --> minY = 2\r\n    --> maxY = 5\r\n    --> minZ = 3\r\n    --> maxZ = 4\r\n\r\n","type":"BoundingBox3d.BoundingBox3d units coordinates -> { minX : Quantity.Quantity Basics.Float units, maxX : Quantity.Quantity Basics.Float units, minY : Quantity.Quantity Basics.Float units, maxY : Quantity.Quantity Basics.Float units, minZ : Quantity.Quantity Basics.Float units, maxZ : Quantity.Quantity Basics.Float units }"},{"name":"from","comment":" Construct a bounding box with the two given points as two of its corners.\r\nThe points can be given in any order and don't have to represent the 'primary'\r\ndiagonal of the bounding box.\r\n\r\n    firstPoint =\r\n        Point3d.fromCoordinates ( 2, 1, 3 )\r\n\r\n    secondPoint =\r\n        Point3d.fromCoordinates ( -1, 5, -2 )\r\n\r\n    BoundingBox3d.from firstPoint secondPoint\r\n    --> BoundingBox3d.fromExtrema\r\n    -->     { minX = -1\r\n    -->     , maxX = 2\r\n    -->     , minY = 1\r\n    -->     , maxY = 5\r\n    -->     , minZ = -2\r\n    -->     , maxZ = 3\r\n    -->     }\r\n\r\n","type":"Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates"},{"name":"fromExtrema","comment":" Construct a bounding box from its minimum and maximum X, Y and Z values:\r\n\r\n    exampleBox =\r\n        BoundingBox3d.fromExtrema\r\n            { minX = -2\r\n            , maxX = 2\r\n            , minY = 2\r\n            , maxY = 5\r\n            , minZ = 3\r\n            , maxZ = 4\r\n            }\r\n\r\nIf the minimum and maximum values are provided in the wrong order (for example\r\nif <code>minX&nbsp;>&nbsp;maxX</code>), then they will be swapped so that the\r\nresulting bounding box is valid.\r\n\r\n","type":"{ minX : Quantity.Quantity Basics.Float units, maxX : Quantity.Quantity Basics.Float units, minY : Quantity.Quantity Basics.Float units, maxY : Quantity.Quantity Basics.Float units, minZ : Quantity.Quantity Basics.Float units, maxZ : Quantity.Quantity Basics.Float units } -> BoundingBox3d.BoundingBox3d units coordinates"},{"name":"hull","comment":" Build a bounding box that contains both given bounding boxes.\r\n\r\n    firstBox =\r\n        BoundingBox3d.fromExtrema\r\n            { minX = 1\r\n            , maxX = 4\r\n            , minY = 2\r\n            , maxY = 3\r\n            , minZ = 0\r\n            , maxZ = 5\r\n            }\r\n\r\n    secondBox =\r\n        BoundingBox3d.fromExtrema\r\n            { minX = -2\r\n            , maxX = 2\r\n            , minY = 4\r\n            , maxY = 5\r\n            , minZ = -1\r\n            , maxZ = 0\r\n            }\r\n\r\n    BoundingBox3d.hull firstBox secondBox\r\n    --> BoundingBox3d.fromExtrema\r\n    -->     { minX = -2\r\n    -->     , maxX = 4\r\n    -->     , minY = 2\r\n    -->     , maxY = 5\r\n    -->     , minZ = -1\r\n    -->     , maxZ = 5\r\n    -->     }\r\n\r\n","type":"BoundingBox3d.BoundingBox3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates"},{"name":"intersection","comment":" Attempt to build a bounding box that contains all points common to both\r\ngiven bounding boxes. If the given boxes do not overlap, returns `Nothing`.\r\n\r\n    firstBox =\r\n        BoundingBox3d.fromExtrema\r\n            { minX = 1\r\n            , maxX = 4\r\n            , minY = 2\r\n            , maxY = 3\r\n            , minZ = 5\r\n            , maxZ = 8\r\n            }\r\n\r\n    secondBox =\r\n        BoundingBox3d.fromExtrema\r\n            { minX = 2\r\n            , maxX = 5\r\n            , minY = 1\r\n            , maxY = 4\r\n            , minZ = 6\r\n            , maxZ = 7\r\n            }\r\n\r\n    thirdBox =\r\n        BoundingBox3d.fromExtrema\r\n            { minX = 1\r\n            , maxX = 4\r\n            , minY = 4\r\n            , maxY = 5\r\n            , minZ = 5\r\n            , maxZ = 8\r\n            }\r\n\r\n    BoundingBox3d.intersection firstBox secondBox\r\n    --> Just\r\n    -->     (BoundingBox3d.fromExtrema\r\n    -->         { minX = 2\r\n    -->         , maxX = 4\r\n    -->         , minY = 2\r\n    -->         , maxY = 3\r\n    -->         , minZ = 6\r\n    -->         , maxZ = 7\r\n    -->         }\r\n    -->     )\r\n\r\n    BoundingBox3d.intersection firstBox thirdBox\r\n    --> Nothing\r\n\r\nIf two boxes just touch along an edge or at a corner, they are still considered\r\nto have an intersection, even though that intersection will have zero area (at\r\nleast one of its dimensions will be zero):\r\n\r\n    firstBox =\r\n        BoundingBox3d.fromExtrema\r\n            { minX = 0\r\n            , maxX = 1\r\n            , minY = 0\r\n            , maxY = 2\r\n            , minZ = 0\r\n            , maxZ = 3\r\n            }\r\n\r\n    secondBox =\r\n        BoundingBox3d.fromExtrema\r\n            { minX = 1\r\n            , maxX = 2\r\n            , minY = 1\r\n            , maxY = 3\r\n            , minZ = 1\r\n            , maxZ = 4\r\n            }\r\n\r\n    BoundingBox3d.intersection firstBox secondBox\r\n    --> Just\r\n    -->     (BoundingBox3d.fromExtrema\r\n    -->         { minX = 1\r\n    -->         , maxX = 1\r\n    -->         , minY = 1\r\n    -->         , maxY = 2\r\n    -->         , minZ = 1\r\n    -->         , maxZ = 3\r\n    -->         }\r\n    -->     )\r\n\r\n","type":"BoundingBox3d.BoundingBox3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates -> Maybe.Maybe (BoundingBox3d.BoundingBox3d units coordinates)"},{"name":"intersects","comment":" Test if two boxes touch or overlap at all (have any points in common);\r\n\r\n    BoundingBox3d.intersects firstBox secondBox\r\n\r\nis equivalent to\r\n\r\n    BoundingBox3d.intersection firstBox secondBox\r\n        /= Nothing\r\n\r\nbut is more efficient.\r\n\r\n    firstBox =\r\n        BoundingBox3d.fromExtrema\r\n            { minX = 0\r\n            , maxX = 3\r\n            , minY = 0\r\n            , maxY = 2\r\n            , minZ = 0\r\n            , maxZ = 1\r\n            }\r\n\r\n    secondBox =\r\n        BoundingBox3d.fromExtrema\r\n            { minX = 0\r\n            , maxX = 3\r\n            , minY = 1\r\n            , maxY = 4\r\n            , minZ = -1\r\n            , maxZ = 2\r\n            }\r\n\r\n    thirdBox =\r\n        BoundingBox3d.fromExtrema\r\n            { minX = 0\r\n            , maxX = 3\r\n            , minY = 4\r\n            , maxY = 5\r\n            , minZ = -1\r\n            , maxZ = 2\r\n            }\r\n\r\n    BoundingBox3d.intersects firstBox secondBox\r\n    --> True\r\n\r\n    BoundingBox3d.intersects firstBox thirdBox\r\n    --> False\r\n\r\n","type":"BoundingBox3d.BoundingBox3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates -> Basics.Bool"},{"name":"isContainedIn","comment":" Test if the second given bounding box is fully contained within the first\r\n(is a subset of it).\r\n\r\n    outerBox =\r\n        BoundingBox3d.fromExtrema\r\n            { minX = 0\r\n            , maxX = 10\r\n            , minY = 0\r\n            , maxY = 10\r\n            , minZ = 0\r\n            , maxZ = 10\r\n            }\r\n\r\n    innerBox =\r\n        BoundingBox3d.fromExtrema\r\n            { minX = 1\r\n            , maxX = 5\r\n            , minY = 3\r\n            , maxY = 9\r\n            , minZ = 7\r\n            , maxZ = 8\r\n            }\r\n\r\n    overlappingBox =\r\n        BoundingBox3d.fromExtrema\r\n            { minX = 1\r\n            , maxX = 5\r\n            , minY = 3\r\n            , maxY = 12\r\n            , minZ = 7\r\n            , maxZ = 8\r\n            }\r\n\r\n    BoundingBox3d.isContainedIn outerBox innerBox\r\n    --> True\r\n\r\n    BoundingBox3d.isContainedIn outerBox overlappingBox\r\n    --> False\r\n\r\n","type":"BoundingBox3d.BoundingBox3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates -> Basics.Bool"},{"name":"maxX","comment":" Get the maximum X value of a bounding box.\r\n\r\n    BoundingBox3d.maxX exampleBox\r\n    --> 2\r\n\r\n","type":"BoundingBox3d.BoundingBox3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"maxY","comment":" Get the maximum Y value of a bounding box.\r\n\r\n    BoundingBox3d.maxY exampleBox\r\n    --> 5\r\n\r\n","type":"BoundingBox3d.BoundingBox3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"maxZ","comment":" Get the maximum Z value of a bounding box.\r\n\r\n    BoundingBox3d.maxZ exampleBox\r\n    --> 4\r\n\r\n","type":"BoundingBox3d.BoundingBox3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"midX","comment":" Get the median X value of a bounding box.\r\n\r\n    BoundingBox3d.midX exampleBox\r\n    --> 0\r\n\r\n","type":"BoundingBox3d.BoundingBox3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"midY","comment":" Get the median Y value of a bounding box.\r\n\r\n    BoundingBox3d.midY exampleBox\r\n    --> 3.5\r\n\r\n","type":"BoundingBox3d.BoundingBox3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"midZ","comment":" Get the median Z value of a bounding box.\r\n\r\n    BoundingBox3d.midZ exampleBox\r\n    --> 3.5\r\n\r\n","type":"BoundingBox3d.BoundingBox3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"minX","comment":" Get the minimum X value of a bounding box.\r\n\r\n    BoundingBox3d.minX exampleBox\r\n    --> -2\r\n\r\n","type":"BoundingBox3d.BoundingBox3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"minY","comment":" Get the minimum Y value of a bounding box.\r\n\r\n    BoundingBox3d.minY exampleBox\r\n    --> 2\r\n\r\n","type":"BoundingBox3d.BoundingBox3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"minZ","comment":" Get the minimum Z value of a bounding box.\r\n\r\n    BoundingBox3d.minZ exampleBox\r\n    --> 3\r\n\r\n","type":"BoundingBox3d.BoundingBox3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"offsetBy","comment":" Expand or shrink the given bounding box in all the directions by the given\r\ndistance. A positive offset will cause the bounding box to expand and a negative\r\nvalue will cause it to shrink.\r\n\r\n    BoundingBox3d.offsetBy 2 exampleBox\r\n    --> Just <|\r\n    -->     BoundingBox3d.fromExtrema\r\n    -->         { minX = -4\r\n    -->         , maxX = 4\r\n    -->         , minY = 0\r\n    -->         , maxY = 7\r\n    -->         , minZ = 1\r\n    -->         , maxZ = 6\r\n    -->         }\r\n\r\n    BoundingBox3d.offsetBy -0.5 exampleBox\r\n    --> Just <|\r\n    -->     BoundingBox3d.fromExtrema\r\n    -->         { minX = -1.5\r\n    -->         , maxX = 1.5\r\n    -->         , minY = 2.5\r\n    -->         , maxY = 4.5\r\n    -->         , minZ = 3.5\r\n    -->         , maxZ = 3.5\r\n    -->         }\r\n\r\nReturns `Nothing` if the offset is negative and large enough to cause the\r\nbounding box to vanish (that is, if the offset is larger than half the height or\r\nhalf the width of the bounding box, whichever is less):\r\n\r\n    BoundingBox3d.offsetBy -1 exampleBox\r\n    --> Nothing\r\n\r\nIf you only want to expand a bounding box, you can use\r\n[`expandBy`](BoundingBox3d#expandBy) instead (which does not return a `Maybe`).\r\n\r\n","type":"Quantity.Quantity Basics.Float units -> BoundingBox3d.BoundingBox3d units coordinates -> Maybe.Maybe (BoundingBox3d.BoundingBox3d units coordinates)"},{"name":"overlappingBy","comment":" Check if one box overlaps another by less than, greater than or equal to a\r\ngiven amount. For example, you could implement a tolerant collision check (one\r\nthat only returns true if the boxes overlap by at least some small finite\r\namount, and ignores boxes that just barely touch each other) as\r\n\r\n    boxesCollide box1 box2 =\r\n        BoundingBox3d.overlappingBy GT 0.001 box1 box2\r\n\r\nThis can be read as \"`box1` and `box2` are overlapping by greater than 0.001\r\nunits\". (The [`Order`](https://package.elm-lang.org/packages/elm/core/latest/Basics#Order)\r\ntype and its three values `LT`, `GT` and `EQ` are defined in Elm's `Basics`\r\nmodule so are available by default in any Elm program.)\r\n\r\nOverlap is defined as the _minimum_ distance one box would have to move so that\r\nit did not touch the other, and is always positive for any two overlapping\r\nboxes.\r\n\r\nBoxes that just touch are considered to have an overlap of zero, which is\r\ndistinct from 'no overlap'. Boxes that do not touch or overlap at all are\r\nconsidered to have an overlap which is less than zero but not comparable to any\r\nnegative number.\r\n\r\n\r\n### Less than\r\n\r\n  - `overlappingBy LT 1e-3` will return true if the two boxes overlap by less\r\n    than 0.001 units or if they do not overlap at all (false if they overlap by\r\n    more than 0.001 units).\r\n  - `overlappingBy LT 0` will return true only if the two boxes don't touch or\r\n    overlap at all.\r\n  - `overlappingBy LT -1e-3` will always return false! If you care about _how\r\n    much_ two boxes are separated by, use `separatedBy` instead.\r\n\r\n\r\n### Greater than\r\n\r\n  - `overlappingBy GT 1e-3` will return true if the two boxes overlap by at\r\n    least 0.001 units (false if they overlap by less than that or do not overlap\r\n    at all).\r\n  - `overlappingBy GT 0` will return true if the two boxes overlap by any\r\n    non-zero amount (false if they just touch or do not overlap at all).\r\n  - `overlappingBy GT -1e-3` doesn't make a lot of sense but will return true if\r\n    the boxes touch or overlap at all (false if they don't overlap, regardless\r\n    of how close they are to overlapping). In this case, though, it would make\r\n    more sense to just user `intersects` instead.\r\n\r\n\r\n### Equal to\r\n\r\nChecking whether two boxes overlap by exactly a given amount is pretty weird and\r\nvulnerable to floating-point roundoff, but is defined as follows:\r\n\r\n  - `overlappingBy EQ 1e-3` will return true if the two boxes overlap by exactly\r\n    0.001 units.\r\n  - `overlappingBy EQ 0` will return true if and only if the boxes just touch\r\n    each other.\r\n  - `overlappingBy EQ -1e-3` will always return false.\r\n\r\n","type":"Basics.Order -> Quantity.Quantity Basics.Float units -> BoundingBox3d.BoundingBox3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates -> Basics.Bool"},{"name":"scaleAbout","comment":" Scale a bounding box about a given point by a given scale.\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 2, 2, 2 )\r\n\r\n    BoundingBox3d.scaleAbout point 2 exampleBox\r\n    --> BoundingBox3d.fromExtrema\r\n    -->     { minX = -6\r\n    -->     , maxX = 2\r\n    -->     , minY = 2\r\n    -->     , maxY = 8\r\n    -->     , minZ = 4\r\n    -->     , maxZ = 6\r\n    -->     }\r\n\r\n","type":"Point3d.Point3d units coordinates -> Basics.Float -> BoundingBox3d.BoundingBox3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates"},{"name":"separatedBy","comment":" Check if one box is separated from another by less than, greater than or\r\nequal to a given amount. For example, to perform clash detection between some\r\nobjects, you could use `separatedBy` on those objects' bounding boxes as a quick\r\ncheck to see if the objects had a gap of at least 1 cm between them:\r\n\r\n    safelySeparated box1 box2 =\r\n        BoundingBox3d.separatedBy GT 0.01 box1 box2\r\n\r\nThis can be read as \"`box1` and `box2` are separated by greater than 0.01\r\nunits\". (The [`Order`](https://package.elm-lang.org/packages/elm/core/latest/Basics#Order)\r\ntype and its three values `LT`, `GT` and `EQ` are defined in Elm's `Basics`\r\nmodule so are available by default in any Elm program.)\r\n\r\nSeparation is defined as the _minimum_ distance one box would have to move\r\nso that it touched the other, and is always positive for any two boxes that do\r\nnot touch.\r\n\r\nBoxes that just touch are considered to have a separation of zero, which is\r\ndistinct from 'no separation'. 'No separation' (overlap) is considered to be\r\nless than zero but not comparable to any negative number.\r\n\r\n\r\n### Less than\r\n\r\n  - `separatedBy LT 1e-3` will return true if the two boxes are separated by\r\n    less than 0.001 units or if they touch or overlap (false if they are\r\n    separated by at least 0.001 units).\r\n  - `separatedBy LT 0` will return true only if the boxes overlap by some\r\n    non-zero amount.\r\n  - `separatedBy LT -1e-3` will always return false! If you care about _how\r\n    much_ two boxes overlap by, use `overlappingBy` instead.\r\n\r\n\r\n### Greater than\r\n\r\n  - `separatedBy GT 1e-3` will return true if the two boxes are separated by at\r\n    least 0.001 units (false if they are separated by less than that or if they\r\n    touch or overlap).\r\n  - `separatedBy GT 0` will return true if the two boxes are separated by any\r\n    non-zero amount (false if they touch or overlap).\r\n  - `separatedBy GT -1e-3` doesn't make a lot of sense but will return true if\r\n    the boxes just touch or are separated by any amount (false if they overlap\r\n    by any non-zero amount).\r\n\r\n\r\n### Equal to\r\n\r\nChecking whether two boxes are separated by exactly a given amount is pretty\r\nweird and vulnerable to floating-point roundoff, but is defined as follows:\r\n\r\n  - `separatedBy EQ 1e-3` will return true if the two boxes are separated by\r\n    exactly 0.001 units.\r\n  - `separatedBy EQ 0` will return true if and only if the boxes just touch each\r\n    other.\r\n  - `separatedBy EQ -3` will always return false.\r\n\r\n","type":"Basics.Order -> Quantity.Quantity Basics.Float units -> BoundingBox3d.BoundingBox3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates -> Basics.Bool"},{"name":"singleton","comment":" Construct a zero-width bounding box containing a single point.\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 2, 1, 3 )\r\n\r\n    BoundingBox3d.singleton point\r\n    --> BoundingBox3d.fromExtrema\r\n    -->     { minX = 2\r\n    -->     , maxX = 2\r\n    -->     , minY = 1\r\n    -->     , maxY = 1\r\n    -->     , minZ = 3\r\n    -->     , maxZ = 3\r\n    -->     }\r\n\r\n","type":"Point3d.Point3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates"},{"name":"translateBy","comment":" Translate a bounding box by a given displacement.\r\n\r\n    displacement =\r\n        Vector3d.fromComponents ( 2, -3, 1 )\r\n\r\n    BoundingBox3d.translateBy displacement exampleBox\r\n    --> BoundingBox3d.fromExtrema\r\n    -->     { minX = 0\r\n    -->     , maxX = 4\r\n    -->     , minY = -1\r\n    -->     , maxY = 2\r\n    -->     , minZ = 4\r\n    -->     , maxZ = 5\r\n    -->     }\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates"},{"name":"translateIn","comment":" Translate a bounding box in a given direction by a given distance;\r\n\r\n    BoundingBox3d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    BoundingBox3d.translateBy\r\n        (Vector3d.withLength distance direction)\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Quantity.Quantity Basics.Float units -> BoundingBox3d.BoundingBox3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates"}],"binops":[]},{"name":"Circle2d","comment":" A `Circle2d` is defined by its center point and radius. This module includes\r\nfunctionality for\r\n\r\n  - Constructing circles through points or with a given center/radius\r\n  - Scaling, rotating and translating circles\r\n  - Extracting properties of circles like area, center point and radius\r\n\r\n@docs Circle2d\r\n\r\n\r\n# Constructors\r\n\r\n@docs withRadius, throughPoints, sweptAround\r\n\r\n\r\n# Properties\r\n\r\n@docs centerPoint, radius, diameter, area, circumference, boundingBox\r\n\r\n\r\n# Conversion\r\n\r\n@docs toArc\r\n\r\n\r\n# Queries\r\n\r\n@docs contains\r\n\r\n\r\n# Transformations\r\n\r\n@docs scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n","unions":[],"aliases":[{"name":"Circle2d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Circle2d units coordinates"}],"values":[{"name":"area","comment":" Get the area of a circle.\r\n\r\n    Circle2d.area exampleCircle\r\n    --> 28.2743\r\n\r\n","type":"Circle2d.Circle2d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Squared units)"},{"name":"boundingBox","comment":" Get the minimal bounding box containing a given circle.\r\n\r\n    Circle2d.boundingBox exampleCircle\r\n    --> BoundingBox2d.fromExtrema\r\n    -->     { minX = -2\r\n    -->     , maxX = 4\r\n    -->     , minY = -1\r\n    -->     , maxY = 5\r\n    -->     }\r\n\r\n","type":"Circle2d.Circle2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates"},{"name":"centerPoint","comment":" Get the center point of a circle.\r\n\r\n    Circle2d.centerPoint exampleCircle\r\n    --> Point2d.fromCoordinates ( 1, 2 )\r\n\r\n","type":"Circle2d.Circle2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"circumference","comment":" Get the circumference of a circle.\r\n\r\n    Circle2d.circumference exampleCircle\r\n    --> 18.8496\r\n\r\n","type":"Circle2d.Circle2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"contains","comment":" Check if a circle contains a given point.\r\n\r\n    Circle2d.contains Point2d.origin exampleCircle\r\n    --> True\r\n\r\n    exampleCircle\r\n        |> Circle2d.contains\r\n            (Point2d.fromCoordinates ( 10, 10 ))\r\n    --> False\r\n\r\n","type":"Point2d.Point2d units coordinates -> Circle2d.Circle2d units coordinates -> Basics.Bool"},{"name":"diameter","comment":" Get the diameter of a circle.\r\n\r\n    Circle2d.diameter exampleCircle\r\n    --> 6\r\n\r\n","type":"Circle2d.Circle2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"mirrorAcross","comment":" Mirror a circle across a given axis.\r\n\r\n    Circle2d.mirrorAcross Axis2d.x exampleCircle\r\n    --> Circle2d.withRadius 3\r\n    -->     (Point2d.fromCoordinates ( 1, -2 ))\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> Circle2d.Circle2d units coordinates -> Circle2d.Circle2d units coordinates"},{"name":"placeIn","comment":" Take a circle considered to be defined in local coordinates relative to a\r\ngiven reference frame, and return that circle expressed in global coordinates.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 2, 3 ))\r\n\r\n    Circle2d.placeIn localFrame exampleCircle\r\n    --> Circle2d.withRadius 3\r\n    -->     (Point2d.fromCoordinates ( 3, 5 ))\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> Circle2d.Circle2d units localCoordinates -> Circle2d.Circle2d units globalCoordinates"},{"name":"radius","comment":" Get the radius of a circle.\r\n\r\n    Circle2d.radius exampleCircle\r\n    --> 3\r\n\r\n","type":"Circle2d.Circle2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"relativeTo","comment":" Take a circle defined in global coordinates, and return it expressed in\r\nlocal coordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 2, 3 ))\r\n\r\n    Circle2d.relativeTo localFrame exampleCircle\r\n    --> Circle2d.withRadius 3\r\n    -->     (Point2d.fromCoordinates ( -1, -1 ))\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> Circle2d.Circle2d units globalCoordinates -> Circle2d.Circle2d units localCoordinates"},{"name":"rotateAround","comment":" Rotate a circle around a given point by a given angle (in radians).\r\n\r\n    exampleCircle\r\n        |> Circle2d.rotateAround Point2d.origin\r\n            (degrees 90)\r\n    --> Circle2d.withRadius 3\r\n    -->     (Point2d.fromCoordinates ( -2, 1 ))\r\n\r\n","type":"Point2d.Point2d units coordinates -> Angle.Angle -> Circle2d.Circle2d units coordinates -> Circle2d.Circle2d units coordinates"},{"name":"scaleAbout","comment":" Scale a circle about a given point by a given scale.\r\n\r\n    Circle2d.scaleAbout Point2d.origin 2 exampleCircle\r\n    --> Circle2d.withRadius 6\r\n    -->     (Point2d.fromCoordinates ( 2, 4 ))\r\n\r\n    exampleCircle\r\n        |> Circle2d.scaleAbout\r\n            (Point2d.fromCoordinates ( 1, 2 ))\r\n            0.5\r\n    --> Circle2d.withRadius 1.5\r\n    -->     (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n","type":"Point2d.Point2d units coordinates -> Basics.Float -> Circle2d.Circle2d units coordinates -> Circle2d.Circle2d units coordinates"},{"name":"sweptAround","comment":" Construct a circle by rotating a point on the circle around a given center\r\npoint. The center point is given first and the point on the circle is given\r\nsecond.\r\n\r\n    Circle2d.sweptAround Point2d.origin\r\n        (Point2d.fromCoordinates ( 2, 0 ))\r\n    --> Circle2d.withRadius 2 Point2d.origin\r\n\r\nThe above example could be rewritten as\r\n\r\n    Point2d.fromCoordinates ( 2, 0 )\r\n        |> Circle2d.sweptAround Point2d.origin\r\n\r\nand if you wanted to create many concentric circles all centered on the origin\r\nbut passing through several other different points, you could use something like\r\n\r\n    concentricCircles =\r\n        points\r\n            |> List.map\r\n                (Circle2d.sweptAround Point2d.origin)\r\n\r\n","type":"Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> Circle2d.Circle2d units coordinates"},{"name":"throughPoints","comment":" Attempt to construct a circle that passes through the three given points. If\r\nthe three given points are collinear, returns `Nothing`.\r\n\r\n    Circle2d.throughPoints\r\n        Point2d.origin\r\n        (Point2d.fromCoordinates ( 1, 0 ))\r\n        (Point2d.fromCoordinates ( 0, 1 ))\r\n    --> Just\r\n    -->     (Circle2d.withRadius 0.7071\r\n    -->         (Point2d.fromCoordinates ( 0.5, 0.5 ))\r\n    -->     )\r\n\r\n    Circle2d.throughPoints\r\n        Point2d.origin\r\n        (Point2d.fromCoordinates ( 2, 1 ))\r\n        (Point2d.fromCoordinates ( 4, 0 ))\r\n    --> Just\r\n    -->     (Circle2d.withRadius 2.5\r\n    -->         (Point2d.fromCoordinates ( 2, -1.5 ))\r\n    -->     )\r\n\r\n    Circle2d.throughPoints\r\n        Point2d.origin\r\n        (Point2d.fromCoordinates ( 2, 0 ))\r\n        (Point2d.fromCoordinates ( 4, 0 ))\r\n    --> Nothing\r\n\r\n    Circle2d.throughPoints\r\n        Point2d.origin\r\n        Point2d.origin\r\n        (Point2d.fromCoordinates ( 1, 0 ))\r\n    --> Nothing\r\n\r\n","type":"Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> Maybe.Maybe (Circle2d.Circle2d units coordinates)"},{"name":"toArc","comment":" Convert a circle to a 360 degree arc.\r\n\r\n    Circle2d.toArc exampleCircle\r\n    --> Point2d.fromCoordinates ( 4, 2 )\r\n    -->     |> Arc2d.sweptAround\r\n    -->         (Point2d.fromCoordinates ( 1, 2 ))\r\n    -->         (degrees 360)\r\n\r\n","type":"Circle2d.Circle2d units coordinates -> Geometry.Types.Arc2d units coordinates"},{"name":"translateBy","comment":" Translate a circle by a given displacement.\r\n\r\n    exampleCircle\r\n        |> Circle2d.translateBy\r\n            (Vector2d.fromComponents ( 2, 2 ))\r\n    --> Circle2d.withRadius 3\r\n    -->     (Point2d.fromCoordinates ( 3, 4 ))\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Circle2d.Circle2d units coordinates -> Circle2d.Circle2d units coordinates"},{"name":"translateIn","comment":" Translate a circle in a given direction by a given distance;\r\n\r\n    Circle2d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    Circle2d.translateBy\r\n        (Vector2d.withLength distance direction)\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Quantity.Quantity Basics.Float units -> Circle2d.Circle2d units coordinates -> Circle2d.Circle2d units coordinates"},{"name":"withRadius","comment":" Construct a circle from its radius and center point:\r\n\r\n    exampleCircle =\r\n        Circle2d.withRadius 3\r\n            (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\nIf you pass a negative radius, the absolute value will be used.\r\n\r\n","type":"Quantity.Quantity Basics.Float units -> Point2d.Point2d units coordinates -> Circle2d.Circle2d units coordinates"}],"binops":[]},{"name":"Circle3d","comment":" A `Circle3d` is defined by its center point, axial direction and radius. The\r\naxial direction is the direction of the axis through the center of the circle\r\nthat all points on the circle are equidistant from, or equivalently the normal\r\ndirection of the plane defined by the circle. This module contains functionality\r\nfor:\r\n\r\n  - Constructing circles around axes, on planes, or through points\r\n  - Scaling, rotating and translating circles\r\n  - Extracting circle properties like center point and area\r\n\r\n@docs Circle3d\r\n\r\n\r\n# Constructors\r\n\r\n@docs withRadius, sweptAround, on, throughPoints\r\n\r\n\r\n# Properties\r\n\r\n@docs centerPoint, axialDirection, radius, diameter, axis, plane, area, circumference, boundingBox\r\n\r\n\r\n# Transformations\r\n\r\n@docs scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross, projectInto\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n","unions":[],"aliases":[{"name":"Circle3d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Circle3d units coordinates"}],"values":[{"name":"area","comment":" Get the area of a circle.\r\n\r\n    Circle3d.area exampleCircle\r\n    --> 28.2743\r\n\r\n","type":"Circle3d.Circle3d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Squared units)"},{"name":"axialDirection","comment":" Get the axial direction of a circle.\r\n\r\n    Circle3d.axialDirection exampleCircle\r\n    --> Direction3d.z\r\n\r\n","type":"Circle3d.Circle3d units coordinates -> Direction3d.Direction3d coordinates"},{"name":"axis","comment":" Get the central axis of a circle, perpendicular to its [`plane`](#plane).\r\nThe origin point of the returned axis will be the center point of the circle.\r\n\r\n    Circle3d.axis exampleCircle\r\n    --> Axis3d.withDirection Direction3d.z\r\n    -->     (Point3d.fromCoordinates ( 2, 0, 1 ))\r\n\r\n","type":"Circle3d.Circle3d units coordinates -> Axis3d.Axis3d units coordinates"},{"name":"boundingBox","comment":" Get the minimal bounding box containing a given circle.\r\n\r\n    Circle3d.boundingBox exampleCircle\r\n    --> BoundingBox3d.fromExtrema\r\n    -->     { minX = -1\r\n    -->     , maxX = 5\r\n    -->     , minY = -3\r\n    -->     , maxY = 3\r\n    -->     , minZ = 1\r\n    -->     , maxZ = 1\r\n    -->     }\r\n\r\n","type":"Circle3d.Circle3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates"},{"name":"centerPoint","comment":" Get the center point of a circle.\r\n\r\n    Circle3d.centerPoint exampleCircle\r\n    --> Point3d.fromCoordinates ( 2, 0, 1 )\r\n\r\n","type":"Circle3d.Circle3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"circumference","comment":" Get the circumference of a circle.\r\n\r\n    Circle3d.circumference exampleCircle\r\n    --> 18.8496\r\n\r\n","type":"Circle3d.Circle3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"diameter","comment":" Get the diameter of a circle.\r\n\r\n    Circl3d.diameter exampleCircle\r\n    --> 6\r\n\r\n","type":"Circle3d.Circle3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"mirrorAcross","comment":" Mirror a circle across a given plane.\r\n\r\n    Circle3d.mirrorAcross Plane3d.xy exampleCircle\r\n    --> Circle3d.withRadius 3\r\n    -->     Direction3d.negativeZ\r\n    -->     (Point3d.fromCoordinates ( 2, 0, -1 ))\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> Circle3d.Circle3d units coordinates -> Circle3d.Circle3d units coordinates"},{"name":"on","comment":" Construct a 3D circle lying _on_ a sketch plane by providing a 2D circle\r\nspecified in XY coordinates _within_ the sketch plane.\r\n\r\n    Circle3d.on SketchPlane3d.yz <|\r\n        Circle2d.withRadius 3\r\n            (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    --> Circle3d.withRadius 3\r\n    -->     Direction3d.x\r\n    -->     (Point3d.fromCoordinates ( 0, 1, 2 ))\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates3d coordinates2d -> Circle2d.Circle2d units coordinates2d -> Circle3d.Circle3d units coordinates3d"},{"name":"placeIn","comment":" Take a circle considered to be defined in local coordinates relative to a\r\ngiven reference frame, and return that circle expressed in global coordinates.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    Circle3d.placeIn localFrame exampleCircle\r\n    --> Circle3d.withRadius 3\r\n    -->     Direction3d.z\r\n    -->     (Point3d.fromCoordinates ( 3, 2, 4 ))\r\n\r\n","type":"Frame3d.Frame3d units globalCoordinates localCoordinates -> Circle3d.Circle3d units localCoordinates -> Circle3d.Circle3d units globalCoordinates"},{"name":"plane","comment":" Get the plane that a circle lies in. The origin point of the returned plane\r\nwill be the center point of the circle, and its normal direction will be the\r\naxial direction of the circle.\r\n\r\n    Circle3d.plane exampleCircle\r\n    --> Plane3d.withNormalDirection Direction3d.z\r\n    -->     (Point3d.fromCoordinates ( 2, 0, 1 ))\r\n\r\n","type":"Circle3d.Circle3d units coordinates -> Plane3d.Plane3d units coordinates"},{"name":"projectInto","comment":" Project a circle into a sketch plane.\r\n\r\n    inclinedCircle : Circle3d\r\n    inclinedCircle =\r\n        Circle3d.withRadius 1\r\n            (Direction3d.fromAzimuthAndElevation\r\n                (degrees 0)\r\n                (degrees 45)\r\n            )\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    Circle3d.projectInto SketchPlane3d.xy inclinedCircle\r\n    --> Ellipse2d.with\r\n    -->     { centerPoint =\r\n    -->         Point2d.fromCoordinates ( 1, 2 )\r\n    -->     , xDirection = Direction2d.negativeY\r\n    -->     , xRadius = 1\r\n    -->     , yRadius = 0.7071\r\n    -->     }\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates3d coordinates2d -> Circle3d.Circle3d units coordinates3d -> Geometry.Types.Ellipse2d units coordinates2d"},{"name":"radius","comment":" Get the radius of a circle.\r\n\r\n    Circle3d.radius exampleCircle\r\n    --> 3\r\n\r\n","type":"Circle3d.Circle3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"relativeTo","comment":" Take a circle defined in global coordinates, and return it expressed in\r\nlocal coordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    Circle3d.relativeTo localFrame exampleCircle\r\n    --> Circle3d.withRadius 3\r\n    -->     Direction3d.z\r\n    -->     (Point3d.fromCoordinates ( 1, -2, -2 ))\r\n\r\n","type":"Frame3d.Frame3d units globalCoordinates localCoordinates -> Circle3d.Circle3d units globalCoordinates -> Circle3d.Circle3d units localCoordinates"},{"name":"rotateAround","comment":" Rotate a circle around a given axis by a given angle (in radians).\r\n\r\n    exampleCircle\r\n        |> Circle3d.rotateAround Axis3d.y (degrees 90)\r\n    --> Circle3d.withRadius 3\r\n    -->     Direction3d.x\r\n    -->     (Point3d.fromCoordinates ( 1, 0, -2 ))\r\n\r\n","type":"Axis3d.Axis3d units coordinates -> Angle.Angle -> Circle3d.Circle3d units coordinates -> Circle3d.Circle3d units coordinates"},{"name":"scaleAbout","comment":" Scale a circle around a given point by a given scale.\r\n\r\n    Circle3d.scaleAbout Point3d.origin 3 exampleCircle\r\n    --> Circle3d.withRadius 3\r\n    -->     Direction3d.z\r\n    -->     (Point3d.fromCoordinates ( 6, 0, 3 ))\r\n\r\n","type":"Point3d.Point3d units coordinates -> Basics.Float -> Circle3d.Circle3d units coordinates -> Circle3d.Circle3d units coordinates"},{"name":"sweptAround","comment":" Construct a circle by sweeping the given point around the given axis.\r\n\r\n    Circle3d.sweptAround Axis3d.z\r\n        (Point3d.fromCoordinates ( 3, 0, 2 ))\r\n    --> Circle3d.withRadius 3\r\n    -->     Direction3d.z\r\n    -->     (Point3d.fromCoordinates ( 0, 0, 2 ))\r\n\r\n","type":"Axis3d.Axis3d units coordinates -> Point3d.Point3d units coordinates -> Circle3d.Circle3d units coordinates"},{"name":"throughPoints","comment":" Attempt to construct a circle that passes through the three given points.\r\nThe axial direction of the returned circle will be such that the three points\r\nare in counterclockwise order around it, according to the right-hand rule. If\r\nthe three given points are collinear, returns `Nothing`.\r\n\r\n    Circle3d.throughPoints\r\n        (Point3d.fromCoordinates ( 1, 0, 0 ))\r\n        (Point3d.fromCoordinates ( 0, 1, 0 ))\r\n        (Point3d.fromCoordinates ( 0, 0, 1 ))\r\n    --> Just\r\n    -->     (Circle3d.withRadius 0.8165\r\n    -->         (Direction3d.fromAzimuthAndElevation\r\n    -->             (degrees 45)\r\n    -->             (degrees 35.26)\r\n    -->         )\r\n    -->         (Point3d.fromCoordinates\r\n    -->             ( 0.333, 0.333, 0.333 )\r\n    -->         )\r\n    -->     )\r\n\r\n","type":"Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> Maybe.Maybe (Circle3d.Circle3d units coordinates)"},{"name":"translateBy","comment":" Translate a circle by a given displacement.\r\n\r\n    displacement =\r\n        Vector3d.fromComponents ( 2, 1, 3 )\r\n\r\n    Circle3d.translateBy displacement exampleCircle\r\n    --> Circle3d.withRadius 3\r\n    -->     Direction3d.z\r\n    -->     (Point3d.fromCoordinates ( 4, 1, 4 ))\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Circle3d.Circle3d units coordinates -> Circle3d.Circle3d units coordinates"},{"name":"translateIn","comment":" Translate a circle in a given direction by a given distance;\r\n\r\n    Circle3d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    Circle3d.translateBy\r\n        (Vector3d.withLength distance direction)\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Quantity.Quantity Basics.Float units -> Circle3d.Circle3d units coordinates -> Circle3d.Circle3d units coordinates"},{"name":"withRadius","comment":" Construct a circle from its radius, axial direction and center point:\r\n\r\n    exampleCircle =\r\n        Circle3d.withRadius 3\r\n            Direction3d.z\r\n            (Point3d.fromCoordinates ( 2, 0, 1 ))\r\n\r\nIf you pass a negative radius, the absolute value will be used.\r\n\r\n","type":"Quantity.Quantity Basics.Float units -> Direction3d.Direction3d coordinates -> Point3d.Point3d units coordinates -> Circle3d.Circle3d units coordinates"}],"binops":[]},{"name":"CubicSpline2d","comment":" A `CubicSpline2d` is a cubic [Bzier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)\r\nin 2D defined by a start point, end point and two control points. This module\r\ncontains functionality for\r\n\r\n  - Constructing splines\r\n  - Evaluating points and tangent directions along a spline\r\n  - Scaling, rotating, translating or mirroring a spline\r\n  - Converting a spline between local and global coordinates in different\r\n    reference frames\r\n\r\n@docs CubicSpline2d\r\n\r\n\r\n# Constructors\r\n\r\n@docs with, fromEndpoints, fromQuadraticSpline\r\n\r\n\r\n# Properties\r\n\r\n@docs startPoint, endPoint, startControlPoint, endControlPoint, startDerivative, endDerivative, boundingBox\r\n\r\n\r\n# Evaluation\r\n\r\n@docs pointOn, pointsAt\r\n@docs Nondegenerate, nondegenerate, fromNondegenerate\r\n@docs tangentDirection, tangentDirectionsAt, sample, samplesAt\r\n\r\n\r\n# Transformations\r\n\r\n@docs reverse, scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n\r\n# Subdivision\r\n\r\n@docs bisect, splitAt\r\n\r\n\r\n# Arc length parameterization\r\n\r\n@docs ArcLengthParameterized, arcLengthParameterized, arcLength, midpoint, pointAlong, tangentDirectionAlong, sampleAlong\r\n\r\n\r\n## Low level\r\n\r\nAn `ArcLengthParameterized` value is a combination of an\r\n[`ArcLengthParameterization`](Geometry-ArcLengthParameterization) and an\r\nunderlying `CubicSpline2d`. If you need to do something fancy, you can extract\r\nthese two values separately.\r\n\r\n@docs arcLengthParameterization, fromArcLengthParameterized\r\n\r\n\r\n# Differentiation\r\n\r\nYou are unlikely to need to use these functions directly, but they are useful if\r\nyou are writing low-level geometric algorithms.\r\n\r\n@docs firstDerivative, firstDerivativesAt, secondDerivative, secondDerivativesAt, thirdDerivative, maxSecondDerivativeMagnitude\r\n\r\n","unions":[{"name":"ArcLengthParameterized","comment":" A spline that has been parameterized by arc length.\r\n","args":["units","coordinates"],"cases":[]},{"name":"Nondegenerate","comment":" If a curve has zero length (consists of just a single point), then we say\r\nthat it is 'degenerate'. Some operations such as computing tangent directions\r\nare not defined on degenerate curves.\r\n\r\nA `Nondegenerate` value represents a spline that is definitely not degenerate.\r\nIt is used as input to functions such as `CubicSpline2d.tangentDirection` and\r\ncan be constructed using `CubicSpline2d.nondegenerate`.\r\n\r\n","args":["units","coordinates"],"cases":[]}],"aliases":[{"name":"CubicSpline2d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.CubicSpline2d units coordinates"}],"values":[{"name":"arcLength","comment":" Find the total arc length of a spline:\r\n\r\n    arcLength =\r\n        CubicSpline2d.arcLength parameterizedSpline\r\n\r\n    arcLength\r\n    --> 7.0952\r\n\r\nIn this example, the result will be accurate to within `1.0e-4` since that was\r\nthe tolerance used when constructing `parameterizedSpline`.\r\n\r\n","type":"CubicSpline2d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"arcLengthParameterization","comment":" ","type":"CubicSpline2d.ArcLengthParameterized units coordinates -> Curve.ArcLengthParameterization.ArcLengthParameterization units"},{"name":"arcLengthParameterized","comment":" Build an arc length parameterization of the given spline, with a given\r\naccuracy. Generally speaking, all operations on the resulting\r\n`ArcLengthParameterized` value will be accurate to within the specified maximum\r\nerror.\r\n\r\n    parameterizedSpline =\r\n        exampleSpline\r\n            |> CubicSpline2d.arcLengthParameterized\r\n                { maxError = 1.0e-4 }\r\n\r\nThe accuracy of the parameterization affects the accuracy of results returned\r\nfrom functions such as `arcLength` and `pointAlong`.\r\n\r\n","type":"{ maxError : Quantity.Quantity Basics.Float units } -> CubicSpline2d.CubicSpline2d units coordinates -> CubicSpline2d.ArcLengthParameterized units coordinates"},{"name":"bisect","comment":" Split a spline into two roughly equal halves.\r\n\r\n    CubicSpline2d.bisect exampleSpline\r\n    --> ( CubicSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 1, 1 )\r\n    -->     , startControlPoint =\r\n    -->         Point2d.fromCoordinates ( 2, 2.5 )\r\n    -->     , endControlPoint =\r\n    -->         Point2d.fromCoordinates ( 3, 2.5 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 4, 2.5 )\r\n    -->     }\r\n    --> , CubicSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 4, 2.5 )\r\n    -->     , startControlPoint =\r\n    -->         Point2d.fromCoordinates ( 5, 2.5 )\r\n    -->     , endControlPoint =\r\n    -->         Point2d.fromCoordinates ( 6, 2.5 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 7, 4 )\r\n    -->     }\r\n    --> )\r\n\r\nEquivalent to `CubicSpline2d.splitAt ParameterValue.half`.\r\n\r\n","type":"CubicSpline2d.CubicSpline2d units coordinates -> ( CubicSpline2d.CubicSpline2d units coordinates, CubicSpline2d.CubicSpline2d units coordinates )"},{"name":"boundingBox","comment":" Compute a bounding box for a given spline. It is not guaranteed that the\r\nresult will be the _smallest_ possible bounding box, since for efficiency the\r\nbounding box is computed from the spline's control points (which cover a larger\r\narea than the spline itself).\r\n\r\n    CubicSpline2d.boundingBox exampleSpline\r\n    --> BoundingBox2d.fromExtrema\r\n    -->     { minX = 1\r\n    -->     , maxX = 7\r\n    -->     , minY = 1\r\n    -->     , maxY = 4\r\n    -->     }\r\n\r\n","type":"CubicSpline2d.CubicSpline2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates"},{"name":"endControlPoint","comment":" Get the end control point of a spline (the control point next to the\r\nend point).\r\n\r\n    CubicSpline2d.endControlPoint exampleSpline\r\n    --> Point2d.fromCoordinates ( 5, 1 )\r\n\r\n","type":"CubicSpline2d.CubicSpline2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"endDerivative","comment":" Get the end derivative of a spline. This is equal to three times the vector\r\nfrom the spline's end control point to its end point.\r\n\r\n    CubicSpline2d.endDerivative exampleSpline\r\n    --> Vector2d.fromComponents ( 6, 9 )\r\n\r\n","type":"CubicSpline2d.CubicSpline2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"endPoint","comment":" Get the end point of a spline.\r\n\r\n    CubicSpline2d.endPoint exampleSpline\r\n    --> Point2d.fromCoordinates ( 7, 4 )\r\n\r\n","type":"CubicSpline2d.CubicSpline2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"firstDerivative","comment":" Get the first derivative of a spline at a given parameter value:\r\n\r\n    CubicSpline2d.firstDerivative exampleSpline\r\n        ParameterValue.zero\r\n    --> Vector2d.fromComponents ( 6, 9 )\r\n\r\n    CubicSpline2d.firstDerivative exampleSpline\r\n        ParameterValue.half\r\n    --> Vector2d.fromComponents ( 6, 0 )\r\n\r\n    CubicSpline2d.firstDerivative exampleSpline\r\n        ParameterValue.one\r\n    --> Vector2d.fromComponents ( 6, 9 )\r\n\r\n","type":"CubicSpline2d.CubicSpline2d units coordinates -> Curve.ParameterValue.ParameterValue -> Vector2d.Vector2d units coordinates"},{"name":"firstDerivativesAt","comment":" Evaluate the first derivative of a spline at a given set of parameter\r\nvalues:\r\n\r\n    exampleSpline\r\n        |> CubicSpline2d.firstDerivativesAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Vector2d.fromComponents ( 6, 9 )\r\n    --> , Vector2d.fromComponents ( 6, 0 )\r\n    --> , Vector2d.fromComponents ( 6, 9 )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> CubicSpline2d.CubicSpline2d units coordinates -> List.List (Vector2d.Vector2d units coordinates)"},{"name":"fromArcLengthParameterized","comment":" ","type":"CubicSpline2d.ArcLengthParameterized units coordinates -> CubicSpline2d.CubicSpline2d units coordinates"},{"name":"fromEndpoints","comment":" Construct a spline from a given start point with a given start derivative,\r\nto a given end point with a given end derivative, like so:\r\n\r\n![Cubic spline from endpoints](https://ianmackenzie.github.io/elm-geometry/1.0.0/CubicSpline2d/fromEndpoints.svg)\r\n\r\nThe spline is based on a parameter that ranges from 0 to 1; as a result, in most\r\ncases the length of each derivative vector should be roughly equal to the length\r\nof the resulting spline.\r\n\r\n","type":"{ startPoint : Point2d.Point2d units coordinates, startDerivative : Vector2d.Vector2d units coordinates, endPoint : Point2d.Point2d units coordinates, endDerivative : Vector2d.Vector2d units coordinates } -> CubicSpline2d.CubicSpline2d units coordinates"},{"name":"fromNondegenerate","comment":" Convert a nondegenerate spline back to a general `CubicSpline2d`.\r\n\r\n    CubicSpline2d.fromNondegenerate\r\n        nondegenerateExampleSpline\r\n    --> exampleSpline\r\n\r\n","type":"CubicSpline2d.Nondegenerate units coordinates -> CubicSpline2d.CubicSpline2d units coordinates"},{"name":"fromQuadraticSpline","comment":" Convert a quadratic spline into the equivalent cubic spline (every quadratic\r\nspline can be represented exactly as a cubic spline).\r\n\r\n    quadraticSpline =\r\n        QuadraticSpline2d.with\r\n            { startPoint =\r\n                Point2d.fromCoordinates ( 0, 0  )\r\n            , controlPoint =\r\n                Point2d.fromCoordinates ( 3, 0 )\r\n            , endPoint =\r\n                Point2d.fromCoordinates ( 3, 3 )\r\n            }\r\n\r\n    CubicSpline2d.fromQuadraticSpline quadraticSpline\r\n    --> CubicSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 0, 0 )\r\n    -->     , startControlPoint =\r\n    -->         Point2d.fromCoordinates ( 2, 0 )\r\n    -->     , endControlPoint =\r\n    -->         Point2d.fromCoordinates ( 3, 1 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 3, 3 )\r\n    -->     }\r\n\r\n","type":"QuadraticSpline2d.QuadraticSpline2d units coordinates -> CubicSpline2d.CubicSpline2d units coordinates"},{"name":"maxSecondDerivativeMagnitude","comment":" Find a conservative upper bound on the magnitude of the second derivative of\r\na spline. This can be useful when determining error bounds for various kinds of\r\nlinear approximations.\r\n\r\n    exampleSpline\r\n        |> CubicSpline2d.maxSecondDerivativeMagnitude\r\n    --> 36\r\n\r\n","type":"CubicSpline2d.CubicSpline2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"midpoint","comment":" Get the midpoint of the spline.\r\n\r\n    CubicSpline2d.midpoint parameterizedSpline\r\n    --> Point2d.fromCoordinates (3.999999999999992, 2.5)\r\n\r\n","type":"CubicSpline2d.ArcLengthParameterized units coordinates -> Point2d.Point2d units coordinates"},{"name":"mirrorAcross","comment":" Mirror a spline across an axis.\r\n\r\n    CubicSpline2d.mirrorAcross Axis2d.x exampleSpline\r\n    --> CubicSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 1, -1 )\r\n    -->     , startControlPoint =\r\n    -->         Point2d.fromCoordinates ( 3, -4 )\r\n    -->     , endControlPoint =\r\n    -->         Point2d.fromCoordinates ( 5, -1 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 7, -4 )\r\n    -->     }\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> CubicSpline2d.CubicSpline2d units coordinates -> CubicSpline2d.CubicSpline2d units coordinates"},{"name":"nondegenerate","comment":" Attempt to construct a nondegenerate spline from a general `CubicSpline2d`.\r\nIf the spline is in fact degenerate (consists of a single point), returns an\r\n`Err` with that point.\r\n\r\n    CubicSpline2d.nondegenerate exampleSpline\r\n    --> Ok nondegenerateExampleSpline\r\n\r\n","type":"CubicSpline2d.CubicSpline2d units coordinates -> Result.Result (Point2d.Point2d units coordinates) (CubicSpline2d.Nondegenerate units coordinates)"},{"name":"placeIn","comment":" Take a spline considered to be defined in local coordinates relative to a\r\ngiven reference frame, and return that spline expressed in global coordinates.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    CubicSpline2d.placeIn localFrame exampleSpline\r\n    --> CubicSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 2, 3 )\r\n    -->     , startControlPoint =\r\n    -->         Point2d.fromCoordinates ( 4, 6 )\r\n    -->     , endControlPoint =\r\n    -->         Point2d.fromCoordinates ( 6, 3 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 8, 6 )\r\n    -->     }\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> CubicSpline2d.CubicSpline2d units localCoordinates -> CubicSpline2d.CubicSpline2d units globalCoordinates"},{"name":"pointAlong","comment":" Try to get the point along a spline at a given arc length. For example, to\r\nget the point a quarter of the way along `exampleSpline`, using `arcLength` as\r\ncomputed above:\r\n\r\n    CubicSpline2d.pointAlong parameterizedSpline\r\n        (0.25 * arcLength)\r\n    --> Just (Point2d.fromCoordinates ( 2.2681, 2.2114 ))\r\n\r\nNote that this is not the same as evaulating at a parameter value of 0.25:\r\n\r\n    CubicSpline2d.pointOn exampleSpline\r\n        (ParameterValue.clamped 0.25)\r\n    --> Point2d.fromCoordinates ( 2.5, 2.3125 )\r\n\r\nIf the given arc length is less than zero or greater than the arc length of the\r\nspline, returns `Nothing`.\r\n\r\n","type":"CubicSpline2d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units -> Maybe.Maybe (Point2d.Point2d units coordinates)"},{"name":"pointOn","comment":" Get the point along a spline at a given parameter value:\r\n\r\n    CubicSpline2d.pointOn exampleSpline ParameterValue.zero\r\n    --> Point2d.fromCoordinates ( 1, 1 )\r\n\r\n    CubicSpline2d.pointOn exampleSpline ParameterValue.half\r\n    --> Point2d.fromCoordinates ( 4, 2.5 )\r\n\r\n    CubicSpline2d.pointOn exampleSpline ParameterValue.one\r\n    --> Point2d.fromCoordinates ( 7, 4 )\r\n\r\n","type":"CubicSpline2d.CubicSpline2d units coordinates -> Curve.ParameterValue.ParameterValue -> Point2d.Point2d units coordinates"},{"name":"pointsAt","comment":" Get points along a spline at a given set of parameter values:\r\n\r\n    exampleSpline\r\n        |> CubicSpline2d.pointsAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Point2d.fromCoordinates ( 1, 1 )\r\n    --> , Point2d.fromCoordinates ( 4, 2.5 )\r\n    --> , Point2d.fromCoordinates ( 7, 4 )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> CubicSpline2d.CubicSpline2d units coordinates -> List.List (Point2d.Point2d units coordinates)"},{"name":"relativeTo","comment":" Take a spline defined in global coordinates, and return it expressed in\r\nlocal coordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    CubicSpline2d.relativeTo localFrame exampleSpline\r\n    --> CubicSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 0, -1 )\r\n    -->     , startControlPoint =\r\n    -->         Point2d.fromCoordinates ( 2, 2 )\r\n    -->     , endControlPoint =\r\n    -->         Point2d.fromCoordinates ( 4, -1 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 6, 2 )\r\n    -->     }\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> CubicSpline2d.CubicSpline2d units globalCoordinates -> CubicSpline2d.CubicSpline2d units localCoordinates"},{"name":"reverse","comment":" Reverse a spline so that the start point becomes the end point, and vice\r\nversa.\r\n\r\n    CubicSpline2d.reverse exampleSpline\r\n    --> CubicSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 7, 4 )\r\n    -->     , startControlPoint =\r\n    -->         Point2d.fromCoordinates ( 5, 1 )\r\n    -->     , endControlPoint =\r\n    -->         Point2d.fromCoordinates ( 3, 4 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 1, 1 )\r\n    -->     }\r\n\r\n","type":"CubicSpline2d.CubicSpline2d units coordinates -> CubicSpline2d.CubicSpline2d units coordinates"},{"name":"rotateAround","comment":" Rotate a spline counterclockwise around a given center point by a given\r\nangle (in radians).\r\n\r\n    exampleSpline\r\n        |> CubicSpline2d.rotateAround Point2d.origin\r\n            (degrees 90)\r\n    --> CubicSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( -1, 1 )\r\n    -->     , startControlPoint =\r\n    -->         Point2d.fromCoordinates ( -4, 3 )\r\n    -->     , endControlPoint =\r\n    -->         Point2d.fromCoordinates ( -1, 5 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( -4, 7 )\r\n    -->     }\r\n\r\n","type":"Point2d.Point2d units coordinates -> Angle.Angle -> CubicSpline2d.CubicSpline2d units coordinates -> CubicSpline2d.CubicSpline2d units coordinates"},{"name":"sample","comment":" Get both the point and tangent direction of a nondegenerate spline at a\r\ngiven parameter value:\r\n\r\n    CubicSpline2d.sample nondegenerateExampleSpline\r\n        ParameterValue.half\r\n    --> ( Point2d.fromCoordinates ( 4, 2.5 )\r\n    --> , Direction2d.fromAngle (degrees 0)\r\n    --> )\r\n\r\n","type":"CubicSpline2d.Nondegenerate units coordinates -> Curve.ParameterValue.ParameterValue -> ( Point2d.Point2d units coordinates, Direction2d.Direction2d coordinates )"},{"name":"sampleAlong","comment":" Try to get the point and tangent direction along a spline at a given arc\r\nlength. To get the point and tangent direction a quarter of the way along\r\n`exampleSpline`:\r\n\r\n    CubicSpline2d.sampleAlong parameterizedSpline\r\n        (0.25 * arcLength)\r\n    --> Just\r\n    -->     ( Point2d.fromCoordinates ( 2.2681, 2.2114 )\r\n    -->     , Direction2d.fromAngle (degrees 26.5611)\r\n    -->     )\r\n\r\nIf the given arc length is less than zero or greater than the arc length of the\r\nspline (or if the spline is degenerate), returns `Nothing`.\r\n\r\n","type":"CubicSpline2d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units -> Maybe.Maybe ( Point2d.Point2d units coordinates, Direction2d.Direction2d coordinates )"},{"name":"samplesAt","comment":" Get points and tangent directions of a nondegenerate spline at a given set\r\nof parameter values:\r\n\r\n    nondegenerateExampleSpline\r\n        |> CubicSpline2d.samplesAt\r\n            (ParameterValue.steps 2)\r\n    --> [ ( Point2d.fromCoordinates ( 1, 1 )\r\n    -->   , Direction2d.fromAngle (degrees 56.31)\r\n    -->   )\r\n    --> , ( Point2d.fromCoordinates ( 4, 2.5 )\r\n    -->   , Direction2d.fromAngle (degrees 0)\r\n    -->   )\r\n    --> , ( Point2d.fromCoordinates ( 7, 4 )\r\n    -->   , Direction2d.fromAngle (degrees 56.31)\r\n    -->   )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> CubicSpline2d.Nondegenerate units coordinates -> List.List ( Point2d.Point2d units coordinates, Direction2d.Direction2d coordinates )"},{"name":"scaleAbout","comment":" Scale a spline about the given center point by the given scale.\r\n\r\n    CubicSpline2d.scaleAbout Point2d.origin 2 exampleSpline\r\n    --> CubicSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 2, 2 )\r\n    -->     , startControlPoint =\r\n    -->         Point2d.fromCoordinates ( 6, 8 )\r\n    -->     , endControlPoint =\r\n    -->         Point2d.fromCoordinates ( 10, 2 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 14, 8 )\r\n    -->     }\r\n\r\n","type":"Point2d.Point2d units coordinates -> Basics.Float -> CubicSpline2d.CubicSpline2d units coordinates -> CubicSpline2d.CubicSpline2d units coordinates"},{"name":"secondDerivative","comment":" Evaluate the second derivative of a spline at a given parameter value:\r\n\r\n    CubicSpline2d.secondDerivativeAt 0 exampleSpline\r\n    --> Just (Vector2d.fromComponents ( 0, -36 ))\r\n\r\n    CubicSpline2d.secondDerivativeAt 0.5 exampleSpline\r\n    --> Just (Vector2d.fromComponents ( 0, 0 ))\r\n\r\n    CubicSpline2d.secondDerivativeAt 1 exampleSpline\r\n    --> Just (Vector2d.fromComponents ( 0, 36 ))\r\n\r\n","type":"CubicSpline2d.CubicSpline2d units coordinates -> Curve.ParameterValue.ParameterValue -> Vector2d.Vector2d units coordinates"},{"name":"secondDerivativesAt","comment":" Evaluate the second derivative of a spline at a given set of parameter\r\nvalues:\r\n\r\n    exampleSpline\r\n        |> CubicSpline2d.secondDerivativesAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Vector2d.fromComponents ( 0, -36 )\r\n    --> , Vector2d.fromComponents ( 0, 0 )\r\n    --> , Vector2d.fromComponents ( 0, 36 )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> CubicSpline2d.CubicSpline2d units coordinates -> List.List (Vector2d.Vector2d units coordinates)"},{"name":"splitAt","comment":" Split a spline at a particular parameter value, resulting in two smaller\r\nsplines.\r\n\r\n    parameterValue =\r\n        ParameterValue.clamped 0.75\r\n\r\n    CubicSpline2d.splitAt parameterValue exampleSpline\r\n    --> ( CubicSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 1, 1 )\r\n    -->     , startControlPoint =\r\n    -->         Point2d.fromCoordinates ( 2.5, 3.25 )\r\n    -->     , endControlPoint =\r\n    -->         Point2d.fromCoordinates ( 4, 2.125 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 5.5, 2.6875 )\r\n    -->     }\r\n    --> , CubicSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 5.5, 2.6875 )\r\n    -->     , startControlPoint =\r\n    -->         Point2d.fromCoordinates ( 6, 2.875 )\r\n    -->     , endControlPoint =\r\n    -->         Point2d.fromCoordinates ( 6.5, 3.25 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 7, 4 )\r\n    -->     }\r\n    --> )\r\n\r\n","type":"Curve.ParameterValue.ParameterValue -> CubicSpline2d.CubicSpline2d units coordinates -> ( CubicSpline2d.CubicSpline2d units coordinates, CubicSpline2d.CubicSpline2d units coordinates )"},{"name":"startControlPoint","comment":" Get the start control point of a spline (the control point next to the\r\nstart point).\r\n\r\n    CubicSpline2d.startControlPoint exampleSpline\r\n    --> Point2d.fromCoordinates ( 3, 4 )\r\n\r\n","type":"CubicSpline2d.CubicSpline2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"startDerivative","comment":" Get the start derivative of a spline. This is equal to three times the\r\nvector from the spline's start point to its start control point.\r\n\r\n    CubicSpline2d.startDerivative exampleSpline\r\n    --> Vector2d.fromComponents ( 6, 9 )\r\n\r\n","type":"CubicSpline2d.CubicSpline2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"startPoint","comment":" Get the start point of a spline.\r\n\r\n    CubicSpline2d.startPoint exampleSpline\r\n    --> Point2d.fromCoordinates ( 1, 1 )\r\n\r\n","type":"CubicSpline2d.CubicSpline2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"tangentDirection","comment":" Get the tangent direction to a nondegenerate spline at a given parameter\r\nvalue:\r\n\r\n    CubicSpline2d.tangentDirection\r\n        nondegenerateExampleSpline\r\n        ParameterValue.zero\r\n    --> Direction2d.fromAngle (degrees 56.31)\r\n\r\n    CubicSpline2d.tangentDirection\r\n        nondegenerateExampleSpline\r\n        ParameterValue.half\r\n    --> Direction2d.fromAngle (degrees 0)\r\n\r\n    CubicSpline2d.tangentDirection\r\n        nondegenerateExampleSpline\r\n        ParameterValue.one\r\n    --> Direction2d.fromAngle (degrees 56.31)\r\n\r\n","type":"CubicSpline2d.Nondegenerate units coordinates -> Curve.ParameterValue.ParameterValue -> Direction2d.Direction2d coordinates"},{"name":"tangentDirectionAlong","comment":" Try to get the tangent direction along a spline at a given arc length. To\r\nget the tangent direction a quarter of the way along `exampleSpline`:\r\n\r\n    CubicSpline2d.tangentDirectionAlong parameterizedSpline\r\n        (0.25 * arcLength)\r\n    --> Just (Direction2d.fromAngle (degrees 26.5611))\r\n\r\nIf the given arc length is less than zero or greater than the arc length of the\r\nspline (or if the spline is degenerate), returns `Nothing`.\r\n\r\n","type":"CubicSpline2d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units -> Maybe.Maybe (Direction2d.Direction2d coordinates)"},{"name":"tangentDirectionsAt","comment":" Get tangent directions to a nondegenerate spline at a given set of parameter\r\nvalues:\r\n\r\n    nondegenerateExampleSpline\r\n        |> CubicSpline2d.tangentDirectionsAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Direction2d.fromAngle (degrees 56.31)\r\n    --> , Direction2d.fromAngle (degrees 0)\r\n    --> , Direction2d.fromAngle (degrees 56.31)\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> CubicSpline2d.Nondegenerate units coordinates -> List.List (Direction2d.Direction2d coordinates)"},{"name":"thirdDerivative","comment":" Get the third derivative of a spline (for a cubic spline, this is a\r\nconstant):\r\n\r\n    CubicSpline2d.thirdDerivative exampleSpline\r\n    --> Vector2d.fromComponents ( 0, 72 )\r\n\r\n","type":"CubicSpline2d.CubicSpline2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"translateBy","comment":" Translate a spline by a given displacement.\r\n\r\n    displacement =\r\n        Vector2d.fromComponents ( 2, 3 )\r\n\r\n    CubicSpline2d.translateBy displacement exampleSpline\r\n    --> CubicSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 3, 4 )\r\n    -->     , startControlPoint =\r\n    -->         Point2d.fromCoordinates ( 5, 7 )\r\n    -->     , endControlPoint =\r\n    -->         Point2d.fromCoordinates ( 7, 4 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 9, 7 )\r\n    -->     }\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> CubicSpline2d.CubicSpline2d units coordinates -> CubicSpline2d.CubicSpline2d units coordinates"},{"name":"translateIn","comment":" Translate a spline in a given direction by a given distance;\r\n\r\n    CubicSpline2d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    CubicSpline2d.translateBy\r\n        (Vector2d.withLength distance direction)\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Quantity.Quantity Basics.Float units -> CubicSpline2d.CubicSpline2d units coordinates -> CubicSpline2d.CubicSpline2d units coordinates"},{"name":"with","comment":" Construct a spline from its endpoints and control points:\r\n\r\n    exampleSpline =\r\n        CubicSpline2d.with\r\n            { startPoint =\r\n                Point2d.fromCoordinates ( 1, 1 )\r\n            , startControlPoint =\r\n                Point2d.fromCoordinates ( 3, 4 )\r\n            , endControlPoint =\r\n                Point2d.fromCoordinates ( 5, 1 )\r\n            , endPoint =\r\n                Point2d.fromCoordinates ( 7, 4 )\r\n            }\r\n\r\n","type":"{ startPoint : Point2d.Point2d units coordinates, startControlPoint : Point2d.Point2d units coordinates, endControlPoint : Point2d.Point2d units coordinates, endPoint : Point2d.Point2d units coordinates } -> CubicSpline2d.CubicSpline2d units coordinates"}],"binops":[]},{"name":"CubicSpline3d","comment":" A `CubicSpline3d` is a cubic [Bzier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)\r\nin 3D defined by a start point, end point and two control points. This module\r\ncontains functionality for\r\n\r\n  - Constructing splines\r\n  - Evaluating points and derivatives along a spline\r\n  - Scaling, rotating, translating or mirroring a spline\r\n  - Converting a spline between local and global coordinates in different\r\n    reference frames\r\n\r\n@docs CubicSpline3d\r\n\r\n\r\n# Constructors\r\n\r\n@docs with, fromEndpoints, on, fromQuadraticSpline\r\n\r\n\r\n# Properties\r\n\r\n@docs startPoint, endPoint, startControlPoint, endControlPoint, startDerivative, endDerivative, boundingBox\r\n\r\n\r\n# Evaluation\r\n\r\n@docs pointOn, pointsAt\r\n@docs Nondegenerate, nondegenerate, fromNondegenerate\r\n@docs tangentDirection, tangentDirectionsAt, sample, samplesAt\r\n\r\n\r\n# Transformations\r\n\r\n@docs reverse, scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross, projectOnto\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn, projectInto\r\n\r\n\r\n# Subdivision\r\n\r\n@docs bisect, splitAt\r\n\r\n\r\n# Arc length parameterization\r\n\r\n@docs ArcLengthParameterized, arcLengthParameterized, arcLength, midpoint, pointAlong, tangentDirectionAlong, sampleAlong\r\n\r\n\r\n## Low level\r\n\r\nAn `ArcLengthParameterized` value is a combination of an\r\n[`ArcLengthParameterization`](Geometry-ArcLengthParameterization) and an\r\nunderlying `CubicSpline3d`. If you need to do something fancy, you can extract\r\nthese two values separately.\r\n\r\n@docs arcLengthParameterization, fromArcLengthParameterized\r\n\r\n\r\n# Differentiation\r\n\r\nYou are unlikely to need to use these functions directly, but they are useful if\r\nyou are writing low-level geometric algorithms.\r\n\r\n@docs firstDerivative, firstDerivativesAt, secondDerivative, secondDerivativesAt, thirdDerivative, maxSecondDerivativeMagnitude\r\n\r\n","unions":[{"name":"ArcLengthParameterized","comment":" A spline that has been parameterized by arc length.\r\n","args":["units","coordinates"],"cases":[]},{"name":"Nondegenerate","comment":" If a curve has zero length (consists of just a single point), then we say\r\nthat it is 'degenerate'. Some operations such as computing tangent directions\r\nare not defined on degenerate curves.\r\n\r\nA `Nondegenerate` value represents a spline that is definitely not degenerate.\r\nIt is used as input to functions such as `CubicSpline3d.tangentDirection` and\r\ncan be constructed using `CubicSpline3d.nondegenerate`.\r\n\r\n","args":["units","coordinates"],"cases":[]}],"aliases":[{"name":"CubicSpline3d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.CubicSpline3d units coordinates"}],"values":[{"name":"arcLength","comment":" Find the total arc length of a spline:\r\n\r\n    arcLength =\r\n        CubicSpline3d.arcLength parameterizedSpline\r\n\r\n    arcLength\r\n    --> 4.3303\r\n\r\nIn this example, the result will be accurate to within `1.0e-4` since that was\r\nthe tolerance used when constructing `parameterizedSpline`.\r\n\r\n","type":"CubicSpline3d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"arcLengthParameterization","comment":" ","type":"CubicSpline3d.ArcLengthParameterized units coordinates -> Curve.ArcLengthParameterization.ArcLengthParameterization units"},{"name":"arcLengthParameterized","comment":" Build an arc length parameterization of the given spline, with a given\r\naccuracy. Generally speaking, all operations on the resulting\r\n`ArcLengthParameterized` value will be accurate to within the specified maximum\r\nerror.\r\n\r\n    parameterizedSpline =\r\n        exampleSpline\r\n            |> CubicSpline3d.arcLengthParameterized\r\n                { maxError = 1.0e-4 }\r\n\r\n","type":"{ maxError : Quantity.Quantity Basics.Float units } -> CubicSpline3d.CubicSpline3d units coordinates -> CubicSpline3d.ArcLengthParameterized units coordinates"},{"name":"bisect","comment":" Split a spline into two roughly equal halves.\r\n\r\n    CubicSpline3d.bisect exampleSpline\r\n    --> ( CubicSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 1, 1, 1 )\r\n    -->     , startControlPoint =\r\n    -->         Point3d.fromCoordinates ( 2, 1, 1 )\r\n    -->     , endControlPoint =\r\n    -->         Point3d.fromCoordinates ( 2.5, 1.5, 1 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 2.75, 2, 1.25 )\r\n    -->     }\r\n    --> , CubicSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 2.75, 2, 1.25 )\r\n    -->     , startControlPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 2.5, 1.5 )\r\n    -->     , endControlPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 3, 2 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 3, 3 )\r\n    -->     }\r\n    --> )\r\n\r\nEquivalent to `CubicSpline3d.splitAt ParameterValue.half`.\r\n\r\n","type":"CubicSpline3d.CubicSpline3d units coordinates -> ( CubicSpline3d.CubicSpline3d units coordinates, CubicSpline3d.CubicSpline3d units coordinates )"},{"name":"boundingBox","comment":" Compute a bounding box for a given spline. It is not guaranteed that the\r\nresult will be the _smallest_ possible bounding box, since for efficiency the\r\nbounding box is computed from the spline's control points (which cover a larger\r\nvolume than the spline itself).\r\n\r\n    CubicSpline3d.boundingBox exampleSpline\r\n    --> BoundingBox3d.fromExtrema\r\n    -->     { minX = 1\r\n    -->     , maxX = 3\r\n    -->     , minY = 1\r\n    -->     , maxY = 3\r\n    -->     , minZ = 1\r\n    -->     , maxZ = 3\r\n    -->     }\r\n\r\n","type":"CubicSpline3d.CubicSpline3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates"},{"name":"endControlPoint","comment":" Get the end control point of a spline (the control point next to the\r\nend point).\r\n","type":"CubicSpline3d.CubicSpline3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"endDerivative","comment":" Get the end derivative of a spline. This is equal to three times the vector\r\nfrom the spline's end control point to its end point.\r\n\r\n    CubicSpline3d.endDerivative exampleSpline\r\n    --> Vector3d.fromComponents ( 0, 0, 6 )\r\n\r\n","type":"CubicSpline3d.CubicSpline3d units coordinates -> Vector3d.Vector3d units coordinates"},{"name":"endPoint","comment":" Get the end point of a spline.\r\n\r\n    CubicSpline3d.endPoint exampleSpline\r\n    --> Point3d.fromCoordinates ( 3, 3, 3 )\r\n\r\n","type":"CubicSpline3d.CubicSpline3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"firstDerivative","comment":" Get the first derivative of a spline at a given parameter value.\r\n\r\n    CubicSpline3d.derivative exampleSpline\r\n        ParameterValue.zero\r\n    --> Vector3d.fromComponents ( 6, 0, 0 )\r\n\r\n    CubicSpline3d.derivative exampleSpline\r\n        ParameterValue.half\r\n    --> Vector3d.fromComponents ( 1.5, 3, 1.5 )\r\n\r\n    CubicSpline3d.derivative exampleSpline\r\n        ParameterValue.one\r\n    --> Vector3d.fromComponents ( 0, 0, 6 )\r\n\r\n","type":"CubicSpline3d.CubicSpline3d units coordinates -> Curve.ParameterValue.ParameterValue -> Vector3d.Vector3d units coordinates"},{"name":"firstDerivativesAt","comment":" Evaluate the first derivative of a spline at a range of parameter values.\r\n\r\n    exampleSpline\r\n        |> CubicSpline3d.firstDerivativesAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Vector3d.fromComponents ( 6, 0, 0 )\r\n    --> , Vector3d.fromComponents ( 1.5, 3, 1.5 )\r\n    --> , Vector3d.fromComponents ( 0, 0, 6 )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> CubicSpline3d.CubicSpline3d units coordinates -> List.List (Vector3d.Vector3d units coordinates)"},{"name":"fromArcLengthParameterized","comment":" ","type":"CubicSpline3d.ArcLengthParameterized units coordinates -> CubicSpline3d.CubicSpline3d units coordinates"},{"name":"fromEndpoints","comment":" Construct a spline from a given start point with a given start derivative,\r\nto a given end point with a given end derivative, like so:\r\n\r\n![Cubic spline from endpoints](https://ianmackenzie.github.io/elm-geometry/1.0.0/CubicSpline2d/fromEndpoints.svg)\r\n\r\nThe spline is based on a parameter that ranges from 0 to 1; as a result, in most\r\ncases the length of each derivative vector should be roughly equal to the length\r\nof the resulting spline.\r\n\r\n","type":"{ startPoint : Point3d.Point3d units coordinates, startDerivative : Vector3d.Vector3d units coordinates, endPoint : Point3d.Point3d units coordinates, endDerivative : Vector3d.Vector3d units coordinates } -> CubicSpline3d.CubicSpline3d units coordinates"},{"name":"fromNondegenerate","comment":" Convert a nondegenerate spline back to a general `CubicSpline3d`.\r\n\r\n    CubicSpline3d.fromNondegenerate\r\n        nondegenerateExampleSpline\r\n    --> exampleSpline\r\n\r\n","type":"CubicSpline3d.Nondegenerate units coordinates -> CubicSpline3d.CubicSpline3d units coordinates"},{"name":"fromQuadraticSpline","comment":" Convert a quadratic spline into the equivalent cubic spline (every quadratic\r\nspline can be represented exactly as a cubic spline).\r\n\r\n    quadraticSpline =\r\n        QuadraticSpline3d.with\r\n            { startPoint =\r\n                Point3d.fromCoordinates ( 0, 0, 0  )\r\n            , controlPoint =\r\n                Point3d.fromCoordinates ( 3, 0, 0 )\r\n            , endPoint =\r\n                Point3d.fromCoordinates ( 3, 3, 0 )\r\n            }\r\n\r\n    CubicSpline3d.fromQuadraticSpline quadraticSpline\r\n    --> CubicSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 0, 0, 0 )\r\n    -->     , startControlPoint =\r\n    -->         Point3d.fromCoordinates ( 2, 0, 0 )\r\n    -->     , endControlPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 1, 0 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 3, 0 )\r\n    -->     )\r\n\r\n","type":"QuadraticSpline3d.QuadraticSpline3d units coordinates -> CubicSpline3d.CubicSpline3d units coordinates"},{"name":"maxSecondDerivativeMagnitude","comment":" Find a conservative upper bound on the magnitude of the second derivative of\r\na spline. This can be useful when determining error bounds for various kinds of\r\nlinear approximations.\r\n","type":"CubicSpline3d.CubicSpline3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"midpoint","comment":" Get the midpoint of the spline.\r\n\r\n    CubicSpline3d.midpoint parameterizedSpline\r\n    --> Point3d.fromCoordinates (2.750000000000003,2.0000000000000067,1.2500000000000033)\r\n\r\n","type":"CubicSpline3d.ArcLengthParameterized units coordinates -> Point3d.Point3d units coordinates"},{"name":"mirrorAcross","comment":" Mirror a spline across a plane.\r\n\r\n    CubicSpline3d.mirrorAcross Plane3d.xy exampleSpline\r\n    --> CubicSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 1, 1, -1 )\r\n    -->     , startControlPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 1, -1 )\r\n    -->     , endControlPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 3, -1 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 3, -3 )\r\n    -->     }\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> CubicSpline3d.CubicSpline3d units coordinates -> CubicSpline3d.CubicSpline3d units coordinates"},{"name":"nondegenerate","comment":" Attempt to construct a nondegenerate spline from a general `CubicSpline3d`.\r\nIf the spline is in fact degenerate (consists of a single point), returns an\r\n`Err` with that point.\r\n\r\n    CubicSpline3d.nondegenerate exampleSpline\r\n    --> Ok nondegenerateExampleSpline\r\n\r\n","type":"CubicSpline3d.CubicSpline3d units coordinates -> Result.Result (Point3d.Point3d units coordinates) (CubicSpline3d.Nondegenerate units coordinates)"},{"name":"on","comment":" Construct a 3D spline lying _on_ a sketch plane by providing a 2D spline\r\nspecified in XY coordinates _within_ the sketch plane.\r\n\r\n    CubicSpline3d.on SketchPlane3d.xz <|\r\n        CubicSpline2d.with\r\n            { startPoint =\r\n                Point2d.fromCoordinates ( 1, 1 )\r\n            , startControlPoint =\r\n                Point2d.fromCoordinates ( 3, 4 )\r\n            , endControlPoint =\r\n                Point2d.fromCoordinates ( 5, 1 )\r\n            , endPoint =\r\n                Point2d.fromCoordinates ( 7, 4 )\r\n            }\r\n    --> CubicSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 1, 0, 1 )\r\n    -->     , startControlPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 0, 4 )\r\n    -->     , endControlPoint =\r\n    -->         Point3d.fromCoordinates ( 5, 0, 1 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 7, 0, 4 )\r\n    -->     }\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates3d coordinates2d -> CubicSpline2d.CubicSpline2d units coordinates2d -> CubicSpline3d.CubicSpline3d units coordinates3d"},{"name":"placeIn","comment":" Take a spline considered to be defined in local coordinates relative to a\r\ngiven reference frame, and return that spline expressed in global coordinates.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    CubicSpline3d.placeIn localFrame exampleSpline\r\n    --> CubicSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 2, 3, 4 )\r\n    -->     , startControlPoint =\r\n    -->         Point3d.fromCoordinates ( 4, 3, 4 )\r\n    -->     , endControlPoint =\r\n    -->         Point3d.fromCoordinates ( 4, 5, 4 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 4, 5, 6 )\r\n    -->     }\r\n\r\n","type":"Frame3d.Frame3d units globalCoordinates localCoordinates -> CubicSpline3d.CubicSpline3d units localCoordinates -> CubicSpline3d.CubicSpline3d units globalCoordinates"},{"name":"pointAlong","comment":" Try to get the point along a spline at a given arc length. For example, to\r\nget the point a quarter of the way along `exampleSpline`:\r\n\r\n    CubicSpline3d.pointAlong parameterizedSpline\r\n        (arcLength / 4)\r\n    --> Just <|\r\n    -->     Point3d.fromCoordinates\r\n    -->         ( 2.0425, 1.2431, 1.0206 )\r\n\r\nNote that this is not the same as evaulating at a parameter value of 1/4:\r\n\r\n    CubicSpline3d.pointOn exampleSpline\r\n        (ParameterValue.clamped 0.25)\r\n    --> Point3d.fromCoordinates ( 2.1563, 1.3125, 1.0313 )\r\n\r\nIf the given arc length is less than zero or greater than the arc length of the\r\nspline, returns `Nothing`.\r\n\r\n","type":"CubicSpline3d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units -> Maybe.Maybe (Point3d.Point3d units coordinates)"},{"name":"pointOn","comment":" Get a point at a given parameter value.\r\n\r\n    CubicSpline3d.pointOn exampleSpline ParameterValue.zero\r\n    --> Point3d.fromCoordinates ( 1, 1, 1 )\r\n\r\n    CubicSpline3d.pointOn exampleSpline ParameterValue.half\r\n    --> Point3d.fromCoordinates ( 2.75, 2, 1.25 )\r\n\r\n    CubicSpline3d.pointOn exampleSpline ParameterValue.one\r\n    --> Point3d.fromCoordinates ( 3, 3, 3 )\r\n\r\n","type":"CubicSpline3d.CubicSpline3d units coordinates -> Curve.ParameterValue.ParameterValue -> Point3d.Point3d units coordinates"},{"name":"pointsAt","comment":" Get points along a spline at a given set of parameter values.\r\n\r\n    exampleSpline\r\n        |> CubicSpline3d.pointsAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Point3d.fromCoordinates ( 1, 1, 1 )\r\n    --> , Point3d.fromCoordinates ( 2.75, 2, 1.25 )\r\n    --> , Point3d.fromCoordinates ( 3, 3, 3 )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> CubicSpline3d.CubicSpline3d units coordinates -> List.List (Point3d.Point3d units coordinates)"},{"name":"projectInto","comment":" Project a spline into a given sketch plane. Conceptually, this finds the\r\n[orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof the spline onto the plane and then expresses the projected spline in 2D\r\nsketch coordinates.\r\n\r\n    exampleSpline\r\n        |> CubicSpline3d.projectInto SketchPlane3d.yz\r\n    --> CubicSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 1, 1 )\r\n    -->     , startControlPoint =\r\n    -->         Point2d.fromCoordinates ( 1, 1 )\r\n    -->     , endControlPoint =\r\n    -->         Point2d.fromCoordinates ( 3, 1 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 3, 3 )\r\n    -->     }\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates3d coordinates2d -> CubicSpline3d.CubicSpline3d units coordinates3d -> CubicSpline2d.CubicSpline2d units coordinates2d"},{"name":"projectOnto","comment":" Find the [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof a spline onto a plane.\r\n\r\n    CubicSpline3d.projectOnto Plane3d.xy exampleSpline\r\n    --> CubicSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 1, 1, 0 )\r\n    -->     , startControlPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 1, 0 )\r\n    -->     , endControlPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 3, 0 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 3, 0 )\r\n    -->     }\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> CubicSpline3d.CubicSpline3d units coordinates -> CubicSpline3d.CubicSpline3d units coordinates"},{"name":"relativeTo","comment":" Take a spline defined in global coordinates, and return it expressed in\r\nlocal coordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    CubicSpline3d.relativeTo localFrame exampleSpline\r\n    --> CubicSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 0, -1, -2 )\r\n    -->     , startControlPoint =\r\n    -->         Point3d.fromCoordinates ( 2, -1, -2 )\r\n    -->     , endControlPoint =\r\n    -->         Point3d.fromCoordinates ( 2, 1, -2 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 2, 1, 0 )\r\n    -->     }\r\n\r\n","type":"Frame3d.Frame3d units globalCoordinates localCoordinates -> CubicSpline3d.CubicSpline3d units globalCoordinates -> CubicSpline3d.CubicSpline3d units localCoordinates"},{"name":"reverse","comment":" Reverse a spline so that the start point becomes the end point, and vice\r\nversa.\r\n\r\n    CubicSpline3d.reverse exampleSpline\r\n    --> CubicSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 3, 3 )\r\n    -->     , startControlPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 3, 1 )\r\n    -->     , endControlPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 1, 1 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 1, 1, 1 )\r\n    -->     }\r\n\r\n","type":"CubicSpline3d.CubicSpline3d units coordinates -> CubicSpline3d.CubicSpline3d units coordinates"},{"name":"rotateAround","comment":" Rotate a spline counterclockwise around a given axis by a given angle (in\r\nradians).\r\n\r\n    exampleSpline\r\n        |> CubicSpline3d.rotateAround Axis3d.z (degrees 90)\r\n    --> CubicSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( -1, 1, 1 )\r\n    -->     , startControlPoint =\r\n    -->         Point3d.fromCoordinates ( -1, 3, 1 )\r\n    -->     , endControlPoint =\r\n    -->         Point3d.fromCoordinates ( -3, 3, 1 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( -3, 3, 3 )\r\n    -->     }\r\n\r\n","type":"Axis3d.Axis3d units coordinates -> Angle.Angle -> CubicSpline3d.CubicSpline3d units coordinates -> CubicSpline3d.CubicSpline3d units coordinates"},{"name":"sample","comment":" Get both the point and tangent direction of a nondegenerate spline at a\r\ngiven parameter value:\r\n\r\n    CubicSpline3d.sample nondegenerateExampleSpline\r\n        ParameterValue.half\r\n    --> ( Point3d.fromCoordinates ( 2.75, 2, 1.25 )\r\n    --> , Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 63.43)\r\n    -->     (degrees 24.09)\r\n    --> )\r\n\r\n","type":"CubicSpline3d.Nondegenerate units coordinates -> Curve.ParameterValue.ParameterValue -> ( Point3d.Point3d units coordinates, Direction3d.Direction3d coordinates )"},{"name":"sampleAlong","comment":" Try to get the point and tangent direction along a spline at a given arc\r\nlength. To get the point and tangent direction a quarter of the way along\r\n`exampleSpline`:\r\n\r\n    CubicSpline3d.sampleAlong parameterizedSpline\r\n        (0.25 * arcLength)\r\n    --> Just\r\n    -->     ( Point3d.fromCoordinates\r\n    -->         ( 2.0425, 1.2431, 1.0206 )\r\n    -->     , Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 29.1)\r\n    -->         (degrees 3.871)\r\n    -->     )\r\n\r\nIf the given arc length is less than zero or greater than the arc length of the\r\nspline (or if the spline is degenerate), returns `Nothing`.\r\n\r\n","type":"CubicSpline3d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units -> Maybe.Maybe ( Point3d.Point3d units coordinates, Direction3d.Direction3d coordinates )"},{"name":"samplesAt","comment":" Get points and tangent directions of a nondegenerate spline at a given set\r\nof parameter values:\r\n\r\n    nondegenerateExampleSpline\r\n        |> CubicSpline3d.samplesAt\r\n            (ParameterValue.steps 2)\r\n    --> [ ( Point3d.fromCoordinates ( 1, 1, 1 )\r\n    -->   , Direction3d.x\r\n    -->   )\r\n    --> , ( Point3d.fromCoordinates ( 2.75, 2, 1.25 )\r\n    -->   , Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 63.43)\r\n    -->         (degrees 24.09)\r\n    -->   )\r\n    --> , ( Point3d.fromCoordinates ( 3, 3, 3 )\r\n    -->   , Direction3d.z\r\n    -->   )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> CubicSpline3d.Nondegenerate units coordinates -> List.List ( Point3d.Point3d units coordinates, Direction3d.Direction3d coordinates )"},{"name":"scaleAbout","comment":" Scale a spline about the given center point by the given scale.\r\n\r\n    CubicSpline3d.scaleAbout Point3d.origin 2 exampleSpline\r\n    --> CubicSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 2, 2, 2 )\r\n    -->     , startControlPoint =\r\n    -->         Point3d.fromCoordinates ( 6, 2, 2 )\r\n    -->     , endControlPoint =\r\n    -->         Point3d.fromCoordinates ( 6, 6, 2 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 6, 6, 6 )\r\n    -->     }\r\n\r\n","type":"Point3d.Point3d units coordinates -> Basics.Float -> CubicSpline3d.CubicSpline3d units coordinates -> CubicSpline3d.CubicSpline3d units coordinates"},{"name":"secondDerivative","comment":" Get the second derivative value at a point along a spline, based on a\r\nparameter that ranges from 0 to 1. A parameter value of 0 corresponds to the\r\nstart of the spline and a value of 1 corresponds to the end.\r\n\r\n    CubicSpline3d.secondDerivative exampleSpline\r\n        ParameterValue.zero\r\n    --> Vector3d.fromComponents ( -12, 12, 0 )\r\n\r\n    CubicSpline3d.secondDerivative exampleSpline\r\n        ParameterValue.half\r\n    --> Vector3d.fromComponents ( -6, 0, 6 )\r\n\r\n    CubicSpline3d.secondDerivative exampleSpline\r\n        ParameterValue.one\r\n    --> Vector3d.fromComponents ( 0, -12, 12 )\r\n\r\n","type":"CubicSpline3d.CubicSpline3d units coordinates -> Curve.ParameterValue.ParameterValue -> Vector3d.Vector3d units coordinates"},{"name":"secondDerivativesAt","comment":" Evaluate the second derivative of a spline at a range of parameter values.\r\n\r\n    exampleSpline\r\n        |> CubicSpline3d.secondDerivativesAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Vector3d.fromComponents ( -12, 12, 0 )\r\n    --> , Vector3d.fromComponents ( -6, 0, 6 )\r\n    --> , Vector3d.fromComponents ( 0, -12, 12 )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> CubicSpline3d.CubicSpline3d units coordinates -> List.List (Vector3d.Vector3d units coordinates)"},{"name":"splitAt","comment":" Split a spline at a particular parameter value, resulting in two smaller\r\nsplines.\r\n\r\n    parameterValue =\r\n        ParameterValue.clamped 0.75\r\n\r\n    CubicSpline3d.splitAt parameterValue exampleSpline\r\n    --> ( CubicSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 1, 1, 1 )\r\n    -->     , startControlPoint =\r\n    -->         Point3d.fromCoordinates ( 2.5, 1, 1 )\r\n    -->     , endControlPoint =\r\n    -->         Point3d.fromCoordinates ( 2.88, 2.13, 1 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 2.97, 2.69, 1.84 )\r\n    -->     }\r\n    --> , CubicSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 2.97, 2.69, 1.84 )\r\n    -->     , startControlPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 2.88, 2.13 )\r\n    -->     , endControlPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 3, 2.5 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 3, 3 )\r\n    -->     }\r\n    --> )\r\n\r\n","type":"Curve.ParameterValue.ParameterValue -> CubicSpline3d.CubicSpline3d units coordinates -> ( CubicSpline3d.CubicSpline3d units coordinates, CubicSpline3d.CubicSpline3d units coordinates )"},{"name":"startControlPoint","comment":" Get the start control point of a spline (the control point next to the\r\nstart point).\r\n","type":"CubicSpline3d.CubicSpline3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"startDerivative","comment":" Get the start derivative of a spline. This is equal to three times the\r\nvector from the spline's start point to its start control point.\r\n\r\n    CubicSpline3d.startDerivative exampleSpline\r\n    --> Vector3d.fromComponents ( 6, 0, 0 )\r\n\r\n","type":"CubicSpline3d.CubicSpline3d units coordinates -> Vector3d.Vector3d units coordinates"},{"name":"startPoint","comment":" Get the start point of a spline.\r\n\r\n    CubicSpline3d.startPoint exampleSpline\r\n    --> Point3d.fromCoordinates ( 1, 1, 1 )\r\n\r\n","type":"CubicSpline3d.CubicSpline3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"tangentDirection","comment":" Get the tangent direction to a nondegenerate spline at a given parameter\r\nvalue:\r\n\r\n    CubicSpline3d.tangentDirection\r\n        nondegenerateExampleSpline\r\n        ParameterValue.zero\r\n    --> Direction3d.x\r\n\r\n    CubicSpline3d.tangentDirection\r\n        nondegenerateExampleSpline\r\n        ParameterValue.half\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 63.43)\r\n    -->     (degrees 24.09)\r\n\r\n    CubicSpline3d.tangentDirection\r\n        nondegenerateExampleSpline\r\n        ParameterValue.one\r\n    --> Direction3d.z\r\n\r\n","type":"CubicSpline3d.Nondegenerate units coordinates -> Curve.ParameterValue.ParameterValue -> Direction3d.Direction3d coordinates"},{"name":"tangentDirectionAlong","comment":" Try to get the tangent direction along a spline at a given arc length. To\r\nget the tangent direction a quarter of the way along `exampleSpline`:\r\n\r\n    CubicSpline3d.tangentDirectionAlong parameterizedSpline\r\n        (0.25 * arcLength)\r\n    --> Just\r\n    -->     (Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 29.1)\r\n    -->         (degrees 3.871)\r\n    -->     )\r\n\r\nIf the given arc length is less than zero or greater than the arc length of the\r\nspline (or if the spline is degenerate), returns `Nothing`.\r\n\r\n","type":"CubicSpline3d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units -> Maybe.Maybe (Direction3d.Direction3d coordinates)"},{"name":"tangentDirectionsAt","comment":" Get tangent directions to a nondegenerate spline at a given set of parameter\r\nvalues:\r\n\r\n    nondegenerateExampleSpline\r\n        |> CubicSpline3d.tangentDirectionsAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Direction3d.x\r\n    --> , Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 63.43)\r\n    -->     (degrees 24.09)\r\n    --> , Direction3d.z\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> CubicSpline3d.Nondegenerate units coordinates -> List.List (Direction3d.Direction3d coordinates)"},{"name":"thirdDerivative","comment":" Get the third derivative of a spline (for a cubic spline, this is a\r\nconstant).\r\n","type":"CubicSpline3d.CubicSpline3d units coordinates -> Vector3d.Vector3d units coordinates"},{"name":"translateBy","comment":" Translate a spline by a given displacement.\r\n\r\n    displacement =\r\n        Vector3d.fromComponents ( 2, 3, 1 )\r\n\r\n    CubicSpline3d.translateBy displacement exampleSpline\r\n    --> CubicSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 4, 2 )\r\n    -->     , startControlPoint =\r\n    -->         Point3d.fromCoordinates ( 5, 4, 2 )\r\n    -->     , endControlPoint =\r\n    -->         Point3d.fromCoordinates ( 5, 6, 2 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 5, 6, 4 )\r\n    -->     }\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> CubicSpline3d.CubicSpline3d units coordinates -> CubicSpline3d.CubicSpline3d units coordinates"},{"name":"translateIn","comment":" Translate a spline in a given direction by a given distance;\r\n\r\n    CubicSpline3d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    CubicSpline3d.translateBy\r\n        (Vector3d.withLength distance direction)\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Quantity.Quantity Basics.Float units -> CubicSpline3d.CubicSpline3d units coordinates -> CubicSpline3d.CubicSpline3d units coordinates"},{"name":"with","comment":" Construct a spline from its four control points:\r\n\r\n    exampleSpline =\r\n        CubicSpline3d.with\r\n            { startPoint =\r\n                Point3d.fromCoordinates ( 1, 1, 1 )\r\n            , startControlPoint =\r\n                Point3d.fromCoordinates ( 3, 1, 1 )\r\n            , endControlPoint =\r\n                Point3d.fromCoordinates ( 3, 3, 1 )\r\n            , endPoint =\r\n                Point3d.fromCoordinates ( 3, 3, 3 )\r\n            }\r\n\r\n","type":"{ startPoint : Point3d.Point3d units coordinates, startControlPoint : Point3d.Point3d units coordinates, endControlPoint : Point3d.Point3d units coordinates, endPoint : Point3d.Point3d units coordinates } -> CubicSpline3d.CubicSpline3d units coordinates"}],"binops":[]},{"name":"Curve.ArcLengthParameterization","comment":" _You will likely never need to use this module directly._ In the vast\r\nmajority of cases the individual curve modules such as `QuadraticSpline2d`\r\nshould contain all the functionality you need to construct an arc length\r\nparameterization and use it to do things like evaluate a curve at evenly-spaced\r\npoints. This module is primarily for use internally by those curve modules, but\r\nmay be useful if you want to do some fancy mapping between arc length and curve\r\nparameter values.\r\n\r\n@docs ArcLengthParameterization\r\n\r\n\r\n# Constructing\r\n\r\n@docs build\r\n\r\n\r\n# Evaluating\r\n\r\n@docs totalArcLength, arcLengthToParameterValue, parameterValueToArcLength\r\n\r\n","unions":[{"name":"ArcLengthParameterization","comment":" Contains a mapping from curve parameter value to arc length, and vice versa.\r\n","args":["units"],"cases":[]}],"aliases":[],"values":[{"name":"arcLengthToParameterValue","comment":" Convert an arc length to the corresponding parameter value. If the given\r\narc length is less than zero or greater than the total arc length of the curve\r\n(as reported by `totalArcLength`), returns `Nothing`.\r\n","type":"Quantity.Quantity Basics.Float units -> Curve.ArcLengthParameterization.ArcLengthParameterization units -> Maybe.Maybe Curve.ParameterValue.ParameterValue"},{"name":"build","comment":" Build an arc length parameterization for some curve. You must supply:\r\n\r\n  - A `derivativeMagnitude` function that returns the magnitude of the first\r\n    derivative of the curve at a given parameter value\r\n  - The maximum magnitude of the second derivative of the curve\r\n  - A tolerance specifying the maximum error of the resulting parameterization\r\n\r\n","type":"{ maxError : Quantity.Quantity Basics.Float units, derivativeMagnitude : Curve.ParameterValue.ParameterValue -> Quantity.Quantity Basics.Float units, maxSecondDerivativeMagnitude : Quantity.Quantity Basics.Float units } -> Curve.ArcLengthParameterization.ArcLengthParameterization units"},{"name":"parameterValueToArcLength","comment":" Convert a parameter value to the corresponding arc length.\r\n","type":"Curve.ParameterValue.ParameterValue -> Curve.ArcLengthParameterization.ArcLengthParameterization units -> Quantity.Quantity Basics.Float units"},{"name":"totalArcLength","comment":" Find the total arc length of some curve given its arc length\r\nparameterization;\r\n\r\n    ArcLengthParameterization.totalArcLength\r\n        parameterization\r\n\r\nis equivalent to\r\n\r\n    ArcLengthParameterization.parameterValueToArcLength\r\n        ParameterValue.one\r\n        parameterization\r\n\r\nbut is more efficient.\r\n\r\n","type":"Curve.ArcLengthParameterization.ArcLengthParameterization units -> Quantity.Quantity Basics.Float units"}],"binops":[]},{"name":"Curve.ParameterValue","comment":" Curves in `elm-geometry` are [parameterized](https://en.wikipedia.org/wiki/Parametric_equation)\nby a value that ranges from 0 to 1. A value of 0 corresponds to the start point\nof the curve and a value of 1 corresponds to the end point. This module contains\nfunctionality for:\n\n  - Constructing parameter values that are guaranteed to be in the range 0 to 1\n  - Constructing ranges of evenly-spaced parameter values\n\n@docs ParameterValue\n\n\n# Constants\n\n@docs zero, half, one\n\n\n# Conversion to and from `Float` values\n\n@docs value, clamped, checked, unsafe\n\n\n# Ranges\n\n@docs steps, leading, trailing, midpoints, range\n\n\n# Arithmetic\n\n@docs midpoint, oneMinus\n\n","unions":[{"name":"ParameterValue","comment":" A parameter value between 0 and 1. Curve types such as [`Arc2d`](Arc2d) and\n[`CubicSpline3d`](CubicSpline3d) use `ParameterValue` arguments for curve\nevaluation functions such as [`Arc2d.pointOn`](Arc2d#pointOn) and\n[`CubicSpline3d.samplesAt`](CubicSpline3d#samplesAt).\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"checked","comment":" If the given value is between 0 and 1, return `Just` that value as a\n`ParameterValue`. Otherwise, return `Nothing`.\n\n    ParameterValue.checked 0.75\n        |> Maybe.map ParameterValue.value\n    --> Just 0.75\n\n    ParameterValue.checked -0.25\n    --> Nothing\n\n    ParameterValue.checked 1.25\n    --> Nothing\n\n","type":"Basics.Float -> Maybe.Maybe Curve.ParameterValue.ParameterValue"},{"name":"clamped","comment":" Construct a valid parameter value by clamping a plain `Float` value to\nbetween 0 and 1.\n\n    ParameterValue.value (ParameterValue.clamped 0.75)\n    --> 0.75\n\n    ParameterValue.value (ParameterValue.clamped -0.25)\n    --> 0\n\n    ParameterValue.value (ParameterValue.clamped 1.25)\n    --> 1\n\n","type":"Basics.Float -> Curve.ParameterValue.ParameterValue"},{"name":"half","comment":" The parameter value 0.5.\n\n    ParameterValue.value ParameterValue.half\n    --> 0.5\n\n","type":"Curve.ParameterValue.ParameterValue"},{"name":"leading","comment":" Construct a list of parameter values by dividing the range [0,1] into a\ngiven number of steps and then returning the value at the beginning of each\nstep.\n\n    ParameterValue.leading 0\n    --> []\n\n    ParameterValue.leading 1\n    --> [ ParameterValue.zero ]\n\n    Parametervalue.leading 2\n    --> [ ParameterValue.zero, ParameterValue.half ]\n\n    ParameterValue.leading 5\n        |> List.map ParameterValue.value\n    --> [ 0, 0.2, 0.4, 0.6, 0.8 ]\n\n","type":"Basics.Int -> List.List Curve.ParameterValue.ParameterValue"},{"name":"midpoint","comment":" Find the midpoint between two parameter values.\n\n    ParameterValue.midpoint\n        ParameterValue.zero\n        ParameterValue.one\n    --> ParameterValue.half\n\n","type":"Curve.ParameterValue.ParameterValue -> Curve.ParameterValue.ParameterValue -> Curve.ParameterValue.ParameterValue"},{"name":"midpoints","comment":" Construct a list of parameter values by dividing the range [0,1] into a\ngiven number of steps and then returning the value at the midpoint of each step.\n\n    ParameterValue.midpoints 0\n    --> []\n\n    ParameterValue.midpoints 1\n    --> [ ParameterValue.half ]\n\n    ParameterValue.midpoints 2\n        |> List.map ParameterValue.value\n    --> [ 0.25, 0.75 ]\n\n    ParameterValue.midpoints 5\n        |> List.map ParameterValue.value\n    --> [ 0.1, 0.3, 0.5, 0.7, 0.9 ]\n\n","type":"Basics.Int -> List.List Curve.ParameterValue.ParameterValue"},{"name":"one","comment":" The parameter value 1.\n\n    ParameterValue.value ParameterValue.one\n    --> 1\n\n","type":"Curve.ParameterValue.ParameterValue"},{"name":"oneMinus","comment":" Subtract a parameter value from 1 to give a new parameter value.\n\n    ParameterValue.oneMinus ParameterValue.one\n    --> ParameterValue.zero\n\n    ParameterValue.oneMinus ParameterValue.zero\n    --> ParameterValue.one\n\n    ParameterValue.oneMinus ParameterValue.half\n    --> ParameterValue.half\n\nThis can be thought of as the 'negation' or 'complement' of a parameter value.\nFor example, evaluating a reversed curve at a parameter value `t` is generally\nequivalent to evaluating the original curve at a parameter value\n<code>1&nbsp;-&nbsp;t</code>, and vice versa.\n\n","type":"Curve.ParameterValue.ParameterValue -> Curve.ParameterValue.ParameterValue"},{"name":"range","comment":" Construct a list of evenly-spaced parameter values between 0 and 1 by\nspecifying:\n\n  - the number of steps to take from 0 to 1\n  - whether to include the start value (0)\n  - whether to include the end value (1)\n\nThis is a more general form of `steps`, `leading` and `trailing`; for example,\n\n    ParameterValue.steps 10\n\nis equivalent to\n\n    ParameterValue.range\n        { numSteps = 10\n        , includeStart = True\n        , includeEnd = True\n        }\n\nand\n\n    ParameterValue.trailing 10\n\nis equivalent to\n\n    ParameterValue.range\n        { numSteps = 10\n        , includeStart = False\n        , includeEnd = True\n        }\n\n","type":"{ numSteps : Basics.Int, includeStart : Basics.Bool, includeEnd : Basics.Bool } -> List.List Curve.ParameterValue.ParameterValue"},{"name":"steps","comment":" Construct a list of parameter values by taking a given number of steps from\n0 to 1. Note that the number of returned values will in general be one greater\nthan the number of steps!\n\n    ParameterValue.steps 0\n    --> []\n\n    ParameterValue.steps 1\n    --> [ ParameterValue.zero, ParameterValue.one ]\n\n    Parametervalue.steps 2\n    --> [ ParameterValue.zero\n    --> , ParameterValue.half\n    --> , ParameterValue.one\n    --> ]\n\n    ParameterValue.steps 5\n        |> List.map ParameterValue.value\n    --> [ 0, 0.2, 0.4, 0.6, 0.8, 1 ]\n\n","type":"Basics.Int -> List.List Curve.ParameterValue.ParameterValue"},{"name":"trailing","comment":" Construct a list of parameter values by dividing the range [0,1] into a\ngiven number of steps and then returning the value at the end of each step.\n\n    ParameterValue.trailing 0\n    --> []\n\n    ParameterValue.trailing 1\n    --> [ ParameterValue.one ]\n\n    Parametervalue.trailing 2\n    --> [ ParameterValue.half, ParameterValue.one ]\n\n    ParameterValue.trailing 5\n        |> List.map ParameterValue.value\n    --> [ 0.2, 0.4, 0.6, 0.8, 1 ]\n\n","type":"Basics.Int -> List.List Curve.ParameterValue.ParameterValue"},{"name":"unsafe","comment":" Directly construct a `ParameterValue` from a `Float` without checking\nwhether it is valid. `ParameterValue.clamped` should generally be used instead,\nunless you are **very** sure you know what you are doing and\nprofiling/benchmarking shows that `ParameterValue.clamped` is a performance\nbottleneck.\n","type":"Basics.Float -> Curve.ParameterValue.ParameterValue"},{"name":"value","comment":" Convert a `ParameterValue` to a plain `Float` value between 0 and 1.\n\n    ParameterValue.value ParameterValue.half\n    --> 0.5\n\n","type":"Curve.ParameterValue.ParameterValue -> Basics.Float"},{"name":"zero","comment":" The parameter value 0.\n\n    ParameterValue.value ParameterValue.zero\n    --> 0\n\n","type":"Curve.ParameterValue.ParameterValue"}],"binops":[]},{"name":"DelaunayTriangulation2d","comment":" This module provides functionality for working with [Delaunay\r\ntriangulations](https://en.wikipedia.org/wiki/Delaunay_triangulation).\r\n\r\n![Delaunay triangulation](https://ianmackenzie.github.io/elm-geometry/1.2.0/DelaunayTriangulation2d/DelaunayTriangulation.png)\r\n\r\nYou can:\r\n\r\n  - Build a Delaunay triangulation from a set of points or arbitrary vertices\r\n  - Add a new vertex to an existing Delaunay triangulation\r\n  - Extract the resulting triangulation as a list of triangles or a\r\n    [`TriangularMesh`](https://package.elm-lang.org/packages/ianmackenzie/elm-triangular-mesh/latest/TriangularMesh#TriangularMesh)\r\n\r\nThe current implementation is somewhat inefficient, but there are plans to speed\r\nit up in the future (without requiring any changes to the API).\r\n\r\n@docs DelaunayTriangulation2d, Error, Face\r\n\r\n\r\n# Construction\r\n\r\nConstructing a Delaunay triangulation from points/vertices is currently an\r\nO(n^2) operation but should be O(n log n) in the future.\r\n\r\n@docs empty\r\n\r\n@docs fromPoints, fromVerticesBy\r\n\r\n\r\n# Modification\r\n\r\nInserting a point into a Delaunay triangulation is currently an O(n) operation\r\nbut should be O(log n) in the future.\r\n\r\n@docs insertPoint, insertVertexBy\r\n\r\n\r\n# Properties\r\n\r\n@docs vertices, triangles, circumcircles, faces, toMesh\r\n\r\n","unions":[{"name":"Error","comment":" An error type indicating that the two given vertices have the same position.\r\n","args":["vertex"],"cases":[["CoincidentVertices",["vertex","vertex"]]]}],"aliases":[{"name":"DelaunayTriangulation2d","comment":" A 2D Delaunay triangulation of a set of vertices.\r\n","args":["vertex","units","coordinates"],"type":"Geometry.Types.DelaunayTriangulation2d vertex units coordinates"},{"name":"Face","comment":" All the details about a particular face of a Delaunay triangulation:\r\n\r\n  - The three input vertices it is formed from\r\n  - The `Triangle2d` defining its shape\r\n  - The circumcircle of that triangle\r\n\r\n","args":["vertex","units","coordinates"],"type":"{ vertices : ( vertex, vertex, vertex ), triangle : Triangle2d.Triangle2d units coordinates, circumcircle : Circle2d.Circle2d units coordinates }"}],"values":[{"name":"circumcircles","comment":" Get all circumcircles in a given Delaunay triangulation;\r\n\r\n    DelaunayTriangulation2d.circumcircles triangulation\r\n\r\nis equivalent to\r\n\r\n    DelaunayTriangulation2d.faces triangulation\r\n        |> List.map .circumcircle\r\n\r\nbut somewhat more efficient. Complexity: O(n).\r\n\r\n","type":"DelaunayTriangulation2d.DelaunayTriangulation2d vertex units coordinates -> List.List (Circle2d.Circle2d units coordinates)"},{"name":"empty","comment":" An empty Delaunay triangulation with no vertices or faces.\r\n","type":"DelaunayTriangulation2d.DelaunayTriangulation2d vertex units coordinates"},{"name":"faces","comment":" Get a list of all `Face`s in a given Delaunay triangulation. Complexity:\r\nO(n).\r\n","type":"DelaunayTriangulation2d.DelaunayTriangulation2d vertex units coordinates -> List.List (DelaunayTriangulation2d.Face vertex units coordinates)"},{"name":"fromPoints","comment":" Construct a Delaunay triangulation from an array of points. The points must\r\nall be distinct; if any two points are equal, you will get an `Err\r\nCoincidentVertices`.\r\n\r\nNote that if all points are collinear, then the resulting triangulation will\r\nbe empty (have no faces).\r\n\r\n","type":"Array.Array (Point2d.Point2d units coordinates) -> Result.Result (DelaunayTriangulation2d.Error (Point2d.Point2d units coordinates)) (DelaunayTriangulation2d.DelaunayTriangulation2d (Point2d.Point2d units coordinates) units coordinates)"},{"name":"fromVerticesBy","comment":" Construct a Delaunay triangulation from an array of vertices of arbitrary\r\ntype, by supplying a function that returns the position of each vertex as a\r\n`Point2d`. For example, if you had\r\n\r\n    types alias Vertex =\r\n        { position = Point2d\r\n        , color = String\r\n        }\r\n\r\nand\r\n\r\n    vertices : Array Vertex\r\n    vertices =\r\n        ...\r\n\r\nthen you would use\r\n\r\n    DelaunayTriangulation2d.fromVerticesBy .position vertices\r\n\r\nThe vertices must all be distinct; if any two have the same position, you will\r\nget an `Err CoincidentVertices`.\r\n\r\nNote that if all vertices are collinear, then the resulting triangulation will\r\nbe empty (have no faces).\r\n\r\n","type":"(vertex -> Point2d.Point2d units coordinates) -> Array.Array vertex -> Result.Result (DelaunayTriangulation2d.Error vertex) (DelaunayTriangulation2d.DelaunayTriangulation2d vertex units coordinates)"},{"name":"insertPoint","comment":" Add a new point into an existing Delaunay triangulation. It must not be\r\nequal to any existing point; if it is, you will get an `Err CoincidentVertices`.\r\n","type":"Point2d.Point2d units coordinates -> DelaunayTriangulation2d.DelaunayTriangulation2d (Point2d.Point2d units coordinates) units coordinates -> Result.Result (DelaunayTriangulation2d.Error (Point2d.Point2d units coordinates)) (DelaunayTriangulation2d.DelaunayTriangulation2d (Point2d.Point2d units coordinates) units coordinates)"},{"name":"insertVertexBy","comment":" Add a new vertex into an existing Delaunay triangulation, by supplying a\r\nfunction to get the position of the vertex. The vertex must not have the same\r\nposition as any existing vertex; if it is, you will get an `Err\r\nCoincidentVertices`.\r\n","type":"(vertex -> Point2d.Point2d units coordinates) -> vertex -> DelaunayTriangulation2d.DelaunayTriangulation2d vertex units coordinates -> Result.Result (DelaunayTriangulation2d.Error vertex) (DelaunayTriangulation2d.DelaunayTriangulation2d vertex units coordinates)"},{"name":"toMesh","comment":" Convert a Delaunay triangulation to a [`TriangularMesh`](https://package.elm-lang.org/packages/ianmackenzie/elm-triangular-mesh/latest/TriangularMesh#TriangularMesh).\r\nComplexity: O(n).\r\n","type":"DelaunayTriangulation2d.DelaunayTriangulation2d vertex units coordinates -> TriangularMesh.TriangularMesh vertex"},{"name":"triangles","comment":" Get all triangles in a given Delaunay triangulation;\r\n\r\n    DelaunayTriangulation2d.triangles triangulation\r\n\r\nis equivalent to\r\n\r\n    DelaunayTriangulation2d.faces triangulation\r\n        |> List.map .triangle\r\n\r\nbut somewhat more efficient. Complexity: O(n).\r\n\r\n","type":"DelaunayTriangulation2d.DelaunayTriangulation2d vertex units coordinates -> List.List (Triangle2d.Triangle2d units coordinates)"},{"name":"vertices","comment":" Get the vertices of a Delaunay triangulation. If the triangulation was\r\nconstructed by calling `fromPoints` or `fromVerticesBy`, then the returned\r\nvertex array will simply be the array that was passed in. If any vertices were\r\nadded using `insertPoint` or `insertVertexBy`, then they will be appended to\r\nthe end of the array. This is a simple accessor, so complexity is O(1).\r\n","type":"DelaunayTriangulation2d.DelaunayTriangulation2d vertex units coordinates -> Array.Array vertex"}],"binops":[]},{"name":"Direction2d","comment":" A `Direction2d` represents a direction like 'up' or 'north' or 'forwards'.\r\nThey are represented using X and Y components, and can be converted to vectors\r\nif necessary, but should be thought of as conceptually different. Directions\r\nhave several uses, such as:\r\n\r\n  - Constructing a vector from a length and direction\r\n  - Determining the component of a vector in a particular direction (for\r\n    example, finding the component of velocity in the up direction to get\r\n    vertical speed)\r\n  - Determining the (signed) angle between two directions\r\n  - Defining the orientation of an axis or reference frame\r\n\r\n@docs Direction2d\r\n\r\n\r\n# Constants\r\n\r\n@docs x, y, positiveX, negativeX, positiveY, negativeY\r\n\r\n\r\n# Constructors\r\n\r\n@docs from, perpendicularTo, orthonormalize, orthogonalize, unsafeFromComponents, unsafeFromComponentsIn\r\n\r\n\r\n# Conversions\r\n\r\n@docs fromAngle, toAngle, toVector\r\n\r\n\r\n# Properties\r\n\r\n@docs components, componentsIn, xComponent, yComponent, componentIn, angleFrom\r\n\r\n\r\n# Comparison\r\n\r\n@docs equalWithin\r\n\r\n\r\n# Transformations\r\n\r\n@docs reverse, rotateClockwise, rotateCounterclockwise, rotateBy, mirrorAcross\r\n\r\n\r\n# Coordinate conversions\r\n\r\nLike other transformations, coordinate transformations of directions depend only\r\non the orientations of the relevant frames, not the positions of their origin\r\npoints.\r\n\r\nFor the examples, assume the following frames have been defined:\r\n\r\n    upsideDownFrame =\r\n        Frame2d\r\n            { originPoint = Point2d.origin\r\n            , xDirection = Direction2d.positiveX\r\n            , yDirection = Direction2d.negativeY\r\n            }\r\n\r\n    rotatedFrame =\r\n        Frame2d.atOrigin |> Frame2d.rotateBy (degrees 30)\r\n\r\n@docs relativeTo, placeIn\r\n\r\n","unions":[],"aliases":[{"name":"Direction2d","comment":" ","args":["coordinates"],"type":"Geometry.Types.Direction2d coordinates"}],"values":[{"name":"angleFrom","comment":" Find the counterclockwise angle in radians from the first direction to the\r\nsecond. The result will be in the range - to .\r\n\r\n    referenceDirection =\r\n        Direction2d.fromAngle (degrees 30)\r\n\r\n    Direction2d.angleFrom referenceDirection Direction2d.y\r\n    --> degrees 60\r\n\r\n    Direction2d.angleFrom referenceDirection Direction2d.x\r\n    --> degrees -30\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Direction2d.Direction2d coordinates -> Angle.Angle"},{"name":"componentIn","comment":" Find the component of one direction in another direction. This is equal to\r\nthe cosine of the angle between the directions, or equivalently the dot product\r\nof the two directions converted to unit vectors.\r\n\r\n    direction =\r\n        Direction2d.fromAngle (degrees 60)\r\n\r\n    Direction2d.componentIn Direction2d.x direction\r\n    --> 0.5\r\n\r\n    Direction2d.componentIn direction direction\r\n    --> 1\r\n\r\n    Direction2d.componentIn Direction2d.x Direction2d.y\r\n    --> 0\r\n\r\nThis is more general and flexible than using `xComponent` or `yComponent`, both\r\nof which can be expressed in terms of `componentIn`; for example,\r\n\r\n    Direction2d.xComponent direction\r\n\r\nis equivalent to\r\n\r\n    Direction2d.componentIn Direction2d.x direction\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Direction2d.Direction2d coordinates -> Basics.Float"},{"name":"components","comment":" Get the components of a direction as a tuple (the components it would have\r\nas a unit vector, also know as its direction cosines).\r\n\r\n    ( x, y ) =\r\n        Direction2d.components direction\r\n\r\n","type":"Direction2d.Direction2d coordinates -> ( Basics.Float, Basics.Float )"},{"name":"componentsIn","comment":" Find the components of a direction in a given frame;\r\n\r\n    direction |> Direction2d.componentsIn frame\r\n\r\nis equivalent to\r\n\r\n    ( direction\r\n        |> Direction2d.componentIn\r\n            (Frame2d.xDirection frame)\r\n    , direction\r\n        |> Direction2d.componentIn\r\n            (Frame2d.yDirection frame)\r\n    )\r\n\r\n","type":"Geometry.Types.Frame2d units globalCoordinates localCoordinates -> Direction2d.Direction2d globalCoordinates -> ( Basics.Float, Basics.Float )"},{"name":"equalWithin","comment":" Compare two directions within an angular tolerance. Returns true if the\r\nabsolute value of the angle between the two given directions is less than the\r\ngiven tolerance.\r\n\r\n    firstDirection =\r\n        Direction2d.fromAngle (degrees 45)\r\n\r\n    secondDirection =\r\n        Direction2d.fromAngle (degrees 47)\r\n\r\n    Direction2d.equalWithin (degrees 5)\r\n        firstDirection\r\n        secondDirection\r\n    --> True\r\n\r\n    Direction2d.equalWithin (degrees 1)\r\n        firstDirection\r\n        secondDirection\r\n    --> False\r\n\r\n","type":"Angle.Angle -> Direction2d.Direction2d coordinates -> Direction2d.Direction2d coordinates -> Basics.Bool"},{"name":"from","comment":" Attempt to construct the direction from the first given point to the second.\r\nIf the two points are coincident, returns `Nothing`.\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 1, 1 )\r\n\r\n    Direction2d.from Point2d.origin point\r\n    --> Just (Direction2d.fromAngle (degrees 45))\r\n\r\n    Direction2d.from point Point2d.origin\r\n    --> Just (Direction2d.fromAngle (degrees -135))\r\n\r\n    Direction2d.from point point\r\n    --> Nothing\r\n\r\n","type":"Geometry.Types.Point2d units coordinates -> Geometry.Types.Point2d units coordinates -> Maybe.Maybe (Direction2d.Direction2d coordinates)"},{"name":"fromAngle","comment":" Construct a direction from an angle in radians, given counterclockwise from\r\nthe positive X direction.\r\n\r\n    Direction2d.fromAngle 0\r\n    --> Direction2d.x\r\n\r\n    Direction2d.fromAngle (degrees 90)\r\n    --> Direction2d.y\r\n\r\n    Direction2d.fromAngle (degrees -90)\r\n    --> Direction2d.negativeY\r\n\r\n","type":"Angle.Angle -> Direction2d.Direction2d coordinates"},{"name":"mirrorAcross","comment":" Mirror a direction across a particular axis. Note that only the direction of\r\nthe axis affects the result, since directions are position-independent.\r\n\r\n    slopedAxis =\r\n        Axis2d.through\r\n            (Point2d.fromCoordinates ( 100, 200 ))\r\n            (Direction2d.fromAngle (degrees 45))\r\n\r\n    Direction2d.mirrorAcross slopedAxis Direction2d.x\r\n    --> Direction2d.y\r\n\r\n    Direction2d.mirrorAcross slopedAxis Direction2d.y\r\n    --> Direction2d.x\r\n\r\n","type":"Geometry.Types.Axis2d units coordinates -> Direction2d.Direction2d coordinates -> Direction2d.Direction2d coordinates"},{"name":"negativeX","comment":" The negative X direction.\r\n\r\n    Direction2d.components Direction2d.negativeX\r\n    --> ( -1, 0 )\r\n\r\n","type":"Direction2d.Direction2d coordinates"},{"name":"negativeY","comment":" The negative Y direction.\r\n\r\n    Direction2d.components Direction2d.negativeY\r\n    --> ( 0, -1 )\r\n\r\n","type":"Direction2d.Direction2d coordinates"},{"name":"orthogonalize","comment":" Attempt to form a pair of perpendicular directions from the two given\r\ndirections;\r\n\r\n    Direction2d.orthogonalize xDirection yDirection\r\n\r\nis equivalent to\r\n\r\n    Direction2d.orthonormalize\r\n        (Direction2d.toVector xDirection)\r\n        (Direction2d.toVector yDirection)\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Direction2d.Direction2d coordinates -> Maybe.Maybe ( Direction2d.Direction2d coordinates, Direction2d.Direction2d coordinates )"},{"name":"orthonormalize","comment":" Attempt to form a pair of perpendicular directions from the two given\r\nvectors by performing [Gram-Schmidt normalization](https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process):\r\n\r\n  - The first returned direction will be equal to the direction of the first\r\n    given vector\r\n  - The second returned direction will be as close as possible to the second\r\n    given vector while being perpendicular to the first returned direction\r\n\r\nIf either of the given vectors are zero, or if the two vectors are parallel,\r\nreturns `Nothing`.\r\n\r\n    Direction2d.orthonormalize\r\n        (Vector2d.fromComponents ( 3, 3 ))\r\n        (Vector2d.fromComponents ( 0, -2 ))\r\n    --> Just\r\n    -->     ( Direction2d.fromAngle (degrees 45)\r\n    -->     , Direction2d.fromAngle (degrees -45)\r\n    -->     )\r\n\r\n    Direction2d.orthonormalize\r\n        (Vector2d.fromComponents ( 3, 3 ))\r\n        (Vector2d.fromComponents ( -2, -2 ))\r\n    --> Nothing\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Vector2d.Vector2d units coordinates -> Maybe.Maybe ( Direction2d.Direction2d coordinates, Direction2d.Direction2d coordinates )"},{"name":"perpendicularTo","comment":" Construct a direction perpendicular to the given direction, by rotating the\r\ngiven direction 90 degrees counterclockwise. Synonym for\r\n`rotateCounterclockwise`.\r\n\r\n    Direction2d.perpendicularTo Direction2d.x\r\n    --> Direction2d.y\r\n\r\n    Direction2d.perpendicularTo Direction2d.y\r\n    --> Direction2d.negativeX\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Direction2d.Direction2d coordinates"},{"name":"placeIn","comment":" Take a direction defined in local coordinates relative to a given reference\r\nframe, and return that direction expressed in global coordinates.\r\n\r\n    Direction2d.placeIn upsideDownFrame Direction2d.y\r\n    --> Direction2d.negativeY\r\n\r\n    Direction2d.placeIn rotatedFrame Direction2d.x\r\n    --> Direction2d.fromAngle (degrees 30)\r\n\r\n    Direction2d.placeIn rotatedFrame Direction2d.y\r\n    --> Direction2d.fromAngle (degrees 120)\r\n\r\n","type":"Geometry.Types.Frame2d units globalCoordinates localCoordinates -> Direction2d.Direction2d localCoordinates -> Direction2d.Direction2d globalCoordinates"},{"name":"positiveX","comment":" The positive X direction.\r\n\r\n    Direction2d.components Direction2d.positiveX\r\n    --> ( 1, 0 )\r\n\r\n","type":"Direction2d.Direction2d coordinates"},{"name":"positiveY","comment":" The positive Y direction.\r\n\r\n    Direction2d.components Direction2d.positiveY\r\n    --> ( 0, 1 )\r\n\r\n","type":"Direction2d.Direction2d coordinates"},{"name":"relativeTo","comment":" Take a direction defined in global coordinates, and return it expressed in\r\nlocal coordinates relative to a given reference frame.\r\n\r\n    Direction2d.relativeTo upsideDownFrame Direction2d.y\r\n    --> Direction2d.negativeY\r\n\r\n    Direction2d.relativeTo rotatedFrame Direction2d.x\r\n    --> Direction2d.fromAngle (degrees -30)\r\n\r\n    Direction2d.relativeTo rotatedFrame Direction2d.y\r\n    --> Direction2d.fromAngle (degrees 60)\r\n\r\n","type":"Geometry.Types.Frame2d units globalCoordinates localCoordinates -> Direction2d.Direction2d globalCoordinates -> Direction2d.Direction2d localCoordinates"},{"name":"reverse","comment":" Reverse a direction.\r\n\r\n    Direction2d.reverse Direction2d.y\r\n    --> Direction2d.negativeY\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Direction2d.Direction2d coordinates"},{"name":"rotateBy","comment":" Rotate a direction counterclockwise by a given angle (in radians).\r\n\r\n    Direction2d.rotateBy pi Direction2d.x\r\n    --> Direction2d.negativeX\r\n\r\n    Direction2d.rotateBy (degrees 45) Direction2d.y\r\n    --> Direction2d.fromAngle (degrees 135)\r\n\r\n","type":"Angle.Angle -> Direction2d.Direction2d coordinates -> Direction2d.Direction2d coordinates"},{"name":"rotateClockwise","comment":" Rotate a direction by 90 degrees clockwise.\r\n\r\n    Direction2d.rotateClockwise Direction2d.y\r\n    --> Direction2d.x\r\n\r\n    Direction2d.rotateClockwise Direction2d.x\r\n    --> Direction2d.negativeY\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Direction2d.Direction2d coordinates"},{"name":"rotateCounterclockwise","comment":" Rotate a direction by 90 degrees counterclockwise.\r\n\r\n    Direction2d.rotateClockwise Direction2d.x\r\n    --> Direction2d.y\r\n\r\n    Direction2d.rotateClockwise Direction2d.y\r\n    --> Direction2d.negativeX\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Direction2d.Direction2d coordinates"},{"name":"toAngle","comment":" Convert a direction to a polar angle (the counterclockwise angle in radians\r\nfrom the positive X direction). The result will be in the range - to .\r\n\r\n    Direction2d.toAngle Direction2d.x\r\n    --> 0\r\n\r\n    Direction2d.toAngle Direction2d.y\r\n    --> degrees 90\r\n\r\n    Direction2d.toAngle Direction2d.negativeY\r\n    --> degrees -90\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Angle.Angle"},{"name":"toVector","comment":" Convert a direction to a unit vector.\r\n\r\n    Direction2d.toVector Direction2d.x\r\n    --> Vector2d.fromComponents ( 1, 0 )\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Vector2d.Vector2d Quantity.Unitless coordinates"},{"name":"unsafeFromComponents","comment":" Construct a direction directly from its X and Y components. Note that **you\r\nmust ensure that the sum of the squares of the given components is exactly\r\none**:\r\n\r\n    Direction2d.unsafeFromComponents ( 1, 0 )\r\n\r\n    Direction2d.unsafeFromComponents ( 0, -1 )\r\n\r\n    Direction2d.unsafeFromComponents ( 0.6, 0.8 )\r\n\r\nare all valid but\r\n\r\n    Direction2d.unsafeFromComponents ( 2, 0 )\r\n\r\n    Direction2d.unsafeFromComponents ( 1, 1 )\r\n\r\nare not. Instead of using `Direction2d.unsafeFromComponents`, it may be easier\r\nto use constructors like `Direction2d.fromAngle` (which will always result in a\r\nvalid direction) or start with existing directions and transform them as\r\nnecessary.\r\n\r\n","type":"( Basics.Float, Basics.Float ) -> Direction2d.Direction2d coordinates"},{"name":"unsafeFromComponentsIn","comment":" Construct a direction directly from its local X and Y components within a\r\ngiven frame. As with `unsafeFromComponents`, you must ensure that the sum of the\r\nsquares of the given components is exactly one.\r\n","type":"Geometry.Types.Frame2d units globalCoordinates localCoordinates -> ( Basics.Float, Basics.Float ) -> Direction2d.Direction2d globalCoordinates"},{"name":"x","comment":" Synonym for `Direction2d.positiveX`.\r\n","type":"Direction2d.Direction2d coordinates"},{"name":"xComponent","comment":" Get the X component of a direction.\r\n\r\n    Direction2d.xComponent Direction2d.x\r\n    --> 1\r\n\r\n    Direction2d.xComponent Direction2d.y\r\n    --> 0\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Basics.Float"},{"name":"y","comment":" Synonym for `Direction2d.positiveY`.\r\n","type":"Direction2d.Direction2d coordinates"},{"name":"yComponent","comment":" Get the Y component of a direction.\r\n\r\n    Direction2d.yComponent Direction2d.x\r\n    --> 0\r\n\r\n    Direction2d.yComponent Direction2d.y\r\n    --> 1\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Basics.Float"}],"binops":[]},{"name":"Direction3d","comment":" A `Direction3d` represents a direction like 'up' or 'north' or 'forwards'.\r\nThey are represented using X, Y and Z components, and can be converted to\r\nvectors if necessary, but should be thought of as conceptually different.\r\nDirections have several uses, such as:\r\n\r\n  - Constructing a vector from a length and direction\r\n  - Determining the component of a vector in a particular direction (for\r\n    example, finding the component of velocity in the up direction to get\r\n    vertical speed)\r\n  - Determining the angle between two directions\r\n  - Defining the orientation of an axis, plane or reference frame\r\n\r\n@docs Direction3d\r\n\r\n\r\n# Constants\r\n\r\n@docs x, y, z, positiveX, negativeX, positiveY, negativeY, positiveZ, negativeZ\r\n\r\n\r\n# Constructors\r\n\r\n@docs from, on, fromAzimuthAndElevation, perpendicularTo, perpendicularBasis, orthonormalize, orthogonalize, unsafeFromComponents, unsafeFromComponentsIn\r\n\r\n\r\n# Conversion\r\n\r\n@docs toVector\r\n\r\n\r\n# Properties\r\n\r\n@docs components, componentsIn, xComponent, yComponent, zComponent, componentIn, angleFrom, azimuth, elevation\r\n\r\n\r\n# Comparison\r\n\r\n@docs equalWithin\r\n\r\n\r\n# Transformations\r\n\r\n@docs reverse, rotateAround, mirrorAcross, projectOnto\r\n\r\n\r\n# Coordinate conversions\r\n\r\nLike other transformations, coordinate transformations of directions depend only\r\non the orientations of the relevant frames, not their positions.\r\n\r\nFor the examples, assume the following definition of a local coordinate frame,\r\none that is rotated 30 degrees counterclockwise around the Z axis from the\r\nglobal XYZ frame:\r\n\r\n    rotatedFrame =\r\n        Frame3d.atOrigin\r\n            |> Frame3d.rotateAround Axis3d.z (degrees 30)\r\n\r\n@docs relativeTo, placeIn, projectInto\r\n\r\n","unions":[],"aliases":[{"name":"Direction3d","comment":" ","args":["coordinates"],"type":"Geometry.Types.Direction3d coordinates"}],"values":[{"name":"angleFrom","comment":" Find the angle from one direction to another. The result will be in the\r\nrange 0 to .\r\n\r\n    Direction3d.angleFrom Direction3d.x Direction3d.x\r\n    --> degrees 0\r\n\r\n    Direction3d.angleFrom Direction3d.x Direction3d.z\r\n    --> degrees 90\r\n\r\n    Direction3d.angleFrom\r\n        Direction3d.y\r\n        Direction3d.negativeY\r\n    --> degrees 180\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Direction3d.Direction3d coordinates -> Angle.Angle"},{"name":"azimuth","comment":" Get the angle of a direction in the XY plane, measured from the X axis\r\ntowards the Y axis (counterclockwise around the Z axis). The result will be in\r\nthe range - to .\r\n\r\n    Direction3d.azimuth Direction3d.x\r\n    --> 0\r\n\r\n    Direction3d.azimuth Direction3d.y\r\n    --> degrees 90\r\n\r\n    Direction3d.azimuth Direction3d.negativeY\r\n    --> degrees -90\r\n\r\n    Direction3d.azimuth Direction3d.negativeX\r\n    --> degrees 180\r\n\r\nVertical directions are considered to have an azimuth of zero:\r\n\r\n    Direction3d.azimuth Direction3d.z\r\n    --> 0\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Angle.Angle"},{"name":"componentIn","comment":" Find the component of one direction in another direction. This is equal to\r\nthe cosine of the angle between the directions, or equivalently the dot product\r\nof the two directions converted to unit vectors.\r\n\r\n    direction =\r\n        Direction3d.fromAzimuthAndElevation\r\n            (degrees 0)\r\n            (degrees 60)\r\n\r\n    Direction3d.componentIn Direction3d.x direction\r\n    --> 0.5\r\n\r\n    Direction3d.componentIn Direction3d.z direction\r\n    --> 0.866\r\n\r\n    Direction3d.componentIn direction direction\r\n    --> 1\r\n\r\n    direction\r\n        |> Direction3d.componentIn\r\n            (Direction3d.reverse direction)\r\n    --> -1\r\n\r\nThis is more general and flexible than using `xComponent`, `yComponent` or\r\n`zComponent`, all of which can be expressed in terms of `componentIn`; for\r\nexample,\r\n\r\n    Direction3d.zComponent direction\r\n\r\nis equivalent to\r\n\r\n    Direction3d.componentIn Direction3d.z direction\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Direction3d.Direction3d coordinates -> Basics.Float"},{"name":"components","comment":" Get the components of a direction as a tuple (the components it would have\r\nas a unit vector, also know as its direction cosines).\r\n\r\n    ( x, y, z ) =\r\n        Direction3d.components direction\r\n\r\n","type":"Direction3d.Direction3d coordinates -> ( Basics.Float, Basics.Float, Basics.Float )"},{"name":"componentsIn","comment":" Find the components of a direction in a given frame;\r\n\r\n    direction |> Direction3d.componentsIn frame\r\n\r\nis equivalent to\r\n\r\n    ( direction\r\n        |> Direction3d.componentIn\r\n            (Frame3d.xDirection frame)\r\n    , direction\r\n        |> Direction3d.componentIn\r\n            (Frame3d.yDirection frame)\r\n    , direction\r\n        |> Direction3d.componentIn\r\n            (Frame3d.zDirection frame)\r\n    )\r\n\r\n","type":"Geometry.Types.Frame3d units globalCoordinates localCoordinates -> Direction3d.Direction3d globalCoordinates -> ( Basics.Float, Basics.Float, Basics.Float )"},{"name":"elevation","comment":" Get the angle of a direction from the XY plane towards positive Z. The\r\nresult will be in the range -/2 to /2.\r\n\r\n    Direction3d.elevation Direction3d.x\r\n    --> 0\r\n\r\n    Direction3d.elevation Direction3d.negativeY\r\n    --> 0\r\n\r\n    Direction3d.elevation Direction3d.z\r\n    --> degrees 90\r\n\r\n    Direction3d.elevation Direction3d.negativeZ\r\n    --> degrees -90\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Angle.Angle"},{"name":"equalWithin","comment":" Compare two directions within an angular tolerance. Returns true if the\r\nangle between the two given directions is less than the given tolerance.\r\n\r\n    rotatedDirection =\r\n        Direction3d.x\r\n            |> Direction3d.rotateAround Axis3d.z\r\n                (degrees 2)\r\n\r\n    Direction3d.equalWithin (degrees 5)\r\n        Direction3d.x\r\n        rotatedDirection\r\n    --> True\r\n\r\n    Direction3d.equalWithin (degrees 1)\r\n        Direction3d.x\r\n        rotatedDirection\r\n    --> False\r\n\r\n","type":"Angle.Angle -> Direction3d.Direction3d coordinates -> Direction3d.Direction3d coordinates -> Basics.Bool"},{"name":"from","comment":" Attempt to construct the direction from the first given point to the second.\r\nIf the two points are coincident, returns `Nothing`.\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 1, 0, 1 )\r\n\r\n    Direction3d.from Point3d.origin point\r\n    --> Just\r\n    -->     (Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 0)\r\n    -->         (degrees 45)\r\n    -->     )\r\n\r\n    Direction3d.from point Point3d.origin\r\n    --> Just\r\n    -->     (Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 180)\r\n    -->         (degrees -45)\r\n    -->     )\r\n\r\n    Direction3d.from point point\r\n    --> Nothing\r\n\r\n","type":"Geometry.Types.Point3d units coordinates -> Geometry.Types.Point3d units coordinates -> Maybe.Maybe (Direction3d.Direction3d coordinates)"},{"name":"fromAzimuthAndElevation","comment":" Construct a direction using azimuthal and elevation angles relative to the\r\nglobal XYZ frame. The azimuth defines the direction's polar angle on the global\r\nXY plane (from X towards Y) and the elevation defines its angle out of the XY\r\nplane towards positive Z.\r\n\r\n    Direction3d.components\r\n        (Direction3d.fromAzimuthAndElevation\r\n            (degrees 45)\r\n            (degrees 45)\r\n        )\r\n    --> ( 0.5, 0.5, 0.7071 )\r\n\r\n","type":"Angle.Angle -> Angle.Angle -> Direction3d.Direction3d coordinates"},{"name":"mirrorAcross","comment":" Mirror a direction across a plane.\r\n\r\n    direction =\r\n        Direction3d.fromAzimuthAndElevation\r\n            (degrees 30)\r\n            (degrees 60)\r\n\r\n    Direction3d.mirrorAcross Plane3d.xy direction\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 30)\r\n    -->     (degrees -60)\r\n\r\nNote that only the normal direction of the plane affects the result, not the\r\nposition of its origin point, since directions are position-independent:\r\n\r\n    Direction3d.mirrorAcross Plane3d.yz direction\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 150)\r\n    -->     (degrees 60)\r\n\r\n    offsetPlane =\r\n        Plane3d.offsetBy 10 Plane3d.yz\r\n\r\n    Direction3d.mirrorAcross offsetPlane direction\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 150)\r\n    -->     (degrees 60)\r\n\r\n","type":"Geometry.Types.Plane3d units coordinates -> Direction3d.Direction3d coordinates -> Direction3d.Direction3d coordinates"},{"name":"negativeX","comment":" The negative X direction.\r\n\r\n    Direction3d.components Direction3d.negativeX\r\n    --> ( -1, 0, 0 )\r\n\r\n","type":"Direction3d.Direction3d coordinates"},{"name":"negativeY","comment":" The negative Y direction.\r\n\r\n    Direction3d.components Direction3d.negativeY\r\n    --> ( 0, -1, 0 )\r\n\r\n","type":"Direction3d.Direction3d coordinates"},{"name":"negativeZ","comment":" The negative Z direction.\r\n\r\n    Direction3d.components Direction3d.negativeZ\r\n    --> ( 0, 0, -1 )\r\n\r\n","type":"Direction3d.Direction3d coordinates"},{"name":"on","comment":" Construct a 3D direction lying _on_ a sketch plane by providing a 2D\r\ndirection specified in XY coordinates _within_ the sketch plane.\r\n\r\n    horizontalDirection =\r\n        Direction3d.on SketchPlane3d.xy <|\r\n            Direction2d.fromAngle (degrees 45)\r\n\r\n    Direction3d.components horizontalDirection\r\n    --> ( 0.7071, 0.7071, 0 )\r\n\r\n    thirtyDegreesFromZ =\r\n        Direction3d.on SketchPlane3d.zx <|\r\n            Direction2d.fromAngle (degrees 30)\r\n\r\n    Direction3d.components thirtyDegreesFromZ\r\n    --> ( 0.5, 0, 0.866 )\r\n\r\n","type":"Geometry.Types.SketchPlane3d units coordinates3d coordinates2d -> Direction2d.Direction2d coordinates2d -> Direction3d.Direction3d coordinates3d"},{"name":"orthogonalize","comment":" Attempt to form a set of three mutually perpendicular directions from the\r\nthree given directions;\r\n\r\n    Direction3d.orthogonalize\r\n        xDirection\r\n        yDirection\r\n        zDirection\r\n\r\nis equivalent to\r\n\r\n    Direction3d.orthonormalize\r\n        (Direction3d.toVector xDirection)\r\n        (Direction3d.toVector yDirection)\r\n        (Direction3d.toVector zDirection)\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Direction3d.Direction3d coordinates -> Direction3d.Direction3d coordinates -> Maybe.Maybe ( Direction3d.Direction3d coordinates, Direction3d.Direction3d coordinates, Direction3d.Direction3d coordinates )"},{"name":"orthonormalize","comment":" Attempt to form a set of three mutually perpendicular directions from the\r\nthree given vectors by performing [Gram-Schmidt normalization](https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process):\r\n\r\n  - The first returned direction will be equal to the direction of the first\r\n    given vector\r\n  - The second returned direction will be as close as possible to the second\r\n    given vector while being perpendicular to the first returned direction\r\n  - The third returned direction will be as close as possible to the third given\r\n    vector while being perpendicular to the first and second returned directions\r\n\r\nIf any of the given vectors are zero, any two of them are parallel, or the three\r\nare coplanar, returns `Nothing`.\r\n\r\n    Direction3d.orthonormalize\r\n        (Vector3d.fromComponents ( 3, 3, 0 ))\r\n        (Vector3d.fromComponents ( 0, 2, 0 ))\r\n        (Vector3d.fromComponents ( 1, 2, 3 ))\r\n    --> Just\r\n    -->     ( Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 45)\r\n    -->         (degrees 0)\r\n    -->     , Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 135)\r\n    -->         (degrees 0)\r\n    -->     , Direction3d.positiveZ\r\n    -->     )\r\n\r\n    -- Three vectors in the XY plane:\r\n    Direction3d.orthonormalize\r\n        (Vector3d.fromComponents ( 2, 0, 0 ))\r\n        (Vector3d.fromComponents ( 3, 1, 0 ))\r\n        (Vector3d.fromComponents ( 4, 2, 0 ))\r\n    --> Nothing\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Vector3d.Vector3d units coordinates -> Vector3d.Vector3d units coordinates -> Maybe.Maybe ( Direction3d.Direction3d coordinates, Direction3d.Direction3d coordinates, Direction3d.Direction3d coordinates )"},{"name":"perpendicularBasis","comment":" Construct a pair of directions that are perpendicular to each other and both\r\nperpendicular to the given direction.\r\n\r\nThe given direction and the two returned directions will form a\r\n[right-handed](https://en.wikipedia.org/wiki/Cartesian_coordinate_system#Orientation_and_handedness)\r\nsystem (that is, a right-handed `Frame3d` could be constructed by using the\r\ngiven direction as the X direction and the two returned directions as the Y and\r\nZ directions, or the given direction as the Z direction and the two returned\r\ndirections as the X and Y directions).\r\n\r\n    Direction3d.perpendicularBasis Direction3d.x\r\n    --> ( Direction3d.negativeZ\r\n    --> , Direction3d.positiveY\r\n    --> )\r\n\r\n    Direction3d.perpendicularBasis Direction3d.y\r\n    --> ( Direction3d.positiveZ\r\n    --> , Direction3d.positiveX\r\n    --> )\r\n\r\n","type":"Direction3d.Direction3d coordinates -> ( Direction3d.Direction3d coordinates, Direction3d.Direction3d coordinates )"},{"name":"perpendicularTo","comment":" Construct an arbitrary direction perpendicular to the given direction. The\r\nexact resulting direction is not specified, but it is guaranteed to be\r\nperpendicular to the given direction.\r\n\r\n    Direction3d.perpendicularTo Direction3d.x\r\n    --> Direction3d.negativeZ\r\n\r\n    Direction3d.perpendicularTo Direction3d.y\r\n    --> Direction3d.positiveZ\r\n\r\n    direction =\r\n        Direction3d.fromAzimuthAndElevation\r\n            (degrees 0)\r\n            (degrees 60)\r\n\r\n    Direction3d.perpendicularTo direction\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 0)\r\n    -->     (degrees -30)\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Direction3d.Direction3d coordinates"},{"name":"placeIn","comment":" Take a direction defined in local coordinates relative to a given reference\r\nframe, and return that direction expressed in global coordinates.\r\n\r\n    Direction3d.placeIn rotatedFrame Direction3d.x\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 30)\r\n    -->     (degrees 0)\r\n\r\n    Direction3d.placeIn rotatedFrame Direction3d.y\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 120)\r\n    -->     (degrees 0)\r\n\r\n    Direction3d.placeIn rotatedFrame Direction3d.z\r\n    --> Direction3d.z\r\n\r\n","type":"Geometry.Types.Frame3d units globalCoordinates localCoordinates -> Direction3d.Direction3d localCoordinates -> Direction3d.Direction3d globalCoordinates"},{"name":"positiveX","comment":" The positive X direction.\r\n\r\n    Direction3d.components Direction3d.positiveX\r\n    --> ( 1, 0, 0 )\r\n\r\n","type":"Direction3d.Direction3d coordinates"},{"name":"positiveY","comment":" The positive Y direction.\r\n\r\n    Direction3d.components Direction3d.positiveY\r\n    --> ( 0, 1, 0 )\r\n\r\n","type":"Direction3d.Direction3d coordinates"},{"name":"positiveZ","comment":" The positive Z direction.\r\n\r\n    Direction3d.components Direction3d.positiveZ\r\n    --> ( 0, 0, 1 )\r\n\r\n","type":"Direction3d.Direction3d coordinates"},{"name":"projectInto","comment":" Project a direction into a given sketch plane. Conceptually, this finds the\r\n[orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof the direction onto the plane, re-normalizes it to have unit length, and then\r\nexpresses the projected direction in 2D sketch coordinates.\r\n\r\nThis is only possible if the direction is not perpendicular to the sketch\r\nplane; if it is perpendicular, `Nothing` is returned.\r\n\r\n    direction =\r\n        Direction3d.fromAzimuthAndElevation\r\n            (degrees -60)\r\n            (degrees 0)\r\n\r\n    Direction3d.projectInto SketchPlane3d.xy direction\r\n    --> Just (Direction2d.fromAngle (degrees -60))\r\n\r\n    Direction3d.projectInto SketchPlane3d.xz direction\r\n    --> Just Direction2d.x\r\n\r\n    Direction3d.projectInto SketchPlane3d.yz direction\r\n    --> Just Direction2d.negativeX\r\n\r\n    Direction3d.projectInto SketchPlane3d.xy Direction3d.z\r\n    --> Nothing\r\n\r\n","type":"Geometry.Types.SketchPlane3d units coordinates3d coordinates2d -> Direction3d.Direction3d coordinates3d -> Maybe.Maybe (Direction2d.Direction2d coordinates2d)"},{"name":"projectOnto","comment":" Find the [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof a direction onto a plane (renormalized to have unit length). If the given\r\ndirection is exactly perpendicular to the given plane, returns `Nothing`.\r\n\r\n    direction =\r\n        Direction3d.fromAzimuthAndElevation\r\n            (degrees -60)\r\n            (degrees 0)\r\n\r\n    Direction3d.projectOnto Plane3d.xy direction\r\n    --> Just direction\r\n\r\n    Direction3d.projectOnto Plane3d.xz direction\r\n    --> Just Direction3d.x\r\n\r\n    Direction3d.projectOnto Plane3d.yz direction\r\n    --> Just Direction3d.negativeY\r\n\r\n    Direction3d.projectOnto Plane3d.xy Direction3d.z\r\n    --> Nothing\r\n\r\n","type":"Geometry.Types.Plane3d units coordinates -> Direction3d.Direction3d coordinates -> Maybe.Maybe (Direction3d.Direction3d coordinates)"},{"name":"relativeTo","comment":" Take a direction defined in global coordinates, and return it expressed in\r\nlocal coordinates relative to a given reference frame.\r\n\r\n    Direction3d.relativeTo rotatedFrame Direction3d.x\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees -30)\r\n    -->     (degrees 0)\r\n\r\n    Direction3d.relativeTo rotatedFrame Direction3d.y\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 60)\r\n    -->     (degrees 0)\r\n\r\n    Direction3d.relativeTo rotatedFrame Direction3d.z\r\n    --> Direction3d.z\r\n\r\n","type":"Geometry.Types.Frame3d units globalCoordinates localCoordinates -> Direction3d.Direction3d globalCoordinates -> Direction3d.Direction3d localCoordinates"},{"name":"reverse","comment":" Reverse a direction.\r\n\r\n    Direction3d.reverse Direction3d.y\r\n    --> Direction3d.negativeY\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Direction3d.Direction3d coordinates"},{"name":"rotateAround","comment":" Rotate a direction around an axis by a given angle.\r\n\r\n    Direction3d.y\r\n        |> Direction3d.rotateAround Axis3d.x (degrees 90)\r\n    --> Direction3d.z\r\n\r\nNote that only the direction of the axis affects the result, not the position of\r\nits origin point, since directions are position-independent:\r\n\r\n    offsetAxis =\r\n        Axis3d.withDirection Direction3d.z\r\n            (Point3d.fromCoordinates ( 100, 200, 300 ))\r\n\r\n    Direction3d.x\r\n        |> Direction3d.rotateAround offsetAxis (degrees 90)\r\n    --> Direction3d.y\r\n\r\n","type":"Geometry.Types.Axis3d units coordinates -> Angle.Angle -> Direction3d.Direction3d coordinates -> Direction3d.Direction3d coordinates"},{"name":"toVector","comment":" Convert a direction to a unit vector.\r\n\r\n    Direction3d.toVector Direction3d.y\r\n    --> Vector3d.fromComponents ( 0, 1, 0 )\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Vector3d.Vector3d Quantity.Unitless coordinates"},{"name":"unsafeFromComponents","comment":" Construct a direction directly from its X, Y and Z components. Note that\r\n**you must ensure that the sum of the squares of the given components is exactly\r\none**:\r\n\r\n    Direction3d.unsafeFromComponents ( 1, 0, 0 )\r\n\r\n    Direction3d.unsafeFromComponents ( 0, -1, 0 )\r\n\r\n    Direction3d.unsafeFromComponents ( 0.6, 0, 0.8 )\r\n\r\nare all valid but\r\n\r\n    Direction3d.unsafeFromComponents ( 2, 0, 0 )\r\n\r\n    Direction3d.unsafeFromComponents ( 1, 1, 1 )\r\n\r\nare not. Instead of using `Direction3d.unsafeFromComponents`, it may be easier to use\r\nconstructors like `Direction3d.on` or `Direction3d.fromAzimuthAndElevation`\r\n(which will always result in a valid direction), or start with existing\r\ndirections and transform them as necessary.\r\n\r\n","type":"( Basics.Float, Basics.Float, Basics.Float ) -> Direction3d.Direction3d coordinates"},{"name":"unsafeFromComponentsIn","comment":" Construct a direction directly from its local X, Y and Z components within a\r\ngiven frame. As with `unsafeFromComponents`, you must ensure that the sum of the squares of\r\nthe given components is exactly one.\r\n","type":"Geometry.Types.Frame3d units globalCoordinates localCoordinates -> ( Basics.Float, Basics.Float, Basics.Float ) -> Direction3d.Direction3d globalCoordinates"},{"name":"x","comment":" Synonym for `Direction3d.positiveX`.\r\n","type":"Direction3d.Direction3d coordinates"},{"name":"xComponent","comment":" Get the X component of a direction.\r\n\r\n    Direction3d.xComponent Direction3d.x\r\n    --> 1\r\n\r\n    Direction3d.xComponent Direction3d.y\r\n    --> 0\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Basics.Float"},{"name":"y","comment":" Synonym for `Direction3d.positiveY`.\r\n","type":"Direction3d.Direction3d coordinates"},{"name":"yComponent","comment":" Get the Y component of a direction.\r\n\r\n    Direction3d.yComponent Direction3d.y\r\n    --> 1\r\n\r\n    Direction3d.yComponent Direction3d.z\r\n    --> 0\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Basics.Float"},{"name":"z","comment":" Synonym for `Direction3d.positiveZ`.\r\n","type":"Direction3d.Direction3d coordinates"},{"name":"zComponent","comment":" Get the Z component of a direction.\r\n\r\n    Direction3d.zComponent Direction3d.z\r\n    --> 1\r\n\r\n    Direction3d.zComponent Direction3d.x\r\n    --> 0\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Basics.Float"}],"binops":[]},{"name":"Ellipse2d","comment":" An [ellipse](https://en.wikipedia.org/wiki/Ellipse) is defined by a center\r\npoint, X and Y radius, and X and Y axes (which will always be perpendicular to\r\neach other). Ellipses are symmetric about their X and Y axes. This module\r\nincludes functionality for\r\n\r\n  - Constructing ellipses\r\n  - Scaling, rotating and translating ellipses\r\n  - Converting ellipses between different coordinate systems\r\n\r\n@docs Ellipse2d, EllipseCoordinates\r\n\r\n\r\n# Constructors\r\n\r\n@docs with\r\n\r\n\r\n# Properties\r\n\r\n@docs centerPoint, xAxis, yAxis, xDirection, yDirection, axes, xRadius, yRadius, area\r\n\r\n\r\n# Transformations\r\n\r\n@docs scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n","unions":[],"aliases":[{"name":"Ellipse2d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Ellipse2d units coordinates"},{"name":"EllipseCoordinates","comment":" The coordinate system associated with the central axes of an ellipse.\r\n","args":[],"type":"Geometry.Types.EllipseCoordinates"}],"values":[{"name":"area","comment":" Get the area of an ellipse.\r\n\r\n    Ellipse2d.area exampleEllipse\r\n    --> 47.1239\r\n\r\n","type":"Ellipse2d.Ellipse2d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Squared units)"},{"name":"axes","comment":" Get the X and Y axes of an ellipse as a `Frame2d`.\r\n\r\n    Ellipse2d.axes exampleEllipse\r\n    --> Frame2d.withXDirection\r\n    -->     (Direction2d.fromAngle (degrees 30))\r\n    -->     (Point2d.fromCoordinates ( 10, 10 ))\r\n\r\n","type":"Ellipse2d.Ellipse2d units coordinates -> Frame2d.Frame2d units coordinates Ellipse2d.EllipseCoordinates"},{"name":"centerPoint","comment":" Get the center point of an ellipse.\r\n\r\n    Ellipse2d.centerPoint exampleEllipse\r\n    --> Point2d.fromCoordinates ( 10, 10 )\r\n\r\n","type":"Ellipse2d.Ellipse2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"mirrorAcross","comment":" Mirror an ellipse across a given axis.\r\n\r\n    mirroredEllipse =\r\n        Ellipse2d.mirrorAcross Axis2d.x exampleEllipse\r\n\r\n    Ellipse2d.centerPoint mirroredEllipse\r\n    --> Point2d.fromCoordinates ( 10, -10 )\r\n\r\n    Ellipse2d.xDirection mirroredEllipse\r\n    --> Direction2d.fromAngle (degrees -30)\r\n\r\n    Ellipse2d.yDirection mirroredEllipse\r\n    --> Direction2d.fromAngle (degrees -120)\r\n\r\nNote that if the axes of the original ellipse form a [right-handed](https://en.wikipedia.org/wiki/Cartesian_coordinate_system#Orientation_and_handedness)\r\nframe, then the axes of the mirrored ellipse will form a left-handed frame (and\r\nvice versa).\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> Ellipse2d.Ellipse2d units coordinates -> Ellipse2d.Ellipse2d units coordinates"},{"name":"placeIn","comment":" Take an ellipse considered to be defined in local coordinates relative to a\r\ngiven reference frame, and return that circle expressed in global coordinates.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates (15, 5))\r\n\r\n    Ellipse2d.placeIn localFrame exampleEllipse\r\n    --> Ellipse2d.with\r\n    -->     { centerPoint =\r\n    -->         Point2d.fromCoordinates ( 25, 15 )\r\n    -->     , xDirection =\r\n    -->         Direction2d.fromAngle (degrees 30)\r\n    -->     , xRadius = 5\r\n    -->     , yRadius = 3\r\n    -->     }\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> Ellipse2d.Ellipse2d units localCoordinates -> Ellipse2d.Ellipse2d units globalCoordinates"},{"name":"relativeTo","comment":" Take an ellipse defined in global coordinates, and return it expressed in\r\nlocal coordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates (15, 5))\r\n\r\n    Ellipse2d.relativeTo localFrame exampleEllipse\r\n    --> Ellipse2d.with\r\n    -->     { centerPoint =\r\n    -->         Point2d.fromCoordinates ( -5, 5 )\r\n    -->     , xDirection =\r\n    -->         Direction2d.fromAngle (degrees 30)\r\n    -->     , xRadius = 5\r\n    -->     , yRadius = 3\r\n    -->     }\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> Ellipse2d.Ellipse2d units globalCoordinates -> Ellipse2d.Ellipse2d units localCoordinates"},{"name":"rotateAround","comment":" Rotate an ellipse around a given point by a given angle (in radians).\r\n\r\n    exampleEllipse\r\n        |> Ellipse2d.rotateAround Point2d.origin\r\n            (degrees 45)\r\n    --> Ellipse2d.with\r\n    -->     { centerPoint =\r\n    -->         Point2d.fromCoordinates ( 0, 14.142 )\r\n    -->     , xDirection =\r\n    -->         Direction2d.fromAngle (degrees 75)\r\n    -->     , xRadius = 5\r\n    -->     , yRadius = 3\r\n    -->     }\r\n\r\n","type":"Point2d.Point2d units coordinates -> Angle.Angle -> Ellipse2d.Ellipse2d units coordinates -> Ellipse2d.Ellipse2d units coordinates"},{"name":"scaleAbout","comment":" Scale an ellipse about a given point by a given scale.\r\n\r\n    exampleEllipse\r\n        |> Ellipse2d.scaleAbout Point2d.origin 3\r\n    --> Ellipse2d.with\r\n    -->     { centerPoint =\r\n    -->         Point2d.fromCoordinates ( 30, 30 )\r\n    -->     , xDirection =\r\n    -->         Direction2d.fromAngle (degrees 30)\r\n    -->     , xRadius = 15\r\n    -->     , yRadius = 9\r\n    -->     }\r\n\r\n","type":"Point2d.Point2d units coordinates -> Basics.Float -> Ellipse2d.Ellipse2d units coordinates -> Ellipse2d.Ellipse2d units coordinates"},{"name":"translateBy","comment":" Translate an ellipse by a given displacement.\r\n\r\n    exampleEllipse\r\n        |> Ellipse2d.translateBy\r\n            (Vector2d.fromComponents ( 5, 10 ))\r\n    --> Ellipse2d.with\r\n    -->     { centerPoint =\r\n    -->         Point2d.fromCoordinates ( 15, 20 )\r\n    -->     , xDirection =\r\n    -->         Direction2d.fromAngle (degrees 30)\r\n    -->     , xRadius = 5\r\n    -->     , yRadius = 3\r\n    -->     }\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Ellipse2d.Ellipse2d units coordinates -> Ellipse2d.Ellipse2d units coordinates"},{"name":"translateIn","comment":" Translate an ellipse in a given direction by a given distance;\r\n\r\n    Ellipse2d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    Ellipse2d.translateBy\r\n        (Vector2d.withLength distance direction)\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Quantity.Quantity Basics.Float units -> Ellipse2d.Ellipse2d units coordinates -> Ellipse2d.Ellipse2d units coordinates"},{"name":"with","comment":" Construct an ellipse from its center point, X direction, and X and Y radii.\r\nIf you pass a negative radius, the absolute value will be used.\r\n\r\n    exampleEllipse =\r\n        Ellipse2d.with\r\n            { centerPoint =\r\n                Point2d.fromCoordinates ( 10, 10 )\r\n            , xDirection =\r\n                Direction2d.fromAngle (degrees 30)\r\n            , xRadius = 5\r\n            , yRadius = 3\r\n            }\r\n\r\n","type":"{ centerPoint : Point2d.Point2d units coordinates, xDirection : Direction2d.Direction2d coordinates, xRadius : Quantity.Quantity Basics.Float units, yRadius : Quantity.Quantity Basics.Float units } -> Ellipse2d.Ellipse2d units coordinates"},{"name":"xAxis","comment":" Get the X axis of an ellipse.\r\n\r\n    Ellipse2d.xAxis exampleEllipse\r\n    --> Axis2d.through\r\n    -->     (Point2d.fromCoordinates ( 10, 10 ))\r\n    -->     (Direction2d.fromAngle (degrees 30))\r\n\r\n","type":"Ellipse2d.Ellipse2d units coordinates -> Axis2d.Axis2d units coordinates"},{"name":"xDirection","comment":" Get the direction of the ellipse's X axis.\r\n\r\n    Ellipse2d.xDirection exampleEllipse\r\n    --> Direction2d.fromAngle (degrees 30)\r\n\r\n","type":"Ellipse2d.Ellipse2d units coordinates -> Direction2d.Direction2d coordinates"},{"name":"xRadius","comment":" Get the radius of an ellipse along its X axis. This may be either the\r\nminimum or maximum radius.\r\n\r\n    Ellipse2d.xRadius exampleEllipse\r\n    --> 5\r\n\r\n","type":"Ellipse2d.Ellipse2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"yAxis","comment":" Get the Y axis of an ellipse.\r\n\r\n    Ellipse2d.yAxis exampleEllipse\r\n    --> Axis2d.through\r\n    -->     (Point2d.fromCoordinates ( 10, 10 ))\r\n    -->     (Direction2d.fromAngle (degrees 120))\r\n\r\n","type":"Ellipse2d.Ellipse2d units coordinates -> Axis2d.Axis2d units coordinates"},{"name":"yDirection","comment":" Get the direction of an ellipse's Y axis.\r\n\r\n    Ellipse2d.yDirection exampleEllipse\r\n    --> Direction2d.fromAngle (degrees 120)\r\n\r\n","type":"Ellipse2d.Ellipse2d units coordinates -> Direction2d.Direction2d coordinates"},{"name":"yRadius","comment":" Get the radius of an ellipse along its Y axis. This may be either the\r\nminimum or maximum radius.\r\n\r\n    Ellipse2d.yRadius exampleEllipse\r\n    --> 3\r\n\r\n","type":"Ellipse2d.Ellipse2d units coordinates -> Quantity.Quantity Basics.Float units"}],"binops":[]},{"name":"EllipticalArc2d","comment":" An `EllipticalArc2d` is a section of an `Ellipse2d` with a start and end\r\npoint. This module includes functionality for\r\n\r\n  - Constructing an elliptical arc from its center or end points\r\n  - Scaling, rotating, translating and mirroring elliptical arcs\r\n  - Evaluating points and derivative vectors along elliptical arcs\r\n  - Forming arc length parameterizations of elliptical arcs\r\n\r\nThe `startAngle` and `sweptAngle` values referred to below are not actually\r\nproper angles but instead refer to values of the [ellipse parameter](https://en.wikipedia.org/wiki/Ellipse#Parametric_representation).\r\nHowever, in simple cases you don't need to worry about the difference - if\r\n`startAngle` and `sweptAngle` are both multiples of 90 degrees, then you can\r\ntreat them as actual angles and everything will behave as you expect.\r\n\r\n@docs EllipticalArc2d\r\n\r\n\r\n# Constructors\r\n\r\n@docs with, fromEndpoints\r\n\r\n\r\n# Properties\r\n\r\n@docs startAngle, sweptAngle, startPoint, endPoint\r\n\r\nAll remaining properties of elliptical arcs are actually just properties of the\r\nunderlying ellipse; check out the <Ellipse2d> module for details.\r\n\r\n@docs centerPoint, axes, xAxis, yAxis, xDirection, yDirection, xRadius, yRadius\r\n\r\n\r\n# Evaluation\r\n\r\n@docs pointOn, pointsAt\r\n@docs Nondegenerate, nondegenerate, fromNondegenerate\r\n@docs tangentDirection, tangentDirectionsAt, sample, samplesAt\r\n\r\n\r\n# Transformations\r\n\r\n@docs reverse, scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n\r\n# Arc length parameterization\r\n\r\n@docs ArcLengthParameterized, arcLengthParameterized, arcLength, pointAlong, tangentDirectionAlong, sampleAlong\r\n\r\n\r\n## Low level\r\n\r\nAn `ArcLengthParameterized` value is a combination of an\r\n[`ArcLengthParameterization`](Geometry-ArcLengthParameterization) and an\r\nunderlying `EllipticalArc2d`. If you need to do something fancy, you can extract\r\nthese two values separately.\r\n\r\n@docs arcLengthParameterization, fromArcLengthParameterized\r\n\r\n\r\n# Differentiation\r\n\r\nYou are unlikely to need to use these functions directly, but they are useful if\r\nyou are writing low-level geometric algorithms.\r\n\r\n@docs firstDerivative, firstDerivativesAt, maxSecondDerivativeMagnitude\r\n\r\n","unions":[{"name":"ArcLengthParameterized","comment":" An elliptical arc that has been parameterized by arc length.\r\n","args":["units","coordinates"],"cases":[]},{"name":"Nondegenerate","comment":" If a curve has zero length (consists of just a single point), then we say\r\nthat it is 'degenerate'. Some operations such as computing tangent directions\r\nare not defined on degenerate curves.\r\n\r\nA `Nondegenerate` value represents an arc that is definitely not degenerate. It\r\nis used as input to functions such as `EllipticalArc2d.tangentDirection` and can\r\nbe constructed using `EllipticalArc2d.nondegenerate`.\r\n\r\n","args":["units","coordinates"],"cases":[]}],"aliases":[{"name":"EllipticalArc2d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.EllipticalArc2d units coordinates"}],"values":[{"name":"arcLength","comment":" Find the total arc length of an elliptical arc. This will be accurate to\r\nwithin the tolerance given when calling `arcLengthParameterized`.\r\n\r\n    arcLength : Float\r\n    arcLength =\r\n        EllipticalArc2d.arcLength parameterizedArc\r\n\r\n    arcLength\r\n    --> 2.4221\r\n\r\n","type":"EllipticalArc2d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"arcLengthParameterization","comment":" ","type":"EllipticalArc2d.ArcLengthParameterized units coordinates -> Curve.ArcLengthParameterization.ArcLengthParameterization units"},{"name":"arcLengthParameterized","comment":" Build an arc length parameterization of the given elliptical arc, with a\r\ngiven accuracy. Generally speaking, all operations on the resulting\r\n`ArcLengthParameterized` value will be accurate to within the specified maximum\r\nerror.\r\n\r\n    parameterizedArc =\r\n        exampleArc\r\n            |> EllipticalArc2d.arcLengthParameterized\r\n                { maxError = 1.0e-4 }\r\n\r\n","type":"{ maxError : Quantity.Quantity Basics.Float units } -> EllipticalArc2d.EllipticalArc2d units coordinates -> EllipticalArc2d.ArcLengthParameterized units coordinates"},{"name":"axes","comment":" ","type":"EllipticalArc2d.EllipticalArc2d units coordinates -> Frame2d.Frame2d units coordinates Ellipse2d.EllipseCoordinates"},{"name":"centerPoint","comment":" ","type":"EllipticalArc2d.EllipticalArc2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"endPoint","comment":" Get the end point of an elliptical arc.\r\n\r\n    EllipticalArc2d.endPoint exampleArc\r\n    --> Point2d.fromCoordinates ( 0, 1 )\r\n\r\n","type":"EllipticalArc2d.EllipticalArc2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"firstDerivative","comment":" Get the first derivative of an elliptical arc at a given parameter value:\r\n\r\n    EllipticalArc2d.firstDerivative exampleArc\r\n        ParameterValue.zero\r\n    --> Vector2d.fromComponents ( 0, 1.5708 )\r\n\r\n    EllipticalArc2d.firstDerivative exampleArc\r\n        ParameterValue.half\r\n    --> Vector2d.fromComponents ( -2.2214, 1.1107 )\r\n\r\n    EllipticalArc2d.firstDerivative exampleArc\r\n        ParameterValue.one\r\n    --> Vector2d.fromComponents ( -3.1416, 0 )\r\n\r\n","type":"EllipticalArc2d.EllipticalArc2d units coordinates -> Curve.ParameterValue.ParameterValue -> Vector2d.Vector2d units coordinates"},{"name":"firstDerivativesAt","comment":" Evaluate the first derivative of an elliptical arc at a given set of\r\nparameter values:\r\n\r\n    exampleArc\r\n        |> EllipticalArc2d.firstDerivativesAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Vector2d.fromComponents ( 0, 1.5708 )\r\n    --> , Vector2d.fromComponents ( -2.2214, 1.1107 )\r\n    --> , Vector2d.fromComponents ( -3.1416, 0 )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> EllipticalArc2d.EllipticalArc2d units coordinates -> List.List (Vector2d.Vector2d units coordinates)"},{"name":"fromArcLengthParameterized","comment":" ","type":"EllipticalArc2d.ArcLengthParameterized units coordinates -> EllipticalArc2d.EllipticalArc2d units coordinates"},{"name":"fromEndpoints","comment":" Attempt to construct an elliptical arc from its endpoints, X direction, and\r\nX and Y radii. For any given valid set of these inputs, there are four possible\r\nsolutions, so you also need to specify which of the four solutions you want -\r\nwhether the swept angle of the arc should be less than or greater than 180\r\ndegrees, and whether the swept angle should be positive (counterclockwise) or\r\nnegative (clockwise).\r\n\r\nThe example below is interactive; try dragging either endpoint or the tip of the\r\nX direction (or the center point to move the whole arc), clicking on the X or Y\r\nradial lines and then scrolling to changet that radius, or clicking/tapping on\r\nthe various dashed arcs to switch what kind of swept angle to use.\r\n\r\n<iframe src=\"https://ianmackenzie.github.io/elm-geometry/1.0.0/EllipticalArc2d/fromEndpoints.html\" style=\"width: 500px; height: 400px\" scrolling=no frameborder=0>\r\n`https://ianmackenzie.github.io/elm-geometry/1.0.0/EllipticalArc2d/fromEndpoints.html`\r\n</iframe>\r\n\r\nThis function will return `Nothing` if no solution can found. Typically this\r\nmeans that the two endpoints are too far apart, but could also mean that one of\r\nthe specified radii was negative or zero, or the two given points were\r\ncoincident.\r\n\r\nThe behavior of this function is very close to [the SVG spec](https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes),\r\nbut when 'out of range' parameters are given this function will simply return\r\n`Nothing` instead of attempting to degrade gracefully (for example, by\r\nincreasing X and Y radius slightly if the given endpoints are slightly too far\r\napart). Note that this means this function is dangerous to use for 180 degree\r\narcs, since then slight numerical roundoff can mean the difference between a\r\nsolution being found and not - for 180 degree arcs it is safer to use\r\n`EllipticalArc2d.with` instead.\r\n\r\n","type":"{ startPoint : Point2d.Point2d units coordinates, endPoint : Point2d.Point2d units coordinates, xRadius : Quantity.Quantity Basics.Float units, yRadius : Quantity.Quantity Basics.Float units, xDirection : Direction2d.Direction2d coordinates, sweptAngle : Arc.SweptAngle.SweptAngle } -> Maybe.Maybe (EllipticalArc2d.EllipticalArc2d units coordinates)"},{"name":"fromNondegenerate","comment":" Convert a nondegenerate elliptical arc back to a general `EllipticalArc2d`.\r\n\r\n    EllipticalArc2d.fromNondegenerate\r\n        nondegenerateExampleArc\r\n    --> exampleArc\r\n\r\n","type":"EllipticalArc2d.Nondegenerate units coordinates -> EllipticalArc2d.EllipticalArc2d units coordinates"},{"name":"maxSecondDerivativeMagnitude","comment":" Find a conservative upper bound on the magnitude of the second derivative of\r\nan elliptical arc. This can be useful when determining error bounds for various\r\nkinds of linear approximations.\r\n\r\n    exampleArc\r\n        |> EllipticalArc2d.maxSecondDerivativeMagnitude\r\n    --> 4.935\r\n\r\n","type":"EllipticalArc2d.EllipticalArc2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"mirrorAcross","comment":" Mirror an elliptical arc across a given axis.\r\n\r\n    mirroredArc =\r\n        exampleArc\r\n            |> EllipticalArc2d.mirrorAcross Axis2d.y\r\n\r\n    EllipticalArc2d.startPoint mirroredArc\r\n    --> Point2d.fromCoordinates ( -2, 0 )\r\n\r\n    EllipticalArc2d.endPoint mirroredArc\r\n    --> Point2d.fromCoordinates ( 0, 1 )\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> EllipticalArc2d.EllipticalArc2d units coordinates -> EllipticalArc2d.EllipticalArc2d units coordinates"},{"name":"nondegenerate","comment":" Attempt to construct a nondegenerate elliptical arc from a general\r\n`EllipticalArc2d`. If the arc is in fact degenerate (consists of a single\r\npoint), returns an `Err` with that point.\r\n\r\n    EllipticalArc2d.nondegenerate exampleArc\r\n    --> Ok nondegenerateExampleArc\r\n\r\n","type":"EllipticalArc2d.EllipticalArc2d units coordinates -> Result.Result (Point2d.Point2d units coordinates) (EllipticalArc2d.Nondegenerate units coordinates)"},{"name":"placeIn","comment":" Take an elliptical arc considered to be defined in local coordinates\r\nrelative to a given reference frame, and return that arc expressed in global\r\ncoordinates.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    EllipticalArc2d.relativeTo localFrame exampleArc\r\n    --> EllipticalArc2d.with\r\n    -->     { centerPoint =\r\n    -->         Point2d.fromCoordinates ( 1, 2 )\r\n    -->     , xDirection = Direction2d.x\r\n    -->     , xRadius = 2\r\n    -->     , yRadius = 1\r\n    -->     , startAngle = 0\r\n    -->     , sweptAngle = degrees 90\r\n    -->     }\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> EllipticalArc2d.EllipticalArc2d units localCoordinates -> EllipticalArc2d.EllipticalArc2d units globalCoordinates"},{"name":"pointAlong","comment":" Try to get the point along an elliptical arc at a given arc length. For\r\nexample, to get the true midpoint of `exampleArc`:\r\n\r\n    EllipticalArc2d.pointAlong parameterizedArc\r\n        (arcLength / 2)\r\n    --> Just (Point2d.fromCoordinates ( 1.1889, 0.8041 ))\r\n\r\nNote that this is not the same as evaulating at a parameter value of 0.5:\r\n\r\n    EllipticalArc2d.pointOn exampleArc\r\n        ParameterValue.half\r\n    --> Point2d.fromCoordinates ( 1.4142, 0.7071 )\r\n\r\nIf the given arc length is less than zero or greater than the arc length of the\r\narc, returns `Nothing`.\r\n\r\n","type":"EllipticalArc2d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units -> Maybe.Maybe (Point2d.Point2d units coordinates)"},{"name":"pointOn","comment":" Get the point along an elliptical arc at a given parameter value:\r\n\r\n    EllipticalArc2d.pointOn exampleArc ParameterValue.zero\r\n    --> Point2d.fromCoordinates ( 2, 0 )\r\n\r\n    EllipticalArc2d.pointOn exampleArc ParameterValue.half\r\n    --> Point2d.fromCoordinates ( 1.4142, 0.7071 )\r\n\r\n    EllipticalArc2d.pointOn exampleArc ParameterValue.one\r\n    --> Point2d.fromCoordinates ( 0, 1 )\r\n\r\n","type":"EllipticalArc2d.EllipticalArc2d units coordinates -> Curve.ParameterValue.ParameterValue -> Point2d.Point2d units coordinates"},{"name":"pointsAt","comment":" Get points along an elliptical arc at a given set of parameter values:\r\n\r\n    exampleArc\r\n        |> EllipticalArc2d.pointsAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Point2d.fromCoordinates ( 2, 0 )\r\n    --> , Point2d.fromCoordinates ( 1.4142, 0.7071 )\r\n    --> , Point2d.fromCoordinates ( 0, 1 )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> EllipticalArc2d.EllipticalArc2d units coordinates -> List.List (Point2d.Point2d units coordinates)"},{"name":"relativeTo","comment":" Take an elliptical arc defined in global coordinates, and return it expressed in\r\nlocal coordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    EllipticalArc2d.relativeTo localFrame exampleArc\r\n    --> EllipticalArc2d.with\r\n    -->     { centerPoint =\r\n    -->         Point2d.fromCoordinates ( -1, -2 )\r\n    -->     , xDirection = Direction2d.x\r\n    -->     , xRadius = 2\r\n    -->     , yRadius = 1\r\n    -->     , startAngle = 0\r\n    -->     , sweptAngle = degrees 90\r\n    -->     }\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> EllipticalArc2d.EllipticalArc2d units globalCoordinates -> EllipticalArc2d.EllipticalArc2d units localCoordinates"},{"name":"reverse","comment":" Reverse the direction of an elliptical arc, so that the start point becomes\r\nthe end point and vice versa. Does not change the shape of the arc or any\r\nproperties of the underlying ellipse.\r\n\r\n    EllipticalArc2d.reverse exampleArc\r\n    --> EllipticalArc2d.with\r\n    -->     { centerPoint = Point2d.origin\r\n    -->     , xDirection = Direction2d.x\r\n    -->     , xRadius = 2\r\n    -->     , yRadius = 1\r\n    -->     , startAngle = degrees 90\r\n    -->     , sweptAngle = degrees -90\r\n    -->     }\r\n\r\n","type":"EllipticalArc2d.EllipticalArc2d units coordinates -> EllipticalArc2d.EllipticalArc2d units coordinates"},{"name":"rotateAround","comment":" Rotate an elliptical arc around a given point by a given angle (in radians).\r\n\r\n    exampleArc\r\n        |> EllipticalArc2d.rotateAround Point2d.origin\r\n            (degrees 180)\r\n    --> EllipticalArc2d.with\r\n    -->     { centerPoint = Point2d.origin\r\n    -->     , xDirection = Direction2d.negativeX\r\n    -->     , xRadius = 2\r\n    -->     , yRadius = 1\r\n    -->     , startAngle = 0\r\n    -->     , sweptAngle = degrees 90\r\n    -->     }\r\n\r\n","type":"Point2d.Point2d units coordinates -> Angle.Angle -> EllipticalArc2d.EllipticalArc2d units coordinates -> EllipticalArc2d.EllipticalArc2d units coordinates"},{"name":"sample","comment":" Get both the point and tangent direction of a nondegenerate elliptical arc\r\nat a given parameter value:\r\n\r\n    EllipticalArc2d.sample nondegenerateExampleArc\r\n        ParameterValue.zero\r\n    --> ( Point2d.fromCoordinates ( 2, 0 )\r\n    --> , Direction2d.fromAngle (degrees 90)\r\n    --> )\r\n\r\n    EllipticalArc2d.sample nondegenerateExampleArc\r\n        ParameterValue.half\r\n    --> ( Point2d.fromCoordinates ( 1.4142, 0.7071 )\r\n    --> , Direction2d.fromAngle (degrees 153.4)\r\n    --> )\r\n\r\n    EllipticalArc2d.sample nondegenerateExampleArc\r\n        ParameterValue.one\r\n    --> ( Point2d.fromCoordinates ( 0, 1 )\r\n    --> , Direction2d.fromAngle (degrees 180)\r\n    --> )\r\n\r\n","type":"EllipticalArc2d.Nondegenerate units coordinates -> Curve.ParameterValue.ParameterValue -> ( Point2d.Point2d units coordinates, Direction2d.Direction2d coordinates )"},{"name":"sampleAlong","comment":" Try to get the point and tangent direction along an elliptical arc at a\r\ngiven arc length. To get the point and tangent direction at the midpoint of\r\n`exampleArc`:\r\n\r\n    EllipticalArc2d.sampleAlong parameterizedArc\r\n        (arcLength / 2)\r\n    --> Just\r\n    -->     ( Point2d.fromCoordinates ( 1.1889, 0.8041 )\r\n    -->     , Direction2d.fromAngle (degrees 159.7)\r\n    -->     )\r\n\r\nIf the given arc length is less than zero or greater than the arc length of the\r\nspline (or if the spline is degenerate), returns `Nothing`.\r\n\r\n","type":"EllipticalArc2d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units -> Maybe.Maybe ( Point2d.Point2d units coordinates, Direction2d.Direction2d coordinates )"},{"name":"samplesAt","comment":" Get points and tangent directions of a nondegenerate arc at a given set of\r\nparameter values:\r\n\r\n    nondegenerateExampleArc\r\n        |> EllipticalArc2d.samplesAt\r\n            (ParameterValue.steps 2)\r\n    --> [ ( Point2d.fromCoordinates ( 2, 0 )\r\n    -->   , Direction2d.fromAngle (degrees 90)\r\n    -->   )\r\n    --> , ( Point2d.fromCoordinates ( 1.4142, 0.7071 )\r\n    -->   , Direction2d.fromAngle (degrees 153.4)\r\n    -->   )\r\n    --> , ( Point2d.fromCoordinates ( 0, 1 )\r\n    -->   , Direction2d.fromAngle (degrees 180)\r\n    -->   )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> EllipticalArc2d.Nondegenerate units coordinates -> List.List ( Point2d.Point2d units coordinates, Direction2d.Direction2d coordinates )"},{"name":"scaleAbout","comment":" Scale an elliptical arc about a given point by a given scale.\r\n\r\n    exampleArc\r\n        |> EllipticalArc2d.scaleAbout Point2d.origin 3\r\n    --> EllipticalArc2d.with\r\n    -->     { centerPoint = Point2d.origin\r\n    -->     , xDirection = Direction2d.x\r\n    -->     , xRadius = 6\r\n    -->     , yRadius = 3\r\n    -->     , startAngle = 0\r\n    -->     , sweptAngle = degrees 90\r\n    -->     }\r\n\r\n","type":"Point2d.Point2d units coordinates -> Basics.Float -> EllipticalArc2d.EllipticalArc2d units coordinates -> EllipticalArc2d.EllipticalArc2d units coordinates"},{"name":"startAngle","comment":" The start angle of an elliptical arc is the value of the [ellipse parameter](https://en.wikipedia.org/wiki/Ellipse#Parametric_representation)\r\nat the start point of the arc.\r\n\r\n    EllipticalArc2d.startAngle exampleArc\r\n    --> 0\r\n\r\n","type":"EllipticalArc2d.EllipticalArc2d units coordinates -> Angle.Angle"},{"name":"startPoint","comment":" Get the start point of an elliptical arc.\r\n\r\n    EllipticalArc2d.startPoint exampleArc\r\n    --> Point2d.fromCoordinates ( 2, 0 )\r\n\r\n","type":"EllipticalArc2d.EllipticalArc2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"sweptAngle","comment":" The swept angle of an elliptical arc is the difference between values of the\r\n[ellipse parameter](https://en.wikipedia.org/wiki/Ellipse#Parametric_representation)\r\nfrom the start point to the end point of the arc.\r\n\r\n    EllipticalArc2d.sweptAngle exampleArc\r\n    --> degrees 90\r\n\r\n","type":"EllipticalArc2d.EllipticalArc2d units coordinates -> Angle.Angle"},{"name":"tangentDirection","comment":" Get the tangent direction to a nondegenerate elliptical arc at a given\r\nparameter value:\r\n\r\n    EllipticalArc2d.tangentDirection nondegenerateExampleArc\r\n        ParameterValue.zero\r\n    --> Direction2d.fromAngle (degrees 90)\r\n\r\n    EllipticalArc2d.tangentDirection nondegenerateExampleArc\r\n        ParameterValue.half\r\n    --> Direction2d.fromAngle (degrees 153.4)\r\n\r\n    EllipticalArc2d.tangentDirection nondegenerateExampleArc\r\n        ParameterValue.one\r\n    --> Direction2d.fromAngle (degrees 180)\r\n\r\n","type":"EllipticalArc2d.Nondegenerate units coordinates -> Curve.ParameterValue.ParameterValue -> Direction2d.Direction2d coordinates"},{"name":"tangentDirectionAlong","comment":" Try to get the tangent direction along an elliptical arc at a given arc\r\nlength. To get the tangent direction at the midpoint of `exampleArc`:\r\n\r\n    EllipticalArc2d.tangentDirectionAlong parameterizedArc\r\n        (arcLength / 2)\r\n    --> Just (Direction2d.fromAngle (degrees 159.7))\r\n\r\nIf the given arc length is less than zero or greater than the arc length of the\r\nelliptical arc (or if the elliptical arc is degenerate), returns `Nothing`.\r\n\r\n","type":"EllipticalArc2d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units -> Maybe.Maybe (Direction2d.Direction2d coordinates)"},{"name":"tangentDirectionsAt","comment":" Get tangent directions to a nondegenerate elliptical arc at a given set of\r\nparameter values:\r\n\r\n    nondegenerateExampleArc\r\n        |> EllipticalArc2d.tangentDirectionsAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Direction2d.fromAngle (degrees 90)\r\n    --> , Direction2d.fromAngle (degrees 153.4)\r\n    --> , Direction2d.fromAngle (degrees 180)\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> EllipticalArc2d.Nondegenerate units coordinates -> List.List (Direction2d.Direction2d coordinates)"},{"name":"translateBy","comment":" Translate an elliptical arc by a given displacement.\r\n\r\n    exampleArc\r\n        |> EllipticalArc2d.translateBy\r\n            (Vector2d.fromComponents ( 2, 3 ))\r\n    --> EllipticalArc2d.with\r\n    -->     { centerPoint =\r\n    -->         Point2d.fromCoordinates ( 2, 3 )\r\n    -->     , xDirection = Direction2d.x\r\n    -->     , xRadius = 2\r\n    -->     , yRadius = 1\r\n    -->     , startAngle = 0\r\n    -->     , sweptAngle = degrees 90\r\n    -->     }\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> EllipticalArc2d.EllipticalArc2d units coordinates -> EllipticalArc2d.EllipticalArc2d units coordinates"},{"name":"translateIn","comment":" Translate an elliptical arc in a given direction by a given distance;\r\n\r\n    EllipticalArc2d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    EllipticalArc2d.translateBy\r\n        (Vector2d.withLength distance direction)\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Quantity.Quantity Basics.Float units -> EllipticalArc2d.EllipticalArc2d units coordinates -> EllipticalArc2d.EllipticalArc2d units coordinates"},{"name":"with","comment":" Construct an elliptical arc from its center point, X direction, X and Y\r\nradii, start angle and swept angle. If you pass a negative radius, the absolute\r\nvalue will be used.\r\n\r\nFor example, to construct a simple 90 degree elliptical arc, you might use\r\n\r\n    exampleArc =\r\n        EllipticalArc2d.with\r\n            { centerPoint = Point2d.origin\r\n            , xDirection = Direction2d.x\r\n            , xRadius = 2\r\n            , yRadius = 1\r\n            , startAngle = 0\r\n            , sweptAngle = degrees 90\r\n            }\r\n\r\n![90 degree elliptical arc](https://ianmackenzie.github.io/elm-geometry/1.0.0/EllipticalArc2d/with1.svg)\r\n\r\nTo make an inclined 180 degree elliptical arc, you might use\r\n\r\n    EllipticalArc2d.with\r\n        { centerPoint = Point2d.origin\r\n        , xDirection = Direction2d.fromAngle (degrees 30)\r\n        , xRadius = 2\r\n        , yRadius = 1\r\n        , startAngle = degrees -90\r\n        , sweptAngle = degrees 180\r\n        }\r\n\r\n![180 degree inclined elliptical arc](https://ianmackenzie.github.io/elm-geometry/1.0.0/EllipticalArc2d/with2.svg)\r\n\r\n","type":"{ centerPoint : Point2d.Point2d units coordinates, xDirection : Direction2d.Direction2d coordinates, xRadius : Quantity.Quantity Basics.Float units, yRadius : Quantity.Quantity Basics.Float units, startAngle : Angle.Angle, sweptAngle : Angle.Angle } -> EllipticalArc2d.EllipticalArc2d units coordinates"},{"name":"xAxis","comment":" ","type":"EllipticalArc2d.EllipticalArc2d units coordinates -> Axis2d.Axis2d units coordinates"},{"name":"xDirection","comment":" ","type":"EllipticalArc2d.EllipticalArc2d units coordinates -> Direction2d.Direction2d coordinates"},{"name":"xRadius","comment":" ","type":"EllipticalArc2d.EllipticalArc2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"yAxis","comment":" ","type":"EllipticalArc2d.EllipticalArc2d units coordinates -> Axis2d.Axis2d units coordinates"},{"name":"yDirection","comment":" ","type":"EllipticalArc2d.EllipticalArc2d units coordinates -> Direction2d.Direction2d coordinates"},{"name":"yRadius","comment":" ","type":"EllipticalArc2d.EllipticalArc2d units coordinates -> Quantity.Quantity Basics.Float units"}],"binops":[]},{"name":"Frame2d","comment":" A `Frame2d` has an origin point and a pair of X and Y directions (which are\r\nalways perpendicular to each other). It can be thought of as:\r\n\r\n  - A local coordinate system: Most geometric types have associated `relativeTo`\r\n    and `placeIn` functions that convert values of that type from global\r\n    coordinates to local coordinates in a particular frame, and vice versa.\r\n  - A pair of X and Y axes: It is often convenient to (for example) mirror\r\n    across the X axis of a frame, or project onto its Y axis. Frames can\r\n    also themselves be translated, rotated and mirrored!\r\n  - A combined 2D position and orientation: For example, a `Frame2d` could be\r\n    used to define the position and orientation of a spaceship in a 2D game.\r\n    Movement of the ship would then be done by translating and rotating the\r\n    frame.\r\n\r\n@docs Frame2d\r\n\r\n\r\n# Constants\r\n\r\n@docs atOrigin\r\n\r\n\r\n# Constructors\r\n\r\n@docs atPoint, atCoordinates, withXDirection, withYDirection, copy, unsafe\r\n\r\n\r\n# Properties\r\n\r\n@docs originPoint, xDirection, yDirection, isRightHanded, xAxis, yAxis\r\n\r\n\r\n# Transformations\r\n\r\n@docs reverseX, reverseY, moveTo, rotateBy, rotateAround, translateBy, translateIn, translateAlongOwn, mirrorAcross\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n","unions":[],"aliases":[{"name":"Frame2d","comment":" ","args":["units","coordinates1","coordinates2"],"type":"Geometry.Types.Frame2d units coordinates1 coordinates2"}],"values":[{"name":"atCoordinates","comment":" Shorthand for `Frame2d.atPoint`;\r\n\r\n    Frame2d.atCoordinates ( x, y )\r\n\r\nis equivalent to\r\n\r\n    Frame2d.atPoint (Point2d.fromCoordinates ( x, y ))\r\n\r\n","type":"( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units ) -> Frame2d.Frame2d units coordinates1 coordinates2"},{"name":"atOrigin","comment":" The global XY frame, centered at the origin.\r\n\r\n    Frame2d.originPoint Frame2d.atOrigin\r\n    --> Point2d.origin\r\n\r\n    Frame2d.xDirection Frame2d.atOrigin\r\n    --> Direction2d.x\r\n\r\n    Frame2d.yDirection Frame2d.atOrigin\r\n    --> Direction2d.y\r\n\r\n","type":"Frame2d.Frame2d units coordinates coordinates"},{"name":"atPoint","comment":" Construct a frame aligned with the global XY frame but with the given origin\r\npoint.\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 2, 3 )\r\n\r\n    frame =\r\n        Frame2d.atPoint point\r\n\r\n    Frame2d.originPoint frame\r\n    --> point\r\n\r\n    Frame2d.xDirection frame\r\n    --> Direction2d.x\r\n\r\n    Frame2d.yDirection frame\r\n    --> Direction2d.y\r\n\r\n","type":"Point2d.Point2d units coordinates1 -> Frame2d.Frame2d units coordinates1 coordinates2"},{"name":"copy","comment":" Create a 'fresh copy' of a frame: one with the same origin point and X/Y\r\ndirections, but that can be used to define a different local coordinate system.\r\nSometimes useful in generic/library code.\r\n","type":"Frame2d.Frame2d units coordinates1 coordinates2 -> Frame2d.Frame2d units coordinates1 coordinates3"},{"name":"isRightHanded","comment":" Check if a frame is [right-handed](https://en.wikipedia.org/wiki/Cartesian_coordinate_system#Orientation_and_handedness).\r\n\r\n    Frame2d.isRightHanded Frame2d.atOrigin\r\n    --> True\r\n\r\n    Frame2d.isRightHanded\r\n        (Frame2d.reverseX Frame2d.atOrigin)\r\n    --> False\r\n\r\nAll predefined frames are right-handed, and most operations on frames preserve\r\nhandedness, so about the only ways to end up with a left-handed frame are by\r\nconstructing one explicitly with `unsafe` or by mirroring a right-handed frame.\r\n\r\n","type":"Frame2d.Frame2d units coordinates1 coordinates2 -> Basics.Bool"},{"name":"mirrorAcross","comment":" Mirror a frame across an axis.\r\n\r\n    frame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 2, 3 ))\r\n\r\n    mirroredFrame =\r\n        Frame2d.mirrorAcross Axis2d.x frame\r\n\r\n    Frame2d.originPoint mirroredFrame\r\n    --> Point2d.fromCoordinates ( 2, -3 )\r\n\r\n    Frame2d.xDirection mirroredFrame\r\n    --> Direction2d.x\r\n\r\n    Frame2d.yDirection mirroredFrame\r\n    --> Direction2d.negativeY\r\n\r\nNote that this will switch the [handedness](https://en.wikipedia.org/wiki/Cartesian_coordinate_system#Orientation_and_handedness)\r\nof the frame.\r\n\r\n","type":"Axis2d.Axis2d units coordinates1 -> Frame2d.Frame2d units coordinates1 coordinates2 -> Frame2d.Frame2d units coordinates1 coordinates3"},{"name":"moveTo","comment":" Move a frame so that it has the given origin point.\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 1, 1 )\r\n\r\n    Frame2d.atOrigin |> Frame2d.moveTo point\r\n    --> Frame2d.atPoint point\r\n\r\n","type":"Point2d.Point2d units coordinates1 -> Frame2d.Frame2d units coordinates1 coordinates2 -> Frame2d.Frame2d units coordinates1 coordinates3"},{"name":"originPoint","comment":" Get the origin point of a given frame.\r\n\r\n    Frame2d.originPoint Frame2d.atOrigin\r\n    --> Point2d.origin\r\n\r\n","type":"Frame2d.Frame2d units coordinates1 coordinates2 -> Point2d.Point2d units coordinates1"},{"name":"placeIn","comment":" Take one frame defined in global coordinates and a second frame defined\r\nin local coordinates relative to the first frame, and return the second frame\r\nexpressed in global coordinates.\r\n","type":"Frame2d.Frame2d units coordinates1 coordinates2 -> Frame2d.Frame2d units coordinates2 coordinates3 -> Frame2d.Frame2d units coordinates1 coordinates3"},{"name":"relativeTo","comment":" Take two frames defined in global coordinates, and return the second one\r\nexpressed in local coordinates relative to the first.\r\n","type":"Frame2d.Frame2d units coordinates1 coordinates2 -> Frame2d.Frame2d units coordinates1 coordinates3 -> Frame2d.Frame2d units coordinates2 coordinates3"},{"name":"reverseX","comment":" Reverse the X direction of a frame, leaving its Y direction and origin point\r\nthe same.\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 2, 3 )\r\n\r\n    frame =\r\n        Frame2d.atPoint point |> Frame2d.reverseX\r\n\r\n    Frame2d.originPoint frame\r\n    --> point\r\n\r\n    Frame2d.xDirection frame\r\n    --> Direction2d.negativeX\r\n\r\n    Frame2d.yDirection frame\r\n    --> Direction2d.y\r\n\r\nNote that this will switch the [handedness](https://en.wikipedia.org/wiki/Cartesian_coordinate_system#Orientation_and_handedness)\r\nof the frame.\r\n\r\n","type":"Frame2d.Frame2d units coordinates1 coordinates2 -> Frame2d.Frame2d units coordinates1 coordinates3"},{"name":"reverseY","comment":" Reverse the Y direction of a frame, leaving its X direction and origin point\r\nthe same.\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 2, 3 )\r\n\r\n    frame =\r\n        Frame2d.atPoint point |> Frame2d.reverseY\r\n\r\n    Frame2d.originPoint frame\r\n    --> point\r\n\r\n    Frame2d.xDirection frame\r\n    --> Direction2d.x\r\n\r\n    Frame2d.yDirection frame\r\n    --> Direction2d.negativeY\r\n\r\nNote that this will switch the [handedness](https://en.wikipedia.org/wiki/Cartesian_coordinate_system#Orientation_and_handedness)\r\nof the frame.\r\n\r\n","type":"Frame2d.Frame2d units coordinates1 coordinates2 -> Frame2d.Frame2d units coordinates1 coordinates3"},{"name":"rotateAround","comment":" Rotate a frame counterclockwise around a given point by a given angle. The\r\nframe's origin point will be rotated around the given point by the given angle,\r\nand its X and Y basis directions will be rotated by the given angle.\r\n\r\n    rotatedFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 1, 1 ))\r\n            |> Frame2d.rotateAround Point2d.origin\r\n                (degrees 45)\r\n\r\n    Frame2d.originPoint rotatedFrame\r\n    --> Point2d.fromCoordinates ( 0, 1.4142 )\r\n\r\n    Frame2d.xDirection rotatedFrame\r\n    --> Direction2d.fromAngle (degrees 45)\r\n\r\n    Frame2d.yDirection rotatedFrame\r\n    --> Direction2d.fromAngle (degrees 135)\r\n\r\n","type":"Point2d.Point2d units coordinates1 -> Angle.Angle -> Frame2d.Frame2d units coordinates1 coordinates2 -> Frame2d.Frame2d units coordinates1 coordinates3"},{"name":"rotateBy","comment":" Rotate a frame counterclockwise by a given angle around the frame's own\r\norigin point. The resulting frame will have the same origin point, and its X and\r\nY directions will be rotated by the given angle.\r\n\r\n    rotatedFrame =\r\n        Frame2d.rotateBy (degrees 30) Frame2d.atOrigin\r\n\r\n    Frame2d.xDirection rotatedFrame\r\n    --> Direction2d.fromAngle (degrees 30)\r\n\r\n    Frame2d.yDirection rotatedFrame\r\n    --> Direction2d.fromAngle (degrees 120)\r\n\r\n","type":"Angle.Angle -> Frame2d.Frame2d units coordinates1 coordinates2 -> Frame2d.Frame2d units coordinates1 coordinates3"},{"name":"translateAlongOwn","comment":" Translate a frame along one of its own axes by a given distance.\r\n\r\nThe first argument is a function that returns the axis to translate along, given\r\nthe current frame. The majority of the time this argument will be either\r\n`Frame2d.xAxis` or `Frame2d.yAxis`. The second argument is the distance to\r\ntranslate along the given axis.\r\n\r\nThis function is convenient when constructing frames via a series of\r\ntransformations. For example,\r\n\r\n    frame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 2, 0 ))\r\n            |> Frame2d.rotateBy (degrees 45)\r\n            |> Frame2d.translateAlongOwn Frame2d.xAxis 2\r\n\r\nmeans \"construct a frame at the point (2, 0), rotate it around its own origin\r\npoint by 45 degrees, then translate it along its own X axis by 2 units\",\r\nresulting in\r\n\r\n    Frame2d.originPoint frame\r\n    --> Point2d.fromCoordinates ( 3.4142, 1.4142 )\r\n\r\n    Frame2d.xDirection frame\r\n    --> Direction2d.fromAngle (degrees 45)\r\n\r\n    Frame2d.yDirection frame\r\n    --> Direction2d.fromAngle (degrees 135)\r\n\r\n","type":"(Frame2d.Frame2d units coordinates1 coordinates2 -> Axis2d.Axis2d units coordinates1) -> Quantity.Quantity Basics.Float units -> Frame2d.Frame2d units coordinates1 coordinates2 -> Frame2d.Frame2d units coordinates1 coordinates3"},{"name":"translateBy","comment":" Translate a frame by a given displacement.\r\n\r\n    frame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 2, 3 ))\r\n\r\n    displacement =\r\n        Vector2d.fromComponents ( 1, 1 )\r\n\r\n    Frame2d.translateBy displacement frame\r\n    --> Frame2d.atPoint (Point2d.fromCoordinates ( 3, 4 ))\r\n\r\n","type":"Vector2d.Vector2d units coordinates1 -> Frame2d.Frame2d units coordinates1 coordinates2 -> Frame2d.Frame2d units coordinates1 coordinates3"},{"name":"translateIn","comment":" Translate a frame in a given direction by a given distance;\r\n\r\n    Frame2d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    Frame2d.translateBy\r\n        (Vector2d.withLength distance direction)\r\n\r\n","type":"Direction2d.Direction2d coordinates1 -> Quantity.Quantity Basics.Float units -> Frame2d.Frame2d units coordinates1 coordinates2 -> Frame2d.Frame2d units coordinates1 coordinates3"},{"name":"unsafe","comment":" Construct a frame directly from its origin point and X and Y directions:\r\n\r\n    frame =\r\n        Frame2d.unsafe\r\n            { originPoint =\r\n                Point2d.fromCoordinates ( 2, 3 )\r\n            , xDirection =\r\n                Direction2d.fromAngle (degrees 45)\r\n            , yDirection =\r\n                Direction2d.fromAngle (degrees 135)\r\n            }\r\n\r\nIn this case **you must be careful to ensure that the X and Y directions are\r\nperpendicular**. To construct pairs of perpendicular directions,\r\n[`Direction2d.orthonormalize`](Direction2d#orthonormalize) or\r\n[`Direction2d.orthogonalize`](Direction2d#orthogonalize) may be useful.\r\n\r\n","type":"{ originPoint : Point2d.Point2d units coordinates1, xDirection : Direction2d.Direction2d coordinates1, yDirection : Direction2d.Direction2d coordinates1 } -> Frame2d.Frame2d units coordinates1 coordinates2"},{"name":"withXDirection","comment":" Construct a frame with the given X axis direction, having the given origin\r\npoint. The Y axis direction will be constructed by rotating the given X\r\ndirection 90 degrees counterclockwise:\r\n\r\n    frame =\r\n        Frame2d.withXDirection\r\n            (Direction2d.fromAngle (degrees 30))\r\n            (Point2d.fromCoordinates ( 2, 3 ))\r\n\r\n    Frame2d.yDirection frame\r\n    --> Direction2d.fromAngle (degrees 120)\r\n\r\n","type":"Direction2d.Direction2d coordinates1 -> Point2d.Point2d units coordinates1 -> Frame2d.Frame2d units coordinates1 coordinates2"},{"name":"withYDirection","comment":" Construct a frame with the given Y axis direction, having the given origin\r\npoint. The X axis direction will be constructed by rotating the given X\r\ndirection 90 degrees clockwise:\r\n\r\n    frame =\r\n        Frame2d.withYDirection\r\n            (Direction2d.fromAngle (degrees 30))\r\n            (Point2d.fromCoordinates ( 2, 3 ))\r\n\r\n    Frame2d.yDirection frame\r\n    --> Direction2d.fromAngle (degrees -60)\r\n\r\n","type":"Direction2d.Direction2d coordinates1 -> Point2d.Point2d units coordinates1 -> Frame2d.Frame2d units coordinates1 coordinates2"},{"name":"xAxis","comment":" Get the X axis of a given frame (the axis formed from the frame's origin\r\npoint and X direction).\r\n\r\n    Frame2d.xAxis Frame2d.atOrigin\r\n    --> Axis2d.x\r\n\r\n","type":"Frame2d.Frame2d units coordinates1 coordinates2 -> Axis2d.Axis2d units coordinates1"},{"name":"xDirection","comment":" Get the X direction of a given frame.\r\n\r\n    Frame2d.xDirection Frame2d.atOrigin\r\n    --> Direction2d.x\r\n\r\n","type":"Frame2d.Frame2d units coordinates1 coordinates2 -> Direction2d.Direction2d coordinates1"},{"name":"yAxis","comment":" Get the Y axis of a given frame (the axis formed from the frame's origin\r\npoint and Y direction).\r\n\r\n    Frame2d.yAxis Frame2d.atOrigin\r\n    --> Axis2d.y\r\n\r\n","type":"Frame2d.Frame2d units coordinates1 coordinates2 -> Axis2d.Axis2d units coordinates1"},{"name":"yDirection","comment":" Get the Y direction of a given frame.\r\n\r\n    Frame2d.yDirection Frame2d.atOrigin\r\n    --> Direction2d.y\r\n\r\n","type":"Frame2d.Frame2d units coordinates1 coordinates2 -> Direction2d.Direction2d coordinates1"}],"binops":[]},{"name":"Frame3d","comment":" A `Frame3d` has an origin point and a set of X, Y and Z directions (which\r\nare always perpendicular to each other). It can be thought of as:\r\n\r\n  - A local coordinate system: Most geometric types have associated `relativeTo`\r\n    and `placeIn` functions that convert values of that type from global\r\n    coordinates to local coordinates in a particular frame, and vice versa.\r\n  - A set of axes and planes: It is often convenient to (for example) rotate\r\n    around the Z axis of a frame, or mirror across its XY plane. Frames can\r\n    also themselves be translated, rotated and mirrored!\r\n  - A combined 3D position and orientation: For example, a `Frame3d` could be\r\n    used to define the position and orientation of a spaceship in a 3D game.\r\n    Movement of the ship would then be done by translating and rotating the\r\n    frame.\r\n\r\n@docs Frame3d\r\n\r\n\r\n# Constants\r\n\r\n@docs atOrigin\r\n\r\n\r\n# Constructors\r\n\r\nThe `withXDirection`, `withYDirection` and `withZDirection` functions all\r\nconstruct a new `Frame3d` with the given axis direction, having the given origin\r\npoint. The other two directions will be chosen arbitrarily. This can be useful\r\nwhen constructing 'scratch' frames where (for example) you want a particular Z\r\ndirection but the specific X/Y directions are unimportant:\r\n\r\n    zDirection =\r\n        Direction3d.fromAzimuthAndElevation\r\n            (degrees 0)\r\n            (degrees 60)\r\n\r\n    frame =\r\n        Frame3d.withZDirection zDirection Point3d.origin\r\n\r\n    Frame3d.zDirection frame\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 0)\r\n    -->     (degrees 60)\r\n\r\n    Frame3d.originPoint frame\r\n    --> Point3d.origin\r\n\r\n    Frame3d.xDirection frame\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 0)\r\n    -->     (degrees -30)\r\n\r\n    Frame3d.yDirection frame\r\n    --> Direction3d.y\r\n\r\nNo guarantees are given about the other two directions other than that the three\r\ndirections will be mutually perpendicular, and will be oriented so that the\r\nresulting frame is [right-handed](https://en.wikipedia.org/wiki/Cartesian_coordinate_system#Orientation_and_handedness).\r\n\r\n@docs withXDirection, withYDirection, withZDirection, atPoint, atCoordinates, copy, unsafe\r\n\r\n\r\n# Properties\r\n\r\n@docs originPoint, xDirection, yDirection, zDirection, isRightHanded\r\n\r\n\r\n## Axes\r\n\r\n@docs xAxis, yAxis, zAxis\r\n\r\n\r\n## Planes\r\n\r\nThe following functions all return planes with the same origin point as the\r\ngiven frame, but with varying normal directions. In each case the normal\r\ndirection of the resulting plane is given by the cross product of the two\r\nindicated basis directions (assuming a right-handed frame); for example,\r\n\r\n    Frame3d.xyPlane Frame3d.atOrigin\r\n    --> Plane3d.through Point3d.origin\r\n    -->     Direction3d.positiveZ\r\n\r\nsince the cross product of the X and Y basis directions of a frame is equal to\r\nits Z basis direction. And since reversing the order of arguments in a cross\r\nproduct reverses the sign of the result,\r\n\r\n    Frame3d.yxPlane Frame3d.atOrigin\r\n    --> Plane3d.through Point3d.origin\r\n    -->     Direction3d.negativeZ\r\n\r\n@docs xyPlane, yxPlane, yzPlane, zyPlane, zxPlane, xzPlane\r\n\r\n\r\n## Sketch planes\r\n\r\nThese functions all form a `SketchPlane3d` from two axes of the given frame. The\r\nX and Y axes of the sketch plane will correspond to the two indicated axes. For\r\nexample,\r\n\r\n    yzSketchPlane =\r\n        Frame3d.yzSketchPlane Frame3d.atOrigin\r\n\r\n    SketchPlane3d.originPoint yzSketchPlane\r\n    --> Point3d.origin\r\n\r\n    SketchPlane3d.xDirection yzSketchPlane\r\n    --> Direction3d.y\r\n\r\n    SketchPlane3d.yDirection yzSketchPlane\r\n    --> Direction3d.z\r\n\r\nNote that this can be confusing - for example, a local X coordinate in the above\r\nsketch plane corresponds to a global Y coordinate, and a local Y coordinate\r\ncorresponds to a global Z coordinate!\r\n\r\n@docs xySketchPlane, yxSketchPlane, yzSketchPlane, zySketchPlane, zxSketchPlane, xzSketchPlane\r\n\r\n\r\n# Transformations\r\n\r\n@docs reverseX, reverseY, reverseZ, moveTo, rotateAround, rotateAroundOwn, translateBy, translateIn, translateAlongOwn, mirrorAcross\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n","unions":[],"aliases":[{"name":"Frame3d","comment":" ","args":["units","coordinates1","coordinates2"],"type":"Geometry.Types.Frame3d units coordinates1 coordinates2"}],"values":[{"name":"atCoordinates","comment":" Shorthand for `Frame3d.atPoint`;\r\n\r\n    Frame3d.atCoordinates ( x, y, z )\r\n\r\nis equivalent to\r\n\r\n    Frame3d.atPoint (Point3d.fromCoordinates ( x, y, z ))\r\n\r\n","type":"( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units ) -> Frame3d.Frame3d units coordinates1 coordinates2"},{"name":"atOrigin","comment":" The global XYZ frame, centered at the origin.\r\n\r\n    Frame3d.originPoint Frame3d.atOrigin\r\n    --> Point3d.origin\r\n\r\n    Frame3d.xDirection Frame3d.atOrigin\r\n    --> Direction3d.x\r\n\r\n    Frame3d.yDirection Frame3d.atOrigin\r\n    --> Direction3d.y\r\n\r\n    Frame3d.zDirection Frame3d.atOrigin\r\n    --> Direction3d.z\r\n\r\n","type":"Frame3d.Frame3d units coordinates coordinates"},{"name":"atPoint","comment":" Construct a frame aligned with the global XYZ frame but with the given\r\norigin point.\r\n\r\n    frame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 2, 1, 3 ))\r\n\r\n    Frame3d.originPoint frame\r\n    --> Point3d.fromCoordinates ( 2, 1, 3 )\r\n\r\n    Frame3d.xDirection frame\r\n    --> Direction3d.x\r\n\r\n    Frame3d.yDirection frame\r\n    --> Direction3d.y\r\n\r\n    Frame3d.zDirection frame\r\n    --> Direction3d.z\r\n\r\n","type":"Point3d.Point3d units coordinates1 -> Frame3d.Frame3d units coordinates1 coordinates2"},{"name":"copy","comment":" Create a 'fresh copy' of a frame: one with the same origin point and X/Y/Z\r\ndirections, but that can be used to define a different local coordinate system.\r\nSometimes useful in generic/library code.\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Frame3d.Frame3d units coordinates1 coordinates3"},{"name":"isRightHanded","comment":" Check if a frame is [right-handed](https://en.wikipedia.org/wiki/Cartesian_coordinate_system#Orientation_and_handedness).\r\n\r\n    Frame3d.isRightHanded Frame3d.atOrigin\r\n    --> True\r\n\r\n    Frame3d.isRightHanded\r\n        (Frame3d.reverseZ Frame3d.atOrigin)\r\n    --> False\r\n\r\nAll predefined frames are right-handed, and most operations on frames preserve\r\nhandedness, so about the only ways to end up with a left-handed frame are by\r\nconstructing one explicitly with `unsafe` or by mirroring a right-handed frame.\r\n\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Basics.Bool"},{"name":"mirrorAcross","comment":" Mirror a frame across a plane.\r\n\r\n    frame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 2, 1, 3 ))\r\n\r\n    mirroredFrame =\r\n        Frame3d.mirrorAcross Plane3d.xy frame\r\n\r\n    Frame3d.originPoint mirroredFrame\r\n    --> Point3d.fromCoordinates ( 2, 1, -3 )\r\n\r\n    Frame3d.xDirection mirroredFrame\r\n    --> Direction3d.x\r\n\r\n    Frame3d.yDirection mirroredFrame\r\n    --> Direction3d.y\r\n\r\n    Frame3d.zDirection mirroredFrame\r\n    --> Direction3d.negativeZ\r\n\r\nNote that this will switch the [handedness](https://en.wikipedia.org/wiki/Cartesian_coordinate_system#Orientation_and_handedness)\r\nof the frame.\r\n\r\n","type":"Plane3d.Plane3d units coordinates1 -> Frame3d.Frame3d units coordinates1 coordinates2 -> Frame3d.Frame3d units coordinates1 coordinates3"},{"name":"moveTo","comment":" Move a frame so that it has the given origin point but unchanged\r\norientation.\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 2, 1, 3 )\r\n\r\n    Frame3d.atOrigin |> Frame3d.moveTo point\r\n    --> Frame3d.atPoint point\r\n\r\n","type":"Point3d.Point3d units coordinates1 -> Frame3d.Frame3d units coordinates1 coordinates2 -> Frame3d.Frame3d units coordinates1 coordinates3"},{"name":"originPoint","comment":" Get the origin point of a given frame.\r\n\r\n    Frame3d.originPoint Frame3d.atOrigin\r\n    --> Point3d.origin\r\n\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Point3d.Point3d units coordinates1"},{"name":"placeIn","comment":" Take one frame defined in global coordinates and a second frame defined\r\nin local coordinates relative to the first frame, and return the second frame\r\nexpressed in global coordinates.\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Frame3d.Frame3d units coordinates2 coordinates3 -> Frame3d.Frame3d units coordinates1 coordinates3"},{"name":"relativeTo","comment":" Take two frames defined in global coordinates, and return the second one\r\nexpressed in local coordinates relative to the first.\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Frame3d.Frame3d units coordinates1 coordinates3 -> Frame3d.Frame3d units coordinates2 coordinates3"},{"name":"reverseX","comment":" Reverse the X direction of a frame.\r\n\r\n    Frame3d.xDirection (Frame3d.reverseX Frame3d.atOrigin)\r\n    --> Direction3d.negativeX\r\n\r\nNote that this will switch the [handedness](https://en.wikipedia.org/wiki/Cartesian_coordinate_system#Orientation_and_handedness)\r\nof the frame.\r\n\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Frame3d.Frame3d units coordinates1 coordinates3"},{"name":"reverseY","comment":" Reverse the Y direction of a frame.\r\n\r\n    Frame3d.yDirection (Frame3d.reverseY Frame3d.atOrigin)\r\n    --> Direction3d.negativeY\r\n\r\nNote that this will switch the [handedness](https://en.wikipedia.org/wiki/Cartesian_coordinate_system#Orientation_and_handedness)\r\nof the frame.\r\n\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Frame3d.Frame3d units coordinates1 coordinates3"},{"name":"reverseZ","comment":" Reverse the Z direction of a frame.\r\n\r\n    Frame3d.zDirection (Frame3d.reverseZ Frame3d.atOrigin)\r\n    --> Direction3d.negativeZ\r\n\r\nNote that this will switch the [handedness](https://en.wikipedia.org/wiki/Cartesian_coordinate_system#Orientation_and_handedness)\r\nof the frame.\r\n\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Frame3d.Frame3d units coordinates1 coordinates3"},{"name":"rotateAround","comment":" Rotate a frame around an axis by a given angle (in radians). The frame's\r\norigin point and basis directions will all be rotated around the given axis.\r\n\r\n    frame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 2, 1, 3 ))\r\n\r\n    rotatedFrame =\r\n        Frame3d.rotateAround Axis3d.z (degrees 90) frame\r\n\r\n    Frame3d.originPoint rotatedFrame\r\n    --> Point3d.fromCoordinates ( -1, 2, 3 )\r\n\r\n    Frame3d.xDirection rotatedFrame\r\n    --> Direction3d.y\r\n\r\n    Frame3d.yDirection rotatedFrame\r\n    --> Direction3d.negativeX\r\n\r\n    Frame3d.zDirection rotatedFrame\r\n    --> Direction3d.z\r\n\r\n","type":"Axis3d.Axis3d units coordinates1 -> Angle.Angle -> Frame3d.Frame3d units coordinates1 coordinates2 -> Frame3d.Frame3d units coordinates1 coordinates3"},{"name":"rotateAroundOwn","comment":" Rotate a frame around one of its own axes by a given angle (in radians).\r\n\r\nThe first argument is a function that returns the axis to rotate around, given\r\nthe current frame. The majority of the time this will be either `Frame3d.xAxis`,\r\n`Frame3d.yAxis` or `Frame3d.zAxis`. Compare the following to the above example\r\nfor `rotateAround`:\r\n\r\n    frame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 2, 1, 3 ))\r\n\r\n    rotatedFrame =\r\n        frame\r\n            |> Frame3d.rotateAroundOwn Frame3d.zAxis\r\n                (degrees 90)\r\n\r\n    Frame3d.originPoint rotatedFrame\r\n    --> Point3d.fromCoordinates ( 2, 1, 3 )\r\n\r\n    Frame3d.xDirection rotatedFrame\r\n    --> Direction3d.y\r\n\r\n    Frame3d.yDirection rotatedFrame\r\n    --> Direction3d.negativeX\r\n\r\n    Frame3d.zDirection rotatedFrame\r\n    --> Direction3d.z\r\n\r\nSince the rotation is done around the frame's own Z axis (which passes through\r\nthe frame's origin point), the origin point remains the same after rotation.\r\n\r\nIn this example the frame's Z axis has the same orientation as the global Z axis\r\nso the frame's basis directions are rotated the same way, but in more complex\r\nexamples involving rotated frames a rotation around (for example) the frame's\r\nown Z axis may be completely different from a rotation around the global Z axis.\r\n\r\n","type":"(Frame3d.Frame3d units coordinates1 coordinates2 -> Axis3d.Axis3d units coordinates1) -> Angle.Angle -> Frame3d.Frame3d units coordinates1 coordinates2 -> Frame3d.Frame3d units coordinates1 coordinates3"},{"name":"translateAlongOwn","comment":" Translate a frame along one of its own axes by a given distance.\r\n\r\nThe first argument is a function that returns the axis to translate along, given\r\nthe current frame. The majority of the time this will be either `Frame3d.xAxis`,\r\n`Frame3d.yAxis` or `Frame3d.zAxis`.\r\n\r\nThis function is convenient when constructing frames via a series of\r\ntransformations. For example,\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 2, 0, 0 )\r\n\r\n    frame =\r\n        Frame3d.atPoint point\r\n            |> Frame3d.rotateAroundOwn Frame3d.zAxis\r\n                (degrees 45)\r\n            |> Frame3d.translateAlongOwn Frame3d.xAxis 2\r\n\r\nmeans \"construct a frame at the point (2, 0, 0), rotate it around its own Z axis\r\ncounterclockwise by 45 degrees, then translate it along its own (rotated) X axis\r\nby 2 units\", resulting in\r\n\r\n    Frame3d.originPoint frame\r\n    --> Point3d.fromCoordinates ( 3.4142, 1.4142, 0 )\r\n\r\n    Frame3d.xDirection frame\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 45)\r\n    -->     (degrees 0)\r\n\r\n    Frame3d.yDirection frame\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 135)\r\n    -->     (degrees 0)\r\n\r\n    Frame3d.zDirection frame\r\n    --> Direction3d.z\r\n\r\n","type":"(Frame3d.Frame3d units coordinates1 coordinates2 -> Axis3d.Axis3d units coordinates1) -> Quantity.Quantity Basics.Float units -> Frame3d.Frame3d units coordinates1 coordinates2 -> Frame3d.Frame3d units coordinates1 coordinates3"},{"name":"translateBy","comment":" Translate a frame by a given displacement.\r\n\r\n    frame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 2, 1, 3 ))\r\n\r\n    displacement =\r\n        Vector3d.fromComponents ( 1, 1, 1 )\r\n\r\n    Frame3d.translateBy displacement frame\r\n    --> Frame3d.atPoint\r\n    -->     (Point3d.fromCoordinates ( 3, 2, 4 ))\r\n\r\n","type":"Vector3d.Vector3d units coordinates1 -> Frame3d.Frame3d units coordinates1 coordinates2 -> Frame3d.Frame3d units coordinates1 coordinates3"},{"name":"translateIn","comment":" Translate a frame in a given direction by a given distance;\r\n\r\n    Frame3d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    Frame3d.translateBy\r\n        (Vector3d.withLength distance direction)\r\n\r\n","type":"Direction3d.Direction3d coordinates1 -> Quantity.Quantity Basics.Float units -> Frame3d.Frame3d units coordinates1 coordinates2 -> Frame3d.Frame3d units coordinates1 coordinates3"},{"name":"unsafe","comment":" Construct a frame directly from its origin point and X, Y and Z directions:\r\n\r\n    frame =\r\n        Frame3d.unsafe\r\n            { originPoint =\r\n                Point3d.fromCoordinates ( 2, 1, 3 )\r\n            , xDirection =\r\n                Direction3d.unsafeFromComponents\r\n                    ( 0.8, 0.6, 0 )\r\n            , yDirection =\r\n                Direction3d.unsafeFromComponents\r\n                    ( -0.6, 0.8, 0 )\r\n            , zDirection =\r\n                Direction3d.unsafeFromComponents\r\n                    ( 0, 0, 1 )\r\n            }\r\n\r\nIn this case **you must be careful to ensure that the X, Y and Z directions are\r\nperpendicular**. (You will likely also want to make sure that they form a\r\n[right-handed](https://en.wikipedia.org/wiki/Cartesian_coordinate_system#Orientation_and_handedness)\r\ncoordinate system.) To construct sets of mutually perpendicular directions,\r\n[`Direction3d.orthonormalize`](Direction3d#orthonormalize),\r\n[`Direction3d.orthogonalize`](Direction3d#orthogonalize), or\r\n[`Direction3d.perpendicularBasis`](Direction3d#perpendicularBasis) may be\r\nuseful.\r\n\r\n","type":"{ originPoint : Point3d.Point3d units coordinates1, xDirection : Direction3d.Direction3d coordinates1, yDirection : Direction3d.Direction3d coordinates1, zDirection : Direction3d.Direction3d coordinates1 } -> Frame3d.Frame3d units coordinates1 coordinates2"},{"name":"withXDirection","comment":" Construct a frame with the given origin point and X direction.\r\n","type":"Direction3d.Direction3d coordinates1 -> Point3d.Point3d units coordinates1 -> Frame3d.Frame3d units coordinates1 coordinates2"},{"name":"withYDirection","comment":" Construct a frame with the given origin point and Y direction.\r\n","type":"Direction3d.Direction3d coordinates1 -> Point3d.Point3d units coordinates1 -> Frame3d.Frame3d units coordinates1 coordinates2"},{"name":"withZDirection","comment":" Construct a frame with the given origin point and Z direction.\r\n","type":"Direction3d.Direction3d coordinates1 -> Point3d.Point3d units coordinates1 -> Frame3d.Frame3d units coordinates1 coordinates2"},{"name":"xAxis","comment":" Get the X axis of a given frame (the axis formed from the frame's origin\r\npoint and X direction).\r\n\r\n    Frame3d.xAxis Frame3d.atOrigin\r\n    --> Axis3d.x\r\n\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Axis3d.Axis3d units coordinates1"},{"name":"xDirection","comment":" Get the X direction of a given frame.\r\n\r\n    Frame3d.xDirection Frame3d.atOrigin\r\n    --> Direction3d.x\r\n\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Direction3d.Direction3d coordinates1"},{"name":"xyPlane","comment":" Get a plane with normal direction equal to the frame's positive Z direction.\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Plane3d.Plane3d units coordinates1"},{"name":"xySketchPlane","comment":" Form a sketch plane from the given frame's X and Y axes.\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"xzPlane","comment":" Get a plane with normal direction equal to the frame's negative Y direction.\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Plane3d.Plane3d units coordinates1"},{"name":"xzSketchPlane","comment":" Form a sketch plane from the given frame's X and Z axes.\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"yAxis","comment":" Get the Y axis of a given frame (the axis formed from the frame's origin\r\npoint and Y direction).\r\n\r\n    Frame3d.yAxis Frame3d.atOrigin\r\n    --> Axis3d.y\r\n\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Axis3d.Axis3d units coordinates1"},{"name":"yDirection","comment":" Get the Y direction of a given frame.\r\n\r\n    Frame3d.yDirection Frame3d.atOrigin\r\n    --> Direction3d.y\r\n\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Direction3d.Direction3d coordinates1"},{"name":"yxPlane","comment":" Get a plane with normal direction equal to the frame's negative Z direction.\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Plane3d.Plane3d units coordinates1"},{"name":"yxSketchPlane","comment":" Form a sketch plane from the given frame's Y and X axes.\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"yzPlane","comment":" Get a plane with normal direction equal to the frame's positive X direction.\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Plane3d.Plane3d units coordinates1"},{"name":"yzSketchPlane","comment":" Form a sketch plane from the given frame's Y and Z axes.\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"zAxis","comment":" Get the Z axis of a given frame (the axis formed from the frame's origin\r\npoint and Z direction).\r\n\r\n    Frame3d.zAxis Frame3d.atOrigin\r\n    --> Axis3d.z\r\n\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Axis3d.Axis3d units coordinates1"},{"name":"zDirection","comment":" Get the Z direction of a given frame.\r\n\r\n    Frame3d.zDirection Frame3d.atOrigin\r\n    --> Direction3d.z\r\n\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Direction3d.Direction3d coordinates1"},{"name":"zxPlane","comment":" Get a plane with normal direction equal to the frame's positive Y direction.\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Plane3d.Plane3d units coordinates1"},{"name":"zxSketchPlane","comment":" Form a sketch plane from the given frame's Z and X axes.\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"zyPlane","comment":" Get a plane with normal direction equal to the frame's negative X direction.\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> Plane3d.Plane3d units coordinates1"},{"name":"zySketchPlane","comment":" Form a sketch plane from the given frame's Z and Y axes.\r\n","type":"Frame3d.Frame3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"}],"binops":[]},{"name":"LineSegment2d","comment":" A `LineSegment2d` is a line between two points in 2D. This module contains\r\nfunctionality such as:\r\n\r\n  - Interpolating within a line segment or measuring its length\r\n  - Scaling, rotating, translating, mirroring or projecting a line segment\r\n  - Converting a line segment between local and global coordinates in different\r\n    reference frames\r\n\r\n@docs LineSegment2d\r\n\r\n\r\n# Constructors\r\n\r\n@docs fromEndpoints, from, along\r\n\r\n\r\n# Properties\r\n\r\n@docs startPoint, endPoint, endpoints, midpoint, length, squaredLength, direction, perpendicularDirection, vector, boundingBox\r\n\r\n\r\n# Interpolation\r\n\r\n@docs interpolate\r\n\r\n\r\n# Intersection\r\n\r\n@docs intersectionPoint, intersectionWithAxis\r\n\r\n\r\n# Transformations\r\n\r\nTransforming a line segment is equivalent to transforming its start and end\r\npoints and forming a new line segment between the resulting points.\r\n\r\n@docs reverse, scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross, projectOnto, mapEndpoints\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n","unions":[],"aliases":[{"name":"LineSegment2d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.LineSegment2d units coordinates"}],"values":[{"name":"along","comment":" Construct a line segment lying on the given axis, with its endpoints at the\r\ngiven distances from the axis' origin point.\r\n\r\n    LineSegment2d.along Axis2d.x 3 5\r\n    --> LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 3, 0 )\r\n    -->     , Point2d.fromCoordinates ( 5, 0 )\r\n    -->     )\r\n\r\n    LineSegment2d.along Axis2d.y 2 -4\r\n    --> LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 0, 2 )\r\n    -->     , Point2d.fromCoordinates ( 0, -4 )\r\n    -->     )\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> Quantity.Quantity Basics.Float units -> Quantity.Quantity Basics.Float units -> LineSegment2d.LineSegment2d units coordinates"},{"name":"boundingBox","comment":" Get the minimal bounding box containing a given line segment.\r\n\r\n    LineSegment2d.boundingBox exampleLineSegment\r\n    --> BoundingBox2d.fromExtrema\r\n    -->     { minX = 1\r\n    -->     , maxX = 3\r\n    -->     , minY = 2\r\n    -->     , maxY = 4\r\n    -->     }\r\n\r\n","type":"LineSegment2d.LineSegment2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates"},{"name":"direction","comment":" Get the direction from a line segment's start point to its end point. If the\r\nline segment has zero length (the start and end points are the same), returns\r\n`Nothing`.\r\n\r\n    LineSegment2d.direction exampleLineSegment\r\n    --> Just (Direction2d.fromAngle (degrees 45))\r\n\r\n","type":"LineSegment2d.LineSegment2d units coordinates -> Maybe.Maybe (Direction2d.Direction2d coordinates)"},{"name":"endPoint","comment":" Get the end point of a line segment.\r\n\r\n    LineSegment2d.endPoint exampleLineSegment\r\n    --> Point2d.fromCoordinates ( 3, 4 )\r\n\r\n","type":"LineSegment2d.LineSegment2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"endpoints","comment":" Get the endpoints of a line segment as a tuple.\r\n\r\n    ( p1, p2 ) =\r\n        LineSegment2d.endpoints lineSegment\r\n\r\n","type":"LineSegment2d.LineSegment2d units coordinates -> ( Point2d.Point2d units coordinates, Point2d.Point2d units coordinates )"},{"name":"from","comment":" Construct a line segment from the first point to the second;\r\n\r\n    LineSegment2d.from firstPoint secondPoint\r\n\r\nis equivalent to\r\n\r\n    LineSegment2d.fromEndpoints ( firstPoint, secondPoint )\r\n\r\n","type":"Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> LineSegment2d.LineSegment2d units coordinates"},{"name":"fromEndpoints","comment":" Construct a line segment from its two endpoints:\r\n\r\n    exampleLineSegment =\r\n        LineSegment2d.fromEndpoints\r\n            ( Point2d.fromCoordinates ( 1, 2 )\r\n            , Point2d.fromCoordinates ( 3, 4 )\r\n            )\r\n\r\n","type":"( Point2d.Point2d units coordinates, Point2d.Point2d units coordinates ) -> LineSegment2d.LineSegment2d units coordinates"},{"name":"interpolate","comment":" Interpolate a line segment between its start and end points; a value of 0.0\r\ncorresponds to the start point of the line segment, a value of 0.5 corresponds\r\nto its midpoint and a value of 1.0 corresponds to its end point. Values less\r\nthan 0.0 or greater than 1.0 can be used to extrapolate.\r\n\r\n    LineSegment2d.interpolate exampleLineSegment 0.25\r\n    --> Point2d.fromCoordinates ( 1.5, 2.5 )\r\n\r\n    LineSegment2d.interpolate exampleLineSegment 1.5\r\n    --> Point2d.fromCoordinates ( 4, 5 )\r\n\r\nIf you just need to interpolate between two points, you don't have to construct\r\na line segment first - you can use [`Point2d.interpolateFrom`](Point2d#interpolateFrom)\r\ndirectly.\r\n\r\n","type":"LineSegment2d.LineSegment2d units coordinates -> Basics.Float -> Point2d.Point2d units coordinates"},{"name":"intersectionPoint","comment":" Attempt to find the unique intersection point of two line segments. If there\r\nis no such point (the two line segments do not touch, or they overlap), returns\r\n`Nothing`.\r\n\r\n    -- 4 corners of a square\r\n\r\n    a =\r\n        Point2d.fromCoordinates ( 0, 0 )\r\n\r\n    b =\r\n        Point2d.fromCoordinates ( 1, 0 )\r\n\r\n    c =\r\n        Point2d.fromCoordinates ( 1, 1 )\r\n\r\n    d =\r\n        Point2d.fromCoordinates ( 0, 1 )\r\n\r\n    -- definition of some segments with those points\r\n\r\n    ab =\r\n        LineSegment2d.from a b\r\n    ...\r\n\r\n    -- searching for intersections\r\n\r\n    LineSegment2d.intersectionPoint ab bc\r\n    --> Just (Point2d.fromCoordinates ( 1, 0 ))\r\n    -- corner point b\r\n\r\n    LineSegment2d.intersectionPoint ac bd\r\n    --> Just (Point2d.fromCoordinates ( 0.5, 0.5 ))\r\n    -- diagonal crossing at square center\r\n\r\n    LineSegment2d.intersectionPoint ab cd\r\n    --> Nothing -- parallel lines\r\n\r\n    LineSegment2d.intersectionPoint ab ab\r\n    --> Nothing -- collinear lines\r\n\r\nNote that if the endpoint of one line segment lies on the other line segment,\r\nnumerical roundoff means that the intersection may or may not be found. If two\r\nsegments have a shared endpoint (the two segments meet in something like a 'V',\r\nwhere the end point of one segment is the start point of the next), that point\r\nis guaranteed to be returned as the intersection point, but if two segments meet\r\nin a 'T' shape the intersection point may or may not be found.\r\n\r\n","type":"LineSegment2d.LineSegment2d units coordinates -> LineSegment2d.LineSegment2d units coordinates -> Maybe.Maybe (Point2d.Point2d units coordinates)"},{"name":"intersectionWithAxis","comment":" Attempt to find the unique intersection point of a line segment with an\r\naxis. If there is no such point (the line segment does not touch the axis, or\r\nlies perfectly along it), returns `Nothing`.\r\n\r\n    lineSegment =\r\n        LineSegment2d.fromEndpoints\r\n            ( Point2d.fromCoordinates ( 1, -1 )\r\n            , Point2d.fromCoordinates ( 4, 1 )\r\n            )\r\n\r\n    LineSegment2d.intersectionWithAxis Axis2d.x lineSegment\r\n    --> Just (Point2d.fromCoordinates ( 2.5, 0 ))\r\n\r\n    LineSegment2d.intersectionWithAxis Axis2d.y lineSegment\r\n    --> Nothing\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> LineSegment2d.LineSegment2d units coordinates -> Maybe.Maybe (Point2d.Point2d units coordinates)"},{"name":"length","comment":" Get the length of a line segment.\r\n\r\n    LineSegment2d.length exampleLineSegment\r\n    --> 2.8284\r\n\r\n","type":"LineSegment2d.LineSegment2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"mapEndpoints","comment":" Transform the start and end points of a line segment by a given function\r\nand create a new line segment from the resulting points. Most other\r\ntransformation functions can be defined in terms of `mapEndpoints`; for example,\r\n\r\n    LineSegment2d.projectOnto axis\r\n\r\nis equivalent to\r\n\r\n    LineSegment2d.mapEndpoints (Point2d.projectOnto axis)\r\n\r\n","type":"(Point2d.Point2d unitsA coordinatesA -> Point2d.Point2d unitsB coordinatesB) -> LineSegment2d.LineSegment2d unitsA coordinatesA -> LineSegment2d.LineSegment2d unitsB coordinatesB"},{"name":"midpoint","comment":" Get the midpoint of a line segment.\r\n\r\n    LineSegment2d.midpoint exampleLineSegment\r\n    --> Point2d.fromCoordinates ( 2, 3 )\r\n\r\n","type":"LineSegment2d.LineSegment2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"mirrorAcross","comment":" Mirror a line segment across an axis.\r\n\r\n    LineSegment2d.mirrorAcross Axis2d.y exampleLineSegment\r\n    --> LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( -1, 2 )\r\n    -->     , Point2d.fromCoordinates ( -3, 4 )\r\n    -->     )\r\n\r\nNote that the endpoints of a mirrored segment are equal to the mirrored\r\nendpoints of the original segment, but as a result the normal direction of a\r\nmirrored segment is the _opposite_ of the mirrored normal direction of the\r\noriginal segment (since the normal direction is always considered to be 'to the\r\nleft' of the line segment).\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> LineSegment2d.LineSegment2d units coordinates -> LineSegment2d.LineSegment2d units coordinates"},{"name":"perpendicularDirection","comment":" Get the direction perpendicular to a line segment, pointing to the left. If\r\nthe line segment has zero length, returns `Nothing`.\r\n\r\n    LineSegment2d.perpendicularDirection exampleLineSegment\r\n    --> Just (Direction2d.fromAngle (degrees 135))\r\n\r\n","type":"LineSegment2d.LineSegment2d units coordinates -> Maybe.Maybe (Direction2d.Direction2d coordinates)"},{"name":"placeIn","comment":" Take a line segment considered to be defined in local coordinates relative\r\nto a given reference frame, and return that line segment expressed in global\r\ncoordinates.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    LineSegment2d.placeIn localFrame exampleLineSegment\r\n    --> LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 2, 4 )\r\n    -->     , Point2d.fromCoordinates ( 4, 6 )\r\n    -->     )\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> LineSegment2d.LineSegment2d units localCoordinates -> LineSegment2d.LineSegment2d units globalCoordinates"},{"name":"projectOnto","comment":" Project a line segment onto an axis.\r\n\r\n    LineSegment2d.projectOnto Axis2d.x exampleLineSegment\r\n    --> LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 1, 0 )\r\n    -->     , Point2d.fromCoordinates ( 3, 0 )\r\n    -->     )\r\n\r\n    LineSegment2d.projectOnto Axis2d.y exampleLineSegment\r\n    --> LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 0, 2 )\r\n    -->     , Point2d.fromCoordinates ( 0, 4 )\r\n    -->     )\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> LineSegment2d.LineSegment2d units coordinates -> LineSegment2d.LineSegment2d units coordinates"},{"name":"relativeTo","comment":" Take a line segment defined in global coordinates, and return it expressed\r\nin local coordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    LineSegment2d.relativeTo localFrame exampleLineSegment\r\n    --> LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 0, 0 )\r\n    -->     , Point2d.fromCoordinates ( 2, 2 )\r\n    -->     )\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> LineSegment2d.LineSegment2d units globalCoordinates -> LineSegment2d.LineSegment2d units localCoordinates"},{"name":"reverse","comment":" Reverse a line segment, swapping its start and end points.\r\n\r\n    LineSegment2d.reverse exampleLineSegment\r\n    --> LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 3, 4 )\r\n    -->     , Point2d.fromCoordinates ( 1, 2 )\r\n    -->     )\r\n\r\n","type":"LineSegment2d.LineSegment2d units coordinates -> LineSegment2d.LineSegment2d units coordinates"},{"name":"rotateAround","comment":" Rotate a line segment counterclockwise around a given center point by a\r\ngiven angle (in radians).\r\n\r\n    exampleLineSegment\r\n        |> LineSegment2d.rotateAround Point2d.origin\r\n            (degrees 90)\r\n    --> LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( -2, 1 )\r\n    -->     , Point2d.fromCoordinates ( -4, 3 )\r\n    -->     )\r\n\r\n","type":"Point2d.Point2d units coordinates -> Angle.Angle -> LineSegment2d.LineSegment2d units coordinates -> LineSegment2d.LineSegment2d units coordinates"},{"name":"scaleAbout","comment":" Scale a line segment about the given center point by the given scale.\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 1, 1 )\r\n\r\n    LineSegment2d.scaleAbout point 2 exampleLineSegment\r\n    --> LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 1, 3 )\r\n    -->     , Point2d.fromCoordinates ( 5, 7 )\r\n    -->     )\r\n\r\n","type":"Point2d.Point2d units coordinates -> Basics.Float -> LineSegment2d.LineSegment2d units coordinates -> LineSegment2d.LineSegment2d units coordinates"},{"name":"squaredLength","comment":" Get the squared length of a line segment. Slightly more efficient than\r\n`length` since it avoids a square root.\r\n\r\n    LineSegment2d.squaredLength exampleLineSegment\r\n    --> 8\r\n\r\n","type":"LineSegment2d.LineSegment2d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Squared units)"},{"name":"startPoint","comment":" Get the start point of a line segment.\r\n\r\n    LineSegment2d.startPoint exampleLineSegment\r\n    --> Point2d.fromCoordinates ( 1, 2 )\r\n\r\n","type":"LineSegment2d.LineSegment2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"translateBy","comment":" Translate a line segment by a given displacement.\r\n\r\n    displacement =\r\n        Vector2d.fromComponents ( 1, 2 )\r\n\r\n    exampleLineSegment\r\n        |> LineSegment2d.translateBy displacement\r\n    --> LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 2, 4 )\r\n    -->     , Point2d.fromCoordinates ( 4, 6 )\r\n    -->     )\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> LineSegment2d.LineSegment2d units coordinates -> LineSegment2d.LineSegment2d units coordinates"},{"name":"translateIn","comment":" Translate a line segment in a given direction by a given distance;\r\n\r\n    LineSegment2d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    LineSegment2d.translateBy\r\n        (Vector2d.withLength distance direction)\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Quantity.Quantity Basics.Float units -> LineSegment2d.LineSegment2d units coordinates -> LineSegment2d.LineSegment2d units coordinates"},{"name":"vector","comment":" Get the vector from a given line segment's start point to its end point.\r\n\r\n    LineSegment2d.vector exampleLineSegment\r\n    --> Vector2d.fromComponents ( 2, 2 )\r\n\r\n","type":"LineSegment2d.LineSegment2d units coordinates -> Vector2d.Vector2d units coordinates"}],"binops":[]},{"name":"LineSegment3d","comment":" A `LineSegment3d` is a line between two points in 3D. This module contains\r\nfunctionality such as:\r\n\r\n  - Interpolating within a line segment or measuring its length\r\n  - Scaling, rotating, translating, mirroring or projecting a line segment\r\n  - Converting a line segment between local and global coordinates in different\r\n    reference frames\r\n\r\n@docs LineSegment3d\r\n\r\n\r\n# Constructors\r\n\r\n@docs fromEndpoints, from, along, on\r\n\r\n\r\n# Properties\r\n\r\n@docs startPoint, endPoint, endpoints, midpoint, length, squaredLength, direction, perpendicularDirection, vector, boundingBox\r\n\r\n\r\n# Interpolation\r\n\r\n@docs interpolate\r\n\r\n\r\n# Transformations\r\n\r\nTransforming a line segment is equivalent to transforming its start and end\r\npoints and forming a new line segment between the resulting points.\r\n\r\n@docs reverse, scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross, projectOnto, mapEndpoints\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn, projectInto\r\n\r\n","unions":[],"aliases":[{"name":"LineSegment3d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.LineSegment3d units coordinates"}],"values":[{"name":"along","comment":" Construct a line segment lying on the given axis, with its endpoints at the\r\ngiven distances from the axis' origin point.\r\n\r\n    LineSegment3d.along Axis3d.x 3 5\r\n    --> LineSegment3d.fromEndpoints\r\n    -->     ( Point3d.fromCoordinates ( 3, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 5, 0, 0 )\r\n    -->     )\r\n\r\n    LineSegment3d.along Axis3d.y 2 -4\r\n    --> LineSegment3d.fromEndpoints\r\n    -->     ( Point3d.fromCoordinates ( 0, 2, 0 )\r\n    -->     , Point3d.fromCoordinates ( 0, -4, 0 )\r\n    -->     )\r\n\r\n","type":"Axis3d.Axis3d units coordinates -> Quantity.Quantity Basics.Float units -> Quantity.Quantity Basics.Float units -> LineSegment3d.LineSegment3d units coordinates"},{"name":"boundingBox","comment":" Get the minimal bounding box containing a line segment.\r\n\r\n    LineSegment3d.boundingBox exampleLineSegment\r\n    --> BoundingBox3d.fromExtrema\r\n    -->     { minX = 1\r\n    -->     , maxX = 4\r\n    -->     , minY = 2\r\n    -->     , maxY = 5\r\n    -->     , minZ = 3\r\n    -->     , maxZ = 6\r\n    -->     }\r\n\r\n","type":"LineSegment3d.LineSegment3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates"},{"name":"direction","comment":" Get the direction from a line segment's start point to its end point. If the\r\nline segment has zero length (the start and end points are the same), returns\r\n`Nothing`.\r\n\r\n    LineSegment3d.direction exampleLineSegment\r\n    --> Just\r\n    -->     (Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 45)\r\n    -->         (degrees 35.26)\r\n    -->     )\r\n\r\n","type":"LineSegment3d.LineSegment3d units coordinates -> Maybe.Maybe (Direction3d.Direction3d coordinates)"},{"name":"endPoint","comment":" Get the end point of a line segment.\r\n\r\n    LineSegment3d.endPoint exampleLineSegment\r\n    --> Point3d.fromCoordinates ( 4, 5, 6 )\r\n\r\n","type":"LineSegment3d.LineSegment3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"endpoints","comment":" Get the endpoints of a line segment as a tuple.\r\n\r\n    ( p1, p2 ) =\r\n        LineSegment3d.endpoints lineSegment\r\n\r\n","type":"LineSegment3d.LineSegment3d units coordinates -> ( Point3d.Point3d units coordinates, Point3d.Point3d units coordinates )"},{"name":"from","comment":" Construct a line segment from the first point to the second;\r\n\r\n    LineSegment3d.from firstPoint secondPoint\r\n\r\nis equivalent to\r\n\r\n    LineSegment3d.fromEndpoints ( firstPoint, secondPoint )\r\n\r\n","type":"Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> LineSegment3d.LineSegment3d units coordinates"},{"name":"fromEndpoints","comment":" Construct a line segment from its two endpoints:\r\n\r\n    exampleLineSegment =\r\n        LineSegment3d.fromEndpoints\r\n            ( Point3d.fromCoordinates ( 1, 2, 3 )\r\n            , Point3d.fromCoordinates ( 4, 5, 6 )\r\n            )\r\n\r\n","type":"( Point3d.Point3d units coordinates, Point3d.Point3d units coordinates ) -> LineSegment3d.LineSegment3d units coordinates"},{"name":"interpolate","comment":" Interpolate a line segment between its start and end points; a value of 0.0\r\ncorresponds to the start point of the line segment, a value of 0.5 corresponds\r\nto its midpoint and a value of 1.0 corresponds to its end point. Values less\r\nthan 0.0 or greater than 1.0 can be used to extrapolate.\r\n\r\n    LineSegment3d.interpolate exampleLineSegment (1 / 3)\r\n    --> Point3d.fromCoordinates ( 2, 4, 5 )\r\n\r\n    LineSegment3d.interpolate exampleLineSegment (-1 / 3)\r\n    --> Point3d.fromCoordinates ( 0, 1, 2 )\r\n\r\nIf you just need to interpolate between two points, you don't have to construct\r\na line segment first - you can use [`Point3d.interpolateFrom`](Point3d#interpolateFrom)\r\ndirectly.\r\n\r\n","type":"LineSegment3d.LineSegment3d units coordinates -> Basics.Float -> Point3d.Point3d units coordinates"},{"name":"length","comment":" Get the length of a line segment.\r\n\r\n    LineSegment3d.length exampleLineSegment\r\n    --> 5.1962\r\n\r\n","type":"LineSegment3d.LineSegment3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"mapEndpoints","comment":" Transform the start and end points of a line segment by a given function\r\nand create a new line segment from the resulting points. Most other\r\ntransformation functions can be defined in terms of `mapEndpoints`; for example,\r\n\r\n    LineSegment3d.projectOnto plane\r\n\r\nis equivalent to\r\n\r\n    LineSegment3d.mapEndpoints (Point3d.projectOnto plane)\r\n\r\n","type":"(Point3d.Point3d units1 coordinates1 -> Point3d.Point3d units2 coordinates2) -> LineSegment3d.LineSegment3d units1 coordinates1 -> LineSegment3d.LineSegment3d units2 coordinates2"},{"name":"midpoint","comment":" Get the midpoint of a line segment.\r\n\r\n    LineSegment3d.midpoint exampleLineSegment\r\n    --> Point3d.fromCoordinates ( 2.5, 3.5, 4.5 )\r\n\r\n","type":"LineSegment3d.LineSegment3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"mirrorAcross","comment":" Mirror a line segment across a plane.\r\n\r\n    exampleLineSegment\r\n        |> LineSegment3d.mirrorAcross Plane3d.xy\r\n    --> LineSegment3d.fromEndpoints\r\n    -->     ( Point3d.fromCoordinates ( 1, 2, -3 )\r\n    -->     , Point3d.fromCoordinates ( 4, 5, -6 )\r\n    -->     )\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> LineSegment3d.LineSegment3d units coordinates -> LineSegment3d.LineSegment3d units coordinates"},{"name":"on","comment":" Construct a 3D line segment lying _on_ a sketch plane by providing a 2D line\r\nsegment specified in XY coordinates _within_ the sketch plane.\r\n\r\n    LineSegment3d.on SketchPlane3d.yz <|\r\n        LineSegment2d.fromEndpoints\r\n            ( Point2d.fromCoordinates ( 1, 2 )\r\n            , Point2d.fromCoordinates ( 3, 4 )\r\n            )\r\n    --> LineSegment3d.fromEndpoints\r\n    -->     ( Point3d.fromCoordinates ( 0, 1, 2 )\r\n    -->     , Point3d.fromCoordinates ( 0, 3, 4 )\r\n    -->     )\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates3d coordinates2d -> LineSegment2d.LineSegment2d units coordinates2d -> LineSegment3d.LineSegment3d units coordinates3d"},{"name":"perpendicularDirection","comment":" Get an arbitrary direction perpendicular to a line segment. If the line\r\nsegment has zero length, returns `Nothing`.\r\n\r\n    LineSegment3d.perpendicularDirection exampleLineSegment\r\n    --> Just\r\n    -->     (Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees -90)\r\n    -->         (degrees 45)\r\n    -->     )\r\n\r\n","type":"LineSegment3d.LineSegment3d units coordinates -> Maybe.Maybe (Direction3d.Direction3d coordinates)"},{"name":"placeIn","comment":" Take a line segment considered to be defined in local coordinates relative\r\nto a given reference frame, and return that line segment expressed in global\r\ncoordinates.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    LineSegment3d.placeIn localFrame exampleLineSegment\r\n    --> LineSegment3d.fromEndpoints\r\n    -->     ( Point3d.fromCoordinates ( 2, 4, 6 )\r\n    -->     , Point3d.fromCoordinates ( 5, 7, 9 )\r\n    -->     )\r\n\r\n","type":"Frame3d.Frame3d units globalCoordinates localCoordinates -> LineSegment3d.LineSegment3d units localCoordinates -> LineSegment3d.LineSegment3d units globalCoordinates"},{"name":"projectInto","comment":" Project a line segment into a given sketch plane. Conceptually, this finds\r\nthe [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof the line segment onto the plane and then expresses the projected line segment\r\nin 2D sketch coordinates.\r\n\r\n    exampleLineSegment\r\n        |> LineSegment3d.projectInto SketchPlane3d.xy\r\n    --> LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 1, 2 )\r\n    -->     , Point2d.fromCoordinates ( 4, 5 )\r\n    -->     )\r\n\r\n    exampleLineSegment\r\n        |> LineSegment3d.projectInto SketchPlane3d.yz\r\n    --> LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 2, 3 )\r\n    -->     , Point2d.fromCoordinates ( 5, 6 )\r\n    -->     )\r\n\r\n    exampleLineSegment\r\n        |> LineSegment3d.projectInto SketchPlane3d.zx\r\n    --> LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 3, 1 )\r\n    -->     , Point2d.fromCoordinates ( 6, 4 )\r\n    -->     )\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates3d coordinates2d -> LineSegment3d.LineSegment3d units coordinates3d -> LineSegment2d.LineSegment2d units coordinates2d"},{"name":"projectOnto","comment":" Find the [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof a line segment onto a plane.\r\n\r\n    LineSegment3d.projectOnto Plane3d.yz exampleLineSegment\r\n    --> LineSegment3d.fromEndpoints\r\n    -->     ( Point3d.fromCoordinates ( 0, 2, 3 )\r\n    -->     , Point3d.fromCoordinates ( 0, 5, 6 )\r\n    -->     )\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> LineSegment3d.LineSegment3d units coordinates -> LineSegment3d.LineSegment3d units coordinates"},{"name":"relativeTo","comment":" Take a line segment defined in global coordinates, and return it expressed\r\nin local coordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    LineSegment3d.relativeTo localFrame exampleLineSegment\r\n    --> LineSegment3d.fromEndpoints\r\n    -->     ( Point3d.fromCoordinates ( 0, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 3, 3, 3 )\r\n    -->     )\r\n\r\n","type":"Frame3d.Frame3d units globalCoordinates localCoordinates -> LineSegment3d.LineSegment3d units globalCoordinates -> LineSegment3d.LineSegment3d units localCoordinates"},{"name":"reverse","comment":" Reverse a line segment, swapping its start and end points.\r\n\r\n    LineSegment3d.reverse exampleLineSegment\r\n    --> LineSegment3d.fromEndpoints\r\n    -->     ( Point3d.fromCoordinates ( 4, 5, 6 )\r\n    -->     , Point3d.fromCoordinates ( 1, 2, 3 )\r\n    -->     )\r\n\r\n","type":"LineSegment3d.LineSegment3d units coordinates -> LineSegment3d.LineSegment3d units coordinates"},{"name":"rotateAround","comment":" Rotate a line segment around a given axis by a given angle (in radians).\r\n\r\n    exampleLineSegment\r\n        |> LineSegment3d.rotateAround Axis3d.z (degrees 90)\r\n    --> LineSegment3d.fromEndpoints\r\n    -->     ( Point3d.fromCoordinates ( -2, 1, 3 )\r\n    -->     , Point3d.fromCoordinates ( -5, 4, 6 )\r\n    -->     )\r\n\r\n","type":"Axis3d.Axis3d units coordinates -> Angle.Angle -> LineSegment3d.LineSegment3d units coordinates -> LineSegment3d.LineSegment3d units coordinates"},{"name":"scaleAbout","comment":" Scale a line segment about the given center point by the given scale.\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 1, 1, 1 )\r\n\r\n    LineSegment3d.scaleAbout point 2 exampleLineSegment\r\n    --> LineSegment3d.fromEndpoints\r\n    -->     ( Point3d.fromCoordinates ( 1, 3, 5 )\r\n    -->     , Point3d.fromCoordinates ( 7, 9, 11 )\r\n    -->     )\r\n\r\n","type":"Point3d.Point3d units coordinates -> Basics.Float -> LineSegment3d.LineSegment3d units coordinates -> LineSegment3d.LineSegment3d units coordinates"},{"name":"squaredLength","comment":" Get the squared length of a line segment. Slightly more efficient than\r\n`length` since it avoids a square root.\r\n\r\n    LineSegment3d.squaredLength exampleLineSegment\r\n    --> 27\r\n\r\n","type":"LineSegment3d.LineSegment3d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Squared units)"},{"name":"startPoint","comment":" Get the start point of a line segment.\r\n\r\n    LineSegment3d.startPoint exampleLineSegment\r\n    --> Point3d.fromCoordinates ( 1, 2, 3 )\r\n\r\n","type":"LineSegment3d.LineSegment3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"translateBy","comment":" Translate a line segment by a given displacement.\r\n\r\n    displacement =\r\n        Vector3d.fromComponents ( 1, 2, 3 )\r\n\r\n    exampleLineSegment\r\n        |> LineSegment3d.translateBy displacement\r\n    --> LineSegment3d.fromEndpoints\r\n    -->     ( Point3d.fromCoordinates ( 2, 4, 6 )\r\n    -->     , Point3d.fromCoordinates ( 5, 7, 9 )\r\n    -->     )\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> LineSegment3d.LineSegment3d units coordinates -> LineSegment3d.LineSegment3d units coordinates"},{"name":"translateIn","comment":" Translate a line segment in a given direction by a given distance;\r\n\r\n    LineSegment3d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    LineSegment3d.translateBy\r\n        (Vector3d.withLength distance direction)\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Quantity.Quantity Basics.Float units -> LineSegment3d.LineSegment3d units coordinates -> LineSegment3d.LineSegment3d units coordinates"},{"name":"vector","comment":" Get the vector from a line segment's start point to its end point.\r\n\r\n    LineSegment3d.vector exampleLineSegment\r\n    --> Vector3d.fromComponents ( 2, 2, 2 )\r\n\r\n","type":"LineSegment3d.LineSegment3d units coordinates -> Vector3d.Vector3d units coordinates"}],"binops":[]},{"name":"Plane3d","comment":" A `Plane3d` is an infinite flat plane in 3D. It is defined by an origin\r\npoint and normal direction and is useful for several operations including:\r\n\r\n  - Mirroring across the plane\r\n  - Projecting onto the plane\r\n  - Measuring distance from the plane\r\n\r\n@docs Plane3d\r\n\r\n\r\n# Constants\r\n\r\n@docs xy, yz, zx\r\n\r\n\r\n# Constructors\r\n\r\n@docs through, withNormalDirection, throughPoints\r\n\r\n\r\n# Properties\r\n\r\n@docs originPoint, normalDirection, normalAxis\r\n\r\n\r\n# Transformations\r\n\r\n@docs offsetBy, reverseNormal, rotateAround, translateBy, translateIn, moveTo, mirrorAcross\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n","unions":[],"aliases":[{"name":"Plane3d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Plane3d units coordinates"}],"values":[{"name":"mirrorAcross","comment":" Mirror one plane across another. The plane to mirror across is given first\r\nand the plane to mirror is given second.\r\n\r\n    plane =\r\n        Plane3d.withNormalDirection Direction3d.z\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    Plane3d.mirrorAcross Plane3d.xy plane\r\n    --> Plane3d.withNormalDirection Direction3d.negativeZ\r\n    -->     (Point3d.fromCoordinates ( 1, 2, -3 ))\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> Plane3d.Plane3d units coordinates -> Plane3d.Plane3d units coordinates"},{"name":"moveTo","comment":" Move a plane so that it has the given origin point but unchanged normal\r\ndirection.\r\n\r\n    newOrigin =\r\n        Point3d.fromCoordinates ( 1, 2, 3 )\r\n\r\n    Plane3d.moveTo newOrigin Plane3d.xy\r\n    --> Plane3d.through newOrigin Direction3d.z\r\n\r\n","type":"Point3d.Point3d units coordinates -> Plane3d.Plane3d units coordinates -> Plane3d.Plane3d units coordinates"},{"name":"normalAxis","comment":" Construct an axis from the origin point and normal direction of a plane.\r\n\r\n    Plane3d.normalAxis Plane3d.zx\r\n    --> Axis3d.y\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> Axis3d.Axis3d units coordinates"},{"name":"normalDirection","comment":" Get the normal direction of a plane.\r\n\r\n    Plane3d.normalDirection Plane3d.xy\r\n    --> Direction3d.z\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> Direction3d.Direction3d coordinates"},{"name":"offsetBy","comment":" Shift a plane in its own normal direction by the given (signed) distance.\r\n\r\n    Plane3d.offsetBy 1.0 Plane3d.zx\r\n    --> Plane3d.withNormalDirection Direction3d.y\r\n    -->     (Point3d.fromCoordinates ( 0, 1, 0 ))\r\n\r\n    Plane3d.offsetBy -2.0 Plane3d.xy\r\n    --> Plane3d.withNormalDirection Direction3d.z\r\n    -->     (Point3d.fromCoordinates ( 0, 0, -2 ))\r\n\r\n","type":"Quantity.Quantity Basics.Float units -> Plane3d.Plane3d units coordinates -> Plane3d.Plane3d units coordinates"},{"name":"originPoint","comment":" Get the origin point of a plane.\r\n\r\n    Plane3d.originPoint Plane3d.xy\r\n    --> Point3d.origin\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"placeIn","comment":" Take a plane defined in local coordinates relative to a given reference\r\nframe, and return that plane expressed in global coordinates.\r\n\r\n    referenceFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 1, 1, 1 ))\r\n\r\n    plane =\r\n        Plane3d.withNormalDirection Direction3d.z\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    Plane3d.placeIn referenceFrame plane\r\n    --> Plane3d.withNormalDirection Direction3d.z\r\n    -->     (Point3d.fromCoordinates ( 2, 3, 4 ))\r\n\r\n","type":"Geometry.Types.Frame3d units globalCoordinates localCoordinates -> Plane3d.Plane3d units localCoordinates -> Plane3d.Plane3d units globalCoordinates"},{"name":"relativeTo","comment":" Take a plane defined in global coordinates, and return it expressed in local\r\ncoordinates relative to a given reference frame.\r\n\r\n    referenceFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 1, 1, 1 ))\r\n\r\n    plane =\r\n        Plane3d.withNormalDirection Direction3d.z\r\n            (Point3d.fromCoordinates ( 0, 0, 2 ))\r\n\r\n    Plane3d.relativeTo referenceFrame plane\r\n    --> Plane3d.withNormalDirection Direction3d.z\r\n    -->     (Point3d.fromCoordinates ( -1, -1, 1 ))\r\n\r\n","type":"Geometry.Types.Frame3d units globalCoordinates localCoordinates -> Plane3d.Plane3d units globalCoordinates -> Plane3d.Plane3d units localCoordinates"},{"name":"reverseNormal","comment":" Reverse a plane's normal direction while leaving its origin point unchanged.\r\n\r\n    Plane3d.reverseNormal Plane3d.xy\r\n    --> Plane3d.through Point3d.origin\r\n    -->     Direction3d.negativeZ\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> Plane3d.Plane3d units coordinates"},{"name":"rotateAround","comment":" Rotate a plane around an axis by a given angle.\r\n\r\n    Plane3d.rotateAround Axis3d.y (degrees 90) Plane3d.xy\r\n    --> Plane3d.yz\r\n\r\n","type":"Axis3d.Axis3d units coordinates -> Angle.Angle -> Plane3d.Plane3d units coordinates -> Plane3d.Plane3d units coordinates"},{"name":"through","comment":" Construct a plane through the given point, with the given normal direction.\r\n\r\n    xyPlane =\r\n        Plane3d.through Point3d.origin Direction3d.z\r\n\r\n","type":"Point3d.Point3d units coordinates -> Direction3d.Direction3d coordinates -> Plane3d.Plane3d units coordinates"},{"name":"throughPoints","comment":" Attempt to construct a plane passing through the three given points. The\r\norigin point of the resulting plane will be equal to the first given point, and\r\nthe normal direction will be such that the three given points are in\r\ncounterclockwise order around it according to the right-hand rule. If the three\r\ngiven points are collinear, returns `Nothing`.\r\n\r\n    Plane3d.throughPoints\r\n        (Point3d.fromCoordinates ( 2, 0, 0 ))\r\n        (Point3d.fromCoordinates ( 3, 0, 0 ))\r\n        (Point3d.fromCoordinates ( 4, 1, 1 ))\r\n    --> Just\r\n    -->     (Plane3d.through\r\n    -->         (Point3d.fromCoordinates ( 2, 0, 0 ))\r\n    -->         (Direction3d.fromAzimuthAndElevation\r\n    -->             (degrees -90)\r\n    -->             (degrees 45)\r\n    -->         )\r\n    -->     )\r\n\r\n    Plane3d.throughPoints\r\n        (Point3d.fromCoordinates ( 2, 0, 0 ))\r\n        (Point3d.fromCoordinates ( 3, 0, 0 ))\r\n        (Point3d.fromCoordinates ( 4, 0, 0 ))\r\n    --> Nothing\r\n\r\n","type":"Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> Maybe.Maybe (Plane3d.Plane3d units coordinates)"},{"name":"translateBy","comment":" Translate a plane by a given displacement. Applies the given displacement to\r\nthe plane's origin point and leaves its normal direction unchanged.\r\n\r\n    plane =\r\n        Plane3d.withNormalDirection Direction3d.z\r\n            (Point3d.fromCoordinates ( 1, 1, 1 ))\r\n\r\n    displacement =\r\n        Vector3d.fromComponents ( 1, 2, 3 )\r\n\r\n    Plane3d.translateBy displacement plane\r\n    --> Plane3d.withNormalDirection Direction3d.z\r\n    -->     (Point3d.fromCoordinates ( 2, 3, 4 ))\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Plane3d.Plane3d units coordinates -> Plane3d.Plane3d units coordinates"},{"name":"translateIn","comment":" Translate a plane in a given direction by a given distance;\r\n\r\n    Plane3d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    Plane3d.translateBy\r\n        (Vector3d.withLength distance direction)\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Quantity.Quantity Basics.Float units -> Plane3d.Plane3d units coordinates -> Plane3d.Plane3d units coordinates"},{"name":"withNormalDirection","comment":" Construct a plane with the given normal direction, through the given point.\r\nFlipped version of `through`.\r\n\r\n    plane =\r\n        Plane3d.withNormalDirection Direction3d.y\r\n            (Point3d.fromCoordinates ( 2, 1, 3 ))\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Point3d.Point3d units coordinates -> Plane3d.Plane3d units coordinates"},{"name":"xy","comment":" The global XY plane, centered at the origin with a normal in the positive Z\r\ndirection.\r\n\r\n    Plane3d.xy\r\n    --> Plane3d.through Point3d.origin Direction3d.z\r\n\r\n","type":"Plane3d.Plane3d units coordinates"},{"name":"yz","comment":" The global YZ plane, centered at the origin with a normal in the positive X\r\ndirection.\r\n\r\n    Plane3d.yz\r\n    --> Plane3d.through Point3d.origin Direction3d.x\r\n\r\n","type":"Plane3d.Plane3d units coordinates"},{"name":"zx","comment":" The global ZX plane, centered at the origin with a normal in the positive Y\r\ndirection.\r\n\r\n    Plane3d.zx\r\n    --> through Point3d.origin Direction3d.y\r\n\r\n","type":"Plane3d.Plane3d units coordinates"}],"binops":[]},{"name":"Point2d","comment":" A `Point2d` represents a position in 2D space and is defined by its X and Y\r\ncoordinates. This module contains a variety of point-related functionality, such\r\nas\r\n\r\n  - Measuring distance between points\r\n  - Scaling, rotating, translating, mirroring and projecting points\r\n  - Converting points between different coordinate systems\r\n\r\nPoints are distinct from vectors but interact with them in well-defined ways;\r\nyou can translate a point by a vector to result in a new point, or you can\r\ncompute the vector from one point to another, but you cannot 'add' two points\r\nlike you can add two vectors.\r\n\r\n@docs Point2d\r\n\r\n\r\n# Constants\r\n\r\n@docs origin\r\n\r\n\r\n# Constructors\r\n\r\n@docs fromCoordinates, fromCoordinatesIn, fromPolarCoordinates, fromPolarCoordinatesIn, midpoint, centroid, interpolateFrom, along, circumcenter\r\n\r\n\r\n# Interop\r\n\r\nThese functions are useful for interoperability with other Elm code that uses\r\nplain `Float` tuples or records to represent points. The resulting `Point2d`\r\nvalues will have [unitless](https://package.elm-lang.org/packages/ianmackenzie/elm-units/latest/Quantity#unitless-quantities)\r\ncoordinates.\r\n\r\n@docs fromTuple, toTuple, fromRecord, toRecord\r\n\r\n\r\n# Unit conversion\r\n\r\n@docs at, at_\r\n\r\n\r\n# Properties\r\n\r\n@docs coordinates, coordinatesIn, xCoordinate, yCoordinate, polarCoordinates\r\n\r\n\r\n# Comparison\r\n\r\n@docs equalWithin, lexicographicComparison\r\n\r\n\r\n# Measurement\r\n\r\n@docs distanceFrom, squaredDistanceFrom, signedDistanceAlong, signedDistanceFrom\r\n\r\n\r\n# Transformations\r\n\r\n@docs scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross, projectOnto\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n","unions":[],"aliases":[{"name":"Point2d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Point2d units coordinates"}],"values":[{"name":"along","comment":" Construct a point along an axis at a particular distance from the axis'\r\norigin point.\r\n\r\n    Point2d.along Axis2d.y 3\r\n    --> Point2d.fromCoordinates ( 0, 3 )\r\n\r\nPositive and negative distances will be interpreted relative to the direction of\r\nthe axis:\r\n\r\n    horizontalAxis =\r\n        Axis2d.withDirection Direction2d.negativeX\r\n            (Point2d.fromCoordinates ( 1, 1 ))\r\n\r\n    Point2d.along horizontalAxis 3\r\n    --> Point2d.fromCoordinates ( -2, 1 )\r\n\r\n    Point2d.along horizontalAxis -3\r\n    --> Point2d.fromCoordinates ( 4, 1 )\r\n\r\n","type":"Geometry.Types.Axis2d units coordinates -> Quantity.Quantity Basics.Float units -> Point2d.Point2d units coordinates"},{"name":"at","comment":" Convert a point from one units type to another, by providing a conversion factor given as a\r\nrate of change of destination units with respect to source units.\r\n\r\n    worldPoint =\r\n        Point2d.fromCoordinates\r\n            ( Length.meters 2\r\n            , Length.meters 3\r\n            )\r\n\r\n    resolution : Quantity Float (Rate Pixels Meters)\r\n    resolution =\r\n        Pixels.pixels 100 |> Quantity.per (Length.meters 1)\r\n\r\n    worldPoint |> Point2d.at resolution\r\n    --> Point2d.fromCoordinates\r\n    -->     ( Pixels.pixels 200\r\n    -->     , Pixels.pixels 300\r\n    -->     )\r\n\r\n","type":"Quantity.Quantity Basics.Float (Quantity.Rate destinationUnits sourceUnits) -> Point2d.Point2d sourceUnits coordinates -> Point2d.Point2d destinationUnits coordinates"},{"name":"at_","comment":" Convert a point from one units type to another, by providing an 'inverse' conversion factor\r\ngiven as a rate of change of source units with respect to destination units.\r\n\r\n    screenPoint =\r\n        Point2d.fromCoordinates\r\n            ( Pixels.pixels 200\r\n            , Pixels.pixels 300\r\n            )\r\n\r\n    resolution : Quantity Float (Rate Pixels Meters)\r\n    resolution =\r\n        Pixels.pixels 50 |> Quantity.per (Length.meters 1)\r\n\r\n    screenPoint |> Point2d.at_ resolution\r\n    --> Point2d.fromCoordinates\r\n    -->     ( Length.meters 4\r\n    -->     , Length.meters 6\r\n    -->     )\r\n\r\n","type":"Quantity.Quantity Basics.Float (Quantity.Rate sourceUnits destinationUnits) -> Point2d.Point2d sourceUnits coordinates -> Point2d.Point2d destinationUnits coordinates"},{"name":"centroid","comment":" Find the centroid of a list of points. Returns `Nothing` if the list is\r\nempty.\r\n\r\n    p0 =\r\n        Point2d.origin\r\n\r\n    p1 =\r\n        Point2d.fromCoordinates ( 1, 0 )\r\n\r\n    p2 =\r\n        Point2d.fromCoordinates ( 1, 1 )\r\n\r\n    Point2d.centroid [ p0, p1, p2 ]\r\n    --> Just (Point2d.fromCoordinates ( 0.6667, 0.3333 ))\r\n\r\n","type":"List.List (Point2d.Point2d units coordinates) -> Maybe.Maybe (Point2d.Point2d units coordinates)"},{"name":"circumcenter","comment":" Attempt to find the circumcenter of three points; this is the center of the\r\ncircle that passes through all three points. If the three given points are\r\ncollinear, returns `Nothing`.\r\n\r\n    Point2d.circumcenter\r\n        ( Point2d.origin\r\n        , Point2d.fromCoordinates ( 1, 0 )\r\n        , Point2d.fromCoordinates ( 0, 1 )\r\n        )\r\n    --> Just (Point2d.fromCoordinates ( 0.5, 0.5 ))\r\n\r\n    Point2d.circumcenter\r\n        ( Point2d.origin\r\n        , Point2d.fromCoordinates ( 2, 1 )\r\n        , Point2d.fromCoordinates ( 4, 0 )\r\n        )\r\n    --> Just (Point2d.fromCoordinates ( 2, -1.5 ))\r\n\r\n    Point2d.circumCenter\r\n        ( Point2d.origin\r\n        , Point2d.fromCoordinates ( 2, 0 )\r\n        , Point2d.fromCoordinates ( 4, 0 )\r\n        )\r\n    --> Nothing\r\n\r\n    Point2d.circumCenter\r\n        ( Point2d.origin\r\n        , Point2d.origin\r\n        , Point2d.fromCoordinates ( 1, 0 )\r\n        )\r\n    --> Nothing\r\n\r\n","type":"Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> Maybe.Maybe (Point2d.Point2d units coordinates)"},{"name":"coordinates","comment":" Get the coordinates of a point as a tuple.\r\n\r\n    ( x, y ) =\r\n        Point2d.coordinates point\r\n\r\n","type":"Point2d.Point2d units coordinates -> ( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units )"},{"name":"coordinatesIn","comment":" Get the coordinates of a point within a given frame.\r\n\r\n    point =\r\n        Point2d.fromCoordinates\r\n            ( Length.centimeters 2\r\n            , Length.centimeters 0\r\n            )\r\n\r\n    rotatedFrame =\r\n        Frame2d.atOrigin\r\n            |> Frame2d.rotateBy (Angle.degrees 45)\r\n\r\n    point |> Point2d.coordinatesIn rotatedFrame\r\n    --> ( Length.centimeters 1.4142\r\n    --> , Length.centimeters -1.4142\r\n    --> )\r\n\r\n","type":"Geometry.Types.Frame2d units globalCoordinates localCoordinates -> Point2d.Point2d units globalCoordinates -> ( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units )"},{"name":"distanceFrom","comment":" Find the distance from the first point to the second.\r\n\r\n    p1 =\r\n        Point2d.fromCoordinates ( 2, 3 )\r\n\r\n    p2 =\r\n        Point2d.fromCoordinates ( 5, 7 )\r\n\r\n    Point2d.distanceFrom p1 p2\r\n    --> 5\r\n\r\nPartial application can be useful:\r\n\r\n    points =\r\n        [ Point2d.fromCoordinates ( 3, 4 )\r\n        , Point2d.fromCoordinates ( 10, 0 )\r\n        , Point2d.fromCoordinates ( -1, 2 )\r\n        ]\r\n\r\n    points\r\n        |> List.sortBy\r\n            (Point2d.distanceFrom Point2d.origin)\r\n    --> [ Point2d.fromCoordinates ( -1, 2 )\r\n    --> , Point2d.fromCoordinates ( 3, 4 )\r\n    --> , Point2d.fromCoordinates ( 10, 0 )\r\n    --> ]\r\n\r\n","type":"Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"equalWithin","comment":" Compare two points within a tolerance. Returns true if the distance\r\nbetween the two given points is less than the given tolerance.\r\n\r\n    firstPoint =\r\n        Point2d.fromCoordinates ( 1, 2 )\r\n\r\n    secondPoint =\r\n        Point2d.fromCoordinates ( 0.9999, 2.0002 )\r\n\r\n    Point2d.equalWithin 1e-3 firstPoint secondPoint\r\n    --> True\r\n\r\n    Point2d.equalWithin 1e-6 firstPoint secondPoint\r\n    --> False\r\n\r\n","type":"Quantity.Quantity Basics.Float units -> Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> Basics.Bool"},{"name":"fromCoordinates","comment":" Construct a point from its X and Y coordinates.\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 2, 3 )\r\n\r\n","type":"( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units ) -> Point2d.Point2d units coordinates"},{"name":"fromCoordinatesIn","comment":" Construct a point given its local coordinates within a particular frame:\r\n\r\n    rotatedFrame =\r\n        Frame2d.atOrigin |> Frame2d.rotateBy (degrees 45)\r\n\r\n    Point2d.fromCoordinatesIn rotatedFrame ( 2, 0 )\r\n    --> Point2d.fromCoordinates ( 1.4142, 1.4142 )\r\n\r\n","type":"Geometry.Types.Frame2d units globalCoordinates localCoordinates -> ( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units ) -> Point2d.Point2d units globalCoordinates"},{"name":"fromPolarCoordinates","comment":" Construct a point from a radius and angle. Radius is measured from the\r\norigin and angle is measured counterclockwise from the positive X direction.\r\n\r\n    Point2d.fromPolarCoordinates ( 2, degrees 135 )\r\n    --> Point2d.fromCoordinates ( -1.4142, 1.4142 )\r\n\r\n","type":"( Quantity.Quantity Basics.Float units, Angle.Angle ) -> Point2d.Point2d units coordinates"},{"name":"fromPolarCoordinatesIn","comment":" Construct a point given its local polar coordinates within a particular\r\nframe:\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 2, 1 ))\r\n\r\n    Point2d.fromPolarCoordinatesIn localFrame\r\n        ( 2, degrees 45 )\r\n    --> Point2d.fromCoordinates ( 3.4142, 2.4142 )\r\n\r\n","type":"Geometry.Types.Frame2d units globalCoordinates localCoordinates -> ( Quantity.Quantity Basics.Float units, Angle.Angle ) -> Point2d.Point2d units globalCoordinates"},{"name":"fromRecord","comment":" Construct a unitless `Point2d` from a record with `Float` fields.\r\n\r\n    Point2d.fromRecord { x = 2, y = 3 }\r\n    --> Point2d.fromCoordinates\r\n    -->     ( Quantity.float 2\r\n    -->     , Quantity.float 3\r\n    -- >    )\r\n\r\n","type":"{ x : Basics.Float, y : Basics.Float } -> Point2d.Point2d Quantity.Unitless coordinates"},{"name":"fromTuple","comment":" Construct a unitless `Point2d` from a tuple of `Float` values.\r\n\r\n    Point2d.fromTuple ( 2, 3 )\r\n    --> Point2d.fromCoordinates\r\n    -->     ( Quantity.float 2\r\n    -->     , Quantity.float 3\r\n    -- >    )\r\n\r\n","type":"( Basics.Float, Basics.Float ) -> Point2d.Point2d Quantity.Unitless coordinates"},{"name":"interpolateFrom","comment":" Construct a point by interpolating from the first given point to the second,\r\nbased on a parameter that ranges from zero to one.\r\n\r\n    startPoint =\r\n        Point2d.origin\r\n\r\n    endPoint =\r\n        Point2d.fromCoordinates ( 8, 12 )\r\n\r\n    Point2d.interpolateFrom startPoint endPoint 0.25\r\n    --> Point2d.fromCoordinates ( 2, 3 )\r\n\r\nPartial application may be useful:\r\n\r\n    interpolatedPoint : Float -> Point2d\r\n    interpolatedPoint =\r\n        Point2d.interpolateFrom startPoint endPoint\r\n\r\n    List.map interpolatedPoint [ 0, 0.5, 1 ]\r\n    --> [ Point2d.fromCoordinates ( 0, 0 )\r\n    --> , Point2d.fromCoordinates ( 4, 6 )\r\n    --> , Point2d.fromCoordinates ( 8, 12 )\r\n    --> ]\r\n\r\nYou can pass values less than zero or greater than one to extrapolate:\r\n\r\n    interpolatedPoint -0.5\r\n    --> Point2d.fromCoordinates ( -4, -6 )\r\n\r\n    interpolatedPoint 1.25\r\n    --> Point2d.fromCoordinates ( 10, 15 )\r\n\r\n","type":"Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> Basics.Float -> Point2d.Point2d units coordinates"},{"name":"lexicographicComparison","comment":" Compare two `Point2d` values lexicographically: first by X coordinate, then\r\nby Y. Can be used to provide a sort order for `Point2d` values.\r\n","type":"Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> Basics.Order"},{"name":"midpoint","comment":" Construct a point halfway between two other points.\r\n\r\n    p1 =\r\n        Point2d.fromCoordinates ( 1, 1 )\r\n\r\n    p2 =\r\n        Point2d.fromCoordinates ( 3, 7 )\r\n\r\n    Point2d.midpoint p1 p2\r\n    --> Point2d.fromCoordinates ( 2, 4 )\r\n\r\n","type":"Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"mirrorAcross","comment":" Mirror a point across an axis. The result will be the same distance from the\r\naxis but on the opposite side.\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 2, 3 )\r\n\r\n    Point2d.mirrorAcross Axis2d.x point\r\n    --> Point2d.fromCoordinates ( 2, -3 )\r\n\r\n    Point2d.mirrorAcross Axis2d.y point\r\n    --> Point2d.fromCoordinates ( -2, 3 )\r\n\r\n","type":"Geometry.Types.Axis2d units coordinates -> Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"origin","comment":" The point (0, 0).\r\n\r\n    Point2d.origin\r\n    --> Point2d.fromCoordinates ( 0, 0 )\r\n\r\n","type":"Point2d.Point2d units coordinates"},{"name":"placeIn","comment":" Take a point defined in local coordinates relative to a given reference\r\nframe, and return that point expressed in global coordinates.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    Point2d.placeIn localFrame\r\n        (Point2d.fromCoordinates ( 3, 3 ))\r\n    --> Point2d.fromCoordinates ( 4, 5 )\r\n\r\n    Point2d.placeIn localFrame\r\n        (Point2d.fromCoordinates ( 0, 1 ))\r\n    --> Point2d.fromCoordinates ( 1, 1 )\r\n\r\n","type":"Geometry.Types.Frame2d units globalCoordinates localCoordinates -> Point2d.Point2d units localCoordinates -> Point2d.Point2d units globalCoordinates"},{"name":"polarCoordinates","comment":" Get the polar coordinates (radius and polar angle) of a point.\r\n\r\n    Point2d.polarCoordinates\r\n        (Point2d.fromCoordinates ( 1, 1 ))\r\n    --> ( 1.4142, degrees 45 )\r\n\r\n","type":"Point2d.Point2d units coordinates -> ( Quantity.Quantity Basics.Float units, Angle.Angle )"},{"name":"projectOnto","comment":" Project a point perpendicularly onto an axis.\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 2, 3 )\r\n\r\n    Point2d.projectOnto Axis2d.x point\r\n    --> Point2d.fromCoordinates ( 2, 0 )\r\n\r\n    Point2d.projectOnto Axis2d.y point\r\n    --> Point2d.fromCoordinates ( 0, 3 )\r\n\r\nThe axis does not have to pass through the origin:\r\n\r\n    offsetYAxis =\r\n        Axis2d.withDirection Direction2d.y\r\n            (Point2d.fromCoordinates ( 1, 0 ))\r\n\r\n    Point2d.projectOnto offsetYAxis point\r\n    --> Point2d.fromCoordinates ( 1, 3 )\r\n\r\n","type":"Geometry.Types.Axis2d units coordinates -> Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"relativeTo","comment":" Take a point defined in global coordinates, and return it expressed in local\r\ncoordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    Point2d.relativeTo localFrame\r\n        (Point2d.fromCoordinates ( 4, 5 ))\r\n    --> Point2d.fromCoordinates ( 3, 3 )\r\n\r\n    Point2d.relativeTo localFrame\r\n        (Point2d.fromCoordinates ( 1, 1 ))\r\n    --> Point2d.fromCoordinates ( 0, -1 )\r\n\r\n","type":"Geometry.Types.Frame2d units globalCoordinates localCoordinates -> Point2d.Point2d units globalCoordinates -> Point2d.Point2d units localCoordinates"},{"name":"rotateAround","comment":" Rotate around a given center point counterclockwise by a given angle (in\r\nradians). The point to rotate around is given first and the point to rotate is\r\ngiven last.\r\n\r\n    centerPoint =\r\n        Point2d.fromCoordinates ( 2, 0 )\r\n\r\n    angle =\r\n        degrees 45\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 3, 0 )\r\n\r\n    Point2d.rotateAround centerPoint angle point\r\n    --> Point2d.fromCoordinates ( 2.7071, 0.7071 )\r\n\r\n","type":"Point2d.Point2d units coordinates -> Angle.Angle -> Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"scaleAbout","comment":" Perform a uniform scaling about the given center point. The center point is\r\ngiven first and the point to transform is given last. Points will contract or\r\nexpand about the center point by the given scale. Scaling by a factor of 1 is a\r\nno-op, and scaling by a factor of 0 collapses all points to the center point.\r\n\r\n    centerPoint =\r\n        Point2d.fromCoordinates ( 1, 1 )\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 2, 3 )\r\n\r\n    Point2d.scaleAbout centerPoint 3 point\r\n    --> Point2d.fromCoordinates ( 4, 7 )\r\n\r\n    Point2d.scaleAbout centerPoint 0.5 point\r\n    --> Point2d.fromCoordinates ( 1.5, 2 )\r\n\r\nAvoid scaling by a negative scaling factor - while this may sometimes do what\r\nyou want it is confusing and error prone. Try a combination of mirror and/or\r\nrotation operations instead.\r\n\r\n","type":"Point2d.Point2d units coordinates -> Basics.Float -> Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"signedDistanceAlong","comment":" Determine how far along an axis a particular point lies. Conceptually, the\r\npoint is projected perpendicularly onto the axis, and then the distance of this\r\nprojected point from the axis' origin point is measured. The result will be\r\npositive if the projected point is ahead the axis' origin point and negative if\r\nit is behind, with 'ahead' and 'behind' defined by the direction of the axis.\r\n\r\n    axis =\r\n        Axis2d.withDirection Direction2d.x\r\n            (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 3, 3 )\r\n\r\n    Point2d.signedDistanceAlong axis point\r\n    --> 2\r\n\r\n    Point2d.signedDistanceAlong axis Point2d.origin\r\n    --> -1\r\n\r\n","type":"Geometry.Types.Axis2d units coordinates -> Point2d.Point2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"signedDistanceFrom","comment":" Find the perpendicular distance of a point from an axis. The result\r\nwill be positive if the point is to the left of the axis and negative if it is\r\nto the right, with the forwards direction defined by the direction of the axis.\r\n\r\n    -- A horizontal axis through a point with a Y\r\n    -- coordinate of 2 is effectively the line Y=2\r\n    axis =\r\n        Axis2d.withDirection Direction2d.x\r\n            (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 3, 3 )\r\n\r\n    -- Since the axis is in the positive X direction,\r\n    -- points above the axis are to the left (positive)\r\n    Point2d.signedDistanceFrom axis point\r\n    -->  1\r\n\r\n    -- and points below are to the right (negative)\r\n    Point2d.signedDistanceFrom axis Point2d.origin\r\n    --> -2\r\n\r\nThis means that reversing an axis will also flip the sign of the result of this\r\nfunction:\r\n\r\n    -- Reversing an axis reverses its direction\r\n    reversedAxis =\r\n        Axis2d.reverse axis\r\n\r\n    Point2d.signedDistanceFrom reversedAxis point\r\n    --> -1\r\n\r\n    Point2d.signedDistanceFrom reversedAxis Point2d.origin\r\n    --> 2\r\n\r\n","type":"Geometry.Types.Axis2d units coordinates -> Point2d.Point2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"squaredDistanceFrom","comment":" Find the square of the distance from one point to another.\r\n`squaredDistanceFrom` is slightly faster than `distanceFrom`, so for example\r\n\r\n    Point2d.squaredDistanceFrom p1 p2\r\n        > (tolerance * tolerance)\r\n\r\nis equivalent to but slightly more efficient than\r\n\r\n    Point2d.distanceFrom p1 p2 > tolerance\r\n\r\nsince the latter requires a square root under the hood. In many cases, however,\r\nthe speed difference will be negligible and using `distanceFrom` is much more\r\nreadable!\r\n\r\n","type":"Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Squared units)"},{"name":"toRecord","comment":" Convert a unitless `Point2d` to a record with `Float` fields.\r\n\r\n    point =\r\n        Point2d.fromCoordinates\r\n            ( Quantity.float 2\r\n            , Quantity.float 3\r\n            )\r\n\r\n    Point2d.toRecord point\r\n    --> { x = 2, y = 3 }\r\n\r\n","type":"Point2d.Point2d Quantity.Unitless coordinates -> { x : Basics.Float, y : Basics.Float }"},{"name":"toTuple","comment":" Convert a unitless `Point2d` to a tuple of `Float` values.\r\n\r\n    point =\r\n        Point2d.fromCoordinates\r\n            ( Quantity.float 2\r\n            , Quantity.float 3\r\n            )\r\n\r\n    Point2d.toTuple point\r\n    --> ( 2, 3 )\r\n\r\n","type":"Point2d.Point2d Quantity.Unitless coordinates -> ( Basics.Float, Basics.Float )"},{"name":"translateBy","comment":" Translate a point by a given displacement.\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 3, 4 )\r\n\r\n    displacement =\r\n        Vector2d.fromComponents ( 1, 2 )\r\n\r\n    Point2d.translateBy displacement point\r\n    --> Point2d.fromCoordinates ( 4, 6 )\r\n\r\nIn more mathematical terms, this is 'point plus vector'. For 'point minus point'\r\n(giving the vector from one point to another), there is [`Vector2d.from`](Vector2d#from).\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"translateIn","comment":" Translate a point in a given direction by a given distance.\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 3, 4 )\r\n\r\n    point |> Point2d.translateIn Direction2d.x 2\r\n    --> Point2d.fromCoordinates ( 5, 4 )\r\n\r\n    point |> Point2d.translateIn Direction2d.y 2\r\n    --> Point2d.fromCoordinates ( 3, 6 )\r\n\r\n    angledDirection =\r\n        Direction2d.fromAngle (degrees 45)\r\n\r\n    point |> Point2d.translateIn angledDirection 1\r\n    --> Point2d.fromCoordinates ( 3.7071, 4.7071 )\r\n\r\nThe distance can be negative:\r\n\r\n    Point2d.translateIn Direction2d.x -2\r\n    --> Point2d.fromCoordinates ( 1, 4 )\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Quantity.Quantity Basics.Float units -> Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"xCoordinate","comment":" Get the X coordinate of a point.\r\n\r\n    Point2d.xCoordinate (Point2d.fromCoordinates ( 2, 3 ))\r\n    --> 2\r\n\r\n","type":"Point2d.Point2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"yCoordinate","comment":" Get the Y coordinate of a point.\r\n\r\n    Point2d.yCoordinate (Point2d.fromCoordinates ( 2, 3 ))\r\n    --> 3\r\n\r\n","type":"Point2d.Point2d units coordinates -> Quantity.Quantity Basics.Float units"}],"binops":[]},{"name":"Point3d","comment":" A `Point3d` represents a position in 3D space and is defined by its X, Y and\r\nZ coordinates. This module contains a variety of point-related functionality,\r\nsuch as\r\n\r\n  - Measuring distance between points, or the distance of a point from an axis\r\n    or a plane\r\n  - Scaling, rotating, translating, mirroring and projecting points\r\n  - Converting points between different coordinate systems\r\n\r\nPoints are distinct from vectors but interact with them in well-defined ways;\r\nyou can translate a point by a vector to result in a new point, or you can\r\ncompute the vector from one point to another, but you cannot 'add' two points\r\nlike you can add two vectors.\r\n\r\n@docs Point3d\r\n\r\n\r\n# Constants\r\n\r\n@docs origin\r\n\r\n\r\n# Constructors\r\n\r\n@docs fromCoordinates, fromCoordinatesIn, midpoint, centroid, interpolateFrom, along, on, circumcenter\r\n\r\n\r\n# Interop\r\n\r\nThese functions are useful for interoperability with other Elm code that uses\r\nplain `Float` tuples or records to represent points. The resulting `Point3d`\r\nvalues will have [unitless](https://package.elm-lang.org/packages/ianmackenzie/elm-units/latest/Quantity#unitless-quantities)\r\ncoordinates.\r\n\r\n@docs fromTuple, toTuple, fromRecord, toRecord\r\n\r\n\r\n# Properties\r\n\r\n@docs coordinates, coordinatesIn, xCoordinate, yCoordinate, zCoordinate\r\n\r\n\r\n# Comparison\r\n\r\n@docs equalWithin, lexicographicComparison\r\n\r\n\r\n# Measurement\r\n\r\n@docs distanceFrom, squaredDistanceFrom, signedDistanceAlong, distanceFromAxis, squaredDistanceFromAxis, signedDistanceFrom\r\n\r\n\r\n# Transformations\r\n\r\n@docs scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross, projectOnto, projectOntoAxis\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn, projectInto\r\n\r\n","unions":[],"aliases":[{"name":"Point3d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Point3d units coordinates"}],"values":[{"name":"along","comment":" Construct a point along an axis at a particular distance from the axis'\r\norigin point.\r\n\r\n    Point3d.along Axis3d.z 2\r\n    --> Point3d.fromCoordinates ( 0, 0, 2 )\r\n\r\nPositive and negative distances are interpreted relative to the direction of the\r\naxis:\r\n\r\n    horizontalAxis =\r\n        Axis3d.withDirection Direction3d.negativeX\r\n            (Point3d.fromCoordinates ( 1, 1, 1 ))\r\n\r\n    Point3d.along horizontalAxis 3\r\n    --> Point3d.fromCoordinates ( -2, 1, 1 )\r\n\r\n    Point3d.along horizontalAxis -3\r\n    --> Point3d.fromCoordinates ( 4, 1, 1 )\r\n\r\n","type":"Geometry.Types.Axis3d units coordinates -> Quantity.Quantity Basics.Float units -> Point3d.Point3d units coordinates"},{"name":"centroid","comment":" Find the centroid of a list of points. Returns `Nothing` if the list is\r\nempty.\r\n\r\n    p0 =\r\n        Point3d.origin\r\n\r\n    p1 =\r\n        Point3d.fromCoordinates ( 1, 0, 1 )\r\n\r\n    p2 =\r\n        Point3d.fromCoordinates ( 0, 1, 1 )\r\n\r\n    Point3d.centroid [ p0, p1, p2 ]\r\n    --> Just (Point3d.fromCoordinates ( 0.3333, 0.3333, 0.6667 ))\r\n\r\n","type":"List.List (Point3d.Point3d units coordinates) -> Maybe.Maybe (Point3d.Point3d units coordinates)"},{"name":"circumcenter","comment":" Attempt to find the circumcenter of three points; this is the center of the\r\ncircle that passes through all three points. If the three given points are\r\ncollinear, returns `Nothing`.\r\n\r\n    Point3d.circumcenter\r\n        (Point3d.fromCoordinates ( 1, 0, 0 ))\r\n        (Point3d.fromCoordinates ( 0, 1, 0 ))\r\n        (Point3d.fromCoordinates ( 0, 0, 1 ))\r\n    --> Just (Point3d.fromCoordinates (0.33, 0.33, 0.33))\r\n\r\n    Point3d.circumcenter\r\n        Point3d.origin\r\n        (Point3d.fromCoordinates ( 1, 0, 0 ))\r\n        (Point3d.fromCoordinates ( 2, 0, 0 ))\r\n    --> Nothing\r\n\r\n","type":"Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> Maybe.Maybe (Point3d.Point3d units coordinates)"},{"name":"coordinates","comment":" Get the coordinates of a point as a tuple.\r\n\r\n    ( x, y, z ) =\r\n        Point3d.coordinates point\r\n\r\n","type":"Point3d.Point3d units coordinates -> ( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units )"},{"name":"coordinatesIn","comment":" Get the coordinates of a point within a given frame.\r\n\r\n    point =\r\n        Point3d.fromCoordinates\r\n            ( Length.meters 2\r\n            , Length.meters 3\r\n            , Length.meters 4\r\n            )\r\n\r\n    frame =\r\n        Frame3d.atCoordinates\r\n            ( Length.meters 1\r\n            , Length.meters 1\r\n            , Length.meters 1\r\n            )\r\n\r\n    point |> Point3d.coordinatesIn frame\r\n    --> ( Length.meters 1\r\n    --> , Length.meters 2\r\n    --> , Length.meters 3\r\n    --> )\r\n\r\n","type":"Geometry.Types.Frame3d units globalCoordinates localCoordinates -> Point3d.Point3d units globalCoordinates -> ( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units )"},{"name":"distanceFrom","comment":" Find the distance from the first point to the second.\r\n\r\n    p1 =\r\n        Point3d.fromCoordinates ( 1, 1, 2 )\r\n\r\n    p2 =\r\n        Point3d.fromCoordinates ( 2, 3, 4 )\r\n\r\n    Point3d.distanceFrom p1 p2\r\n    --> 3\r\n\r\nPartial application can be useful:\r\n\r\n    points =\r\n        [ Point3d.fromCoordinates ( 3, 4, 5 )\r\n        , Point3d.fromCoordinates ( 10, 10, 10 )\r\n        , Point3d.fromCoordinates ( -1, 2, -3 )\r\n        ]\r\n\r\n    points\r\n        |> List.sortBy\r\n            (Point3d.distanceFrom Point3d.origin)\r\n    --> [ Point3d.fromCoordinates ( -1, 2, -3 )\r\n    --> , Point3d.fromCoordinates ( 3, 4, 5 )\r\n    --> , Point3d.fromCoordinates ( 10, 10, 10 )\r\n    --> ]\r\n\r\n","type":"Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"distanceFromAxis","comment":" Find the perpendicular (nearest) distance of a point from an axis.\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( -3, 4, 0 )\r\n\r\n    Point3d.distanceFromAxis Axis3d.x point\r\n    --> 4\r\n\r\n    Point3d.distanceFromAxis Axis3d.y point\r\n    --> 3\r\n\r\n    Point3d.distanceFromAxis Axis3d.z point\r\n    --> 5\r\n\r\nNote that unlike in 2D, the result is always positive (unsigned) since there is\r\nno such thing as the left or right side of an axis in 3D.\r\n\r\n","type":"Geometry.Types.Axis3d units coordinates -> Point3d.Point3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"equalWithin","comment":" Compare two points within a tolerance. Returns true if the distance\r\nbetween the two given points is less than the given tolerance.\r\n\r\n    firstPoint =\r\n        Point3d.fromCoordinates ( 2, 1, 3 )\r\n\r\n    secondPoint =\r\n        Point3d.fromCoordinates ( 2.0002, 0.9999, 3.0001 )\r\n\r\n    Point3d.equalWithin 1e-3 firstPoint secondPoint\r\n    --> True\r\n\r\n    Point3d.equalWithin 1e-6 firstPoint secondPoint\r\n    --> False\r\n\r\n","type":"Quantity.Quantity Basics.Float units -> Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> Basics.Bool"},{"name":"fromCoordinates","comment":" Construct a point from its X, Y and Z coordinates.\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 2, 1, 3 )\r\n\r\n","type":"( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units ) -> Point3d.Point3d units coordinates"},{"name":"fromCoordinatesIn","comment":" Construct a point given its local coordinates within a particular frame:\r\n\r\n    frame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 1, 1, 1 ))\r\n\r\n    Point3d.fromCoordinatesIn frame ( 1, 2, 3 )\r\n    --> Point3d.fromCoordinates ( 2, 3, 4 )\r\n\r\n","type":"Geometry.Types.Frame3d units globalCoordinates localCoordinates -> ( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units ) -> Point3d.Point3d units globalCoordinates"},{"name":"fromRecord","comment":" Construct a unitless `Point3d` from a record with `Float` fields.\r\n\r\n    Point3d.fromRecord { x = 2, y = 1, z = 3 }\r\n    --> Point3d.fromCoordinates\r\n    -->     ( Quantity.float 2\r\n    -->     , Quantity.float 1\r\n    -->     , Quantity.float 3\r\n    -- >    )\r\n\r\n","type":"{ x : Basics.Float, y : Basics.Float, z : Basics.Float } -> Point3d.Point3d Quantity.Unitless coordinates"},{"name":"fromTuple","comment":" Construct a unitless `Point3d` from a tuple of `Float` values.\r\n\r\n    Point3d.fromTuple ( 2, 1, 3 )\r\n    --> Point3d.fromCoordinates\r\n    -->     ( Quantity.float 2\r\n    -->     , Quantity.float 1\r\n    -->     , Quantity.float 3\r\n    -- >    )\r\n\r\n","type":"( Basics.Float, Basics.Float, Basics.Float ) -> Point3d.Point3d Quantity.Unitless coordinates"},{"name":"interpolateFrom","comment":" Construct a point by interpolating from the first given point to the second,\r\nbased on a parameter that ranges from zero to one.\r\n\r\n    startPoint =\r\n        Point3d.fromCoordinates ( 1, 2, 4 )\r\n\r\n    endPoint =\r\n        Point3d.fromCoordinates ( 1, 2, 8 )\r\n\r\n    Point3d.interpolateFrom startPoint endPoint 0.25\r\n    --> Point3d.fromCoordinates ( 1, 2, 5 )\r\n\r\nPartial application may be useful:\r\n\r\n    interpolatedPoint : Float -> Point3d\r\n    interpolatedPoint =\r\n        Point3d.interpolateFrom startPoint endPoint\r\n\r\n    List.map interpolatedPoint [ 0, 0.5, 1 ]\r\n    --> [ Point3d.fromCoordinates ( 1, 2, 4 )\r\n    --> , Point3d.fromCoordinates ( 1, 2, 6 )\r\n    --> , Point3d.fromCoordinates ( 1, 2, 8 )\r\n    --> ]\r\n\r\nYou can pass values less than zero or greater than one to extrapolate:\r\n\r\n    interpolatedPoint -0.5\r\n    --> Point3d.fromCoordinates ( 1, 2, 2 )\r\n\r\n    interpolatedPoint 1.25\r\n    --> Point3d.fromCoordinates ( 1, 2, 9 )\r\n\r\n","type":"Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> Basics.Float -> Point3d.Point3d units coordinates"},{"name":"lexicographicComparison","comment":" Compare two `Point3d` values lexicographically: first by X coordinate, then\r\nby Y, then by Z. Can be used to provide a sort order for `Point3d` values.\r\n","type":"Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> Basics.Order"},{"name":"midpoint","comment":" Construct a point halfway between two other points.\r\n\r\n    p1 =\r\n        Point3d.fromCoordinates ( 1, 1, 1 )\r\n\r\n    p2 =\r\n        Point3d.fromCoordinates ( 3, 7, 9 )\r\n\r\n    Point3d.midpoint p1 p2\r\n    --> Point3d.fromCoordinates ( 2, 4, 5 )\r\n\r\n","type":"Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"mirrorAcross","comment":" Mirror a point across a plane. The result will be the same distance from the\r\nplane but on the opposite side.\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 1, 2, 3 )\r\n\r\n    -- Plane3d.xy is the plane Z=0\r\n    Point3d.mirrorAcross Plane3d.xy point\r\n    --> Point3d.fromCoordinates ( 1, 2, -3 )\r\n\r\n    -- Plane3d.yz is the plane X=0\r\n    Point3d.mirrorAcross Plane3d.yz point\r\n    --> Point3d.fromCoordinates ( -1, 2, 3 )\r\n\r\nThe plane does not have to pass through the origin:\r\n\r\n    -- offsetPlane is the plane Z=1\r\n    offsetPlane =\r\n        Plane3d.offsetBy 1 Plane3d.xy\r\n\r\n    -- The origin point is 1 unit below the offset\r\n    -- plane, so its mirrored copy is one unit above\r\n    Point3d.mirrorAcross offsetPlane Point3d.origin\r\n    --> Point3d.fromCoordinates ( 0, 0, 2 )\r\n\r\n","type":"Geometry.Types.Plane3d units coordinates -> Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"on","comment":" Construct a 3D point lying _on_ a sketch plane by providing a 2D point\r\nspecified in XY coordinates _within_ the sketch plane.\r\n\r\n    Point3d.on SketchPlane3d.xy <|\r\n        Point2d.fromCoordinates ( 2, 1 )\r\n    --> Point3d.fromCoordinates ( 2, 1, 0 )\r\n\r\n    Point3d.on SketchPlane3d.xz <|\r\n        Point2d.fromCoordinates ( 2, 1 )\r\n    --> Point3d.fromCoordinates ( 2, 0, 1 )\r\n\r\nThe sketch plane can have any position and orientation:\r\n\r\n    tiltedSketchPlane =\r\n        SketchPlane3d.xy\r\n            |> SketchPlane3d.rotateAround Axis3d.x\r\n                (degrees 45)\r\n            |> SketchPlane3d.moveTo\r\n                (Point3d.fromCoordinates ( 10, 10, 10 ))\r\n\r\n    Point3d.on tiltedSketchPlane <|\r\n        Point2d.fromCoordinates ( 2, 1 )\r\n    --> Point3d.fromCoordinates ( 12, 10.7071, 10.7071 )\r\n\r\n","type":"Geometry.Types.SketchPlane3d units coordinates3d coordinates2d -> Point2d.Point2d units coordinates2d -> Point3d.Point3d units coordinates3d"},{"name":"origin","comment":" The point (0, 0, 0).\r\n\r\n    Point3d.origin\r\n    --> Point3d.fromCoordinates ( 0, 0, 0 )\r\n\r\n","type":"Point3d.Point3d units coordinates"},{"name":"placeIn","comment":" Take a point defined in local coordinates relative to a given reference\r\nframe, and return that point expressed in global coordinates.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    Point3d.placeIn localFrame\r\n        (Point3d.fromCoordinates ( 3, 3, 3 ))\r\n    --> Point3d.fromCoordinates ( 4, 5, 6 )\r\n\r\n    Point3d.placeIn localFrame\r\n        (Point3d.fromCoordinates ( 0, -1, -2 ))\r\n    --> Point3d.fromCoordinates ( 1, 1, 1 )\r\n\r\n","type":"Geometry.Types.Frame3d units globalCoordinates localCoordinates -> Point3d.Point3d units localCoordinates -> Point3d.Point3d units globalCoordinates"},{"name":"projectInto","comment":" Project a point into a given sketch plane. Conceptually, this finds the\r\n[orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof the point onto the plane and then expresses the projected point in 2D sketch\r\ncoordinates.\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 2, 1, 3 )\r\n\r\n    Point3d.projectInto SketchPlane3d.xy point\r\n    --> Point2d.fromCoordinates ( 2, 1 )\r\n\r\n    Point3d.projectInto SketchPlane3d.yz point\r\n    --> Point2d.fromCoordinates ( 1, 3 )\r\n\r\n    Point3d.projectInto SketchPlane3d.zx point\r\n    --> Point2d.fromCoordinates ( 3, 2 )\r\n\r\n","type":"Geometry.Types.SketchPlane3d units coordinates coordinates2d -> Point3d.Point3d units coordinates -> Point2d.Point2d units coordinates2d"},{"name":"projectOnto","comment":" Find the [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof a point onto a plane:\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 1, 2, 3 )\r\n\r\n    Point3d.projectOnto Plane3d.xy point\r\n    --> Point3d.fromCoordinates ( 1, 2, 0 )\r\n\r\n    Point3d.projectOnto Plane3d.yz point\r\n    --> Point3d.fromCoordinates ( 0, 2, 3 )\r\n\r\nThe plane does not have to pass through the origin:\r\n\r\n    offsetPlane =\r\n        Plane3d.offsetBy 1 Plane3d.xy\r\n\r\n    Point3d.projectOnto offsetPlane point\r\n    --> Point3d.fromCoordinates ( 1, 2, 1 )\r\n\r\n","type":"Geometry.Types.Plane3d units coordinates -> Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"projectOntoAxis","comment":" Project a point perpendicularly onto an axis.\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 1, 2, 3 )\r\n\r\n    Point3d.projectOntoAxis Axis3d.x\r\n    --> Point3d.fromCoordinates ( 1, 0, 0 )\r\n\r\n    verticalAxis =\r\n        Axis3d.withDirection Direction3d.z\r\n            (Point3d.fromCoordinates ( 0, 1, 2 ))\r\n\r\n    Point3d.projectOntoAxis verticalAxis\r\n    --> Point3d.fromCoordinates ( 0, 1, 3 )\r\n\r\n","type":"Geometry.Types.Axis3d units coordinates -> Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"relativeTo","comment":" Take a point defined in global coordinates, and return it expressed in local\r\ncoordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    Point3d.relativeTo localFrame\r\n        (Point3d.fromCoordinates ( 4, 5, 6 ))\r\n    --> Point3d.fromCoordinates ( 3, 3, 3 )\r\n\r\n    Point3d.relativeTo localFrame\r\n        (Point3d.fromCoordinates ( 1, 1, 1 ))\r\n    --> Point3d.fromCoordinates ( 0, -1, -2 )\r\n\r\n","type":"Geometry.Types.Frame3d units globalCoordinates localCoordinates -> Point3d.Point3d units globalCoordinates -> Point3d.Point3d units localCoordinates"},{"name":"rotateAround","comment":" Rotate a point around an axis by a given angle (in radians).\r\n\r\n    axis =\r\n        Axis3d.x\r\n\r\n    angle =\r\n        degrees 45\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 3, 1, 0 )\r\n\r\n    Point3d.rotateAround axis angle point\r\n    --> Point3d.fromCoordinates ( 3, 0.7071, 0.7071 )\r\n\r\nRotation direction is given by the right-hand rule, counterclockwise around the\r\ndirection of the axis.\r\n\r\n","type":"Geometry.Types.Axis3d units coordinates -> Angle.Angle -> Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"scaleAbout","comment":" Perform a uniform scaling about the given center point. The center point is\r\ngiven first and the point to transform is given last. Points will contract or\r\nexpand about the center point by the given scale. Scaling by a factor of 1 is a\r\nno-op, and scaling by a factor of 0 collapses all points to the center point.\r\n\r\n    centerPoint =\r\n        Point3d.fromCoordinates ( 1, 1, 1 )\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 1, 2, 3 )\r\n\r\n    Point3d.scaleAbout centerPoint 3 point\r\n    --> Point3d.fromCoordinates ( 1, 4, 7 )\r\n\r\n    Point3d.scaleAbout centerPoint 0.5 point\r\n    --> Point3d.fromCoordinates ( 1, 1.5, 2 )\r\n\r\nAvoid scaling by a negative scaling factor - while this may sometimes do what\r\nyou want it is confusing and error prone. Try a combination of mirror and/or\r\nrotation operations instead.\r\n\r\n","type":"Point3d.Point3d units coordinates -> Basics.Float -> Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"signedDistanceAlong","comment":" Determine how far along an axis a particular point lies. Conceptually, the\r\npoint is projected perpendicularly onto the axis, and then the distance of this\r\nprojected point from the axis' origin point is measured. The result will be\r\npositive if the projected point is ahead the axis' origin point and negative if\r\nit is behind, with 'ahead' and 'behind' defined by the direction of the axis.\r\n\r\n    axis =\r\n        Axis3d.withDirection Direction3d.x\r\n            (Point3d.fromCoordinates ( 1, 0, 0 ))\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 3, 3, 3 )\r\n\r\n    Point3d.signedDistanceAlong axis point\r\n    --> 2\r\n\r\n    Point3d.signedDistanceAlong axis Point3d.origin\r\n    --> -1\r\n\r\n","type":"Geometry.Types.Axis3d units coordinates -> Point3d.Point3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"signedDistanceFrom","comment":" Find the perpendicular distance of a point from a plane. The result will be\r\npositive if the point is 'above' the plane and negative if it is 'below', with\r\n'up' defined by the normal direction of the plane.\r\n\r\n    plane =\r\n        Plane3d.withNormalDirection Direction3d.y\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 3, 3, 3 )\r\n\r\n    Point3d.signedDistanceFrom plane point\r\n    --> 1\r\n\r\n    Point3d.signedDistanceFrom plane Point3d.origin\r\n    --> -2\r\n\r\nThis means that flipping a plane (reversing its normal direction) will also flip\r\nthe sign of the result of this function:\r\n\r\n    flippedPlane =\r\n        Plane3d.reverseNormal plane\r\n\r\n    Point3d.signedDistanceFrom flippedPlane point\r\n    --> -1\r\n\r\n    Point3d.signedDistanceFrom flippedPlane Point3d.origin\r\n    --> 2\r\n\r\n","type":"Geometry.Types.Plane3d units coordinates -> Point3d.Point3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"squaredDistanceFrom","comment":" Find the square of the distance from one point to another.\r\n`squaredDistanceFrom` is slightly faster than `distanceFrom`, so for example\r\n\r\n    Point3d.squaredDistanceFrom p1 p2\r\n        > (tolerance * tolerance)\r\n\r\nis equivalent to but slightly more efficient than\r\n\r\n    Point3d.distanceFrom p1 p2 > tolerance\r\n\r\nsince the latter requires a square root under the hood. In many cases, however,\r\nthe speed difference will be negligible and using `distanceFrom` is much more\r\nreadable!\r\n\r\n","type":"Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Squared units)"},{"name":"squaredDistanceFromAxis","comment":" Find the square of the perpendicular distance of a point from an axis. As\r\nwith `distanceFrom`/`squaredDistanceFrom` this is slightly more efficient than\r\n`distanceFromAxis` since it avoids a square root.\r\n","type":"Geometry.Types.Axis3d units coordinates -> Point3d.Point3d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Squared units)"},{"name":"toRecord","comment":" Convert a unitless `Point3d` to a record with `Float` fields.\r\n\r\n    point =\r\n        Point3d.fromComponents\r\n            ( Quantity.float 2\r\n            , Quantity.float 1\r\n            , Quantity.float 3\r\n            )\r\n\r\n    Point3d.toRecord point\r\n    --> { x = 2, y = 1, z = 3 }\r\n\r\n","type":"Point3d.Point3d Quantity.Unitless coordinates -> { x : Basics.Float, y : Basics.Float, z : Basics.Float }"},{"name":"toTuple","comment":" Convert a unitless `Point3d` to a tuple of `Float` values.\r\n\r\n    point =\r\n        Point3d.fromCoordinates\r\n            ( Quantity.float 2\r\n            , Quantity.float 1\r\n            , Quantity.float 3\r\n            )\r\n\r\n    Point3d.toTuple point\r\n    --> ( 2, 1, 3 )\r\n\r\n","type":"Point3d.Point3d Quantity.Unitless coordinates -> ( Basics.Float, Basics.Float, Basics.Float )"},{"name":"translateBy","comment":" Translate a point by a given displacement.\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 3, 4, 5 )\r\n\r\n    displacement =\r\n        Vector3d.fromComponents ( 1, 2, 3 )\r\n\r\n    Point3d.translateBy displacement point\r\n    --> Point3d.fromCoordinates ( 4, 6, 8 )\r\n\r\nIn more mathematical terms, this is 'point plus vector'. For 'point minus point'\r\n(giving the vector from one point to another), there is [`Vector3d.from`](Vector3d#from).\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"translateIn","comment":" Translate a point in a given direction by a given distance.\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 3, 4, 5 )\r\n\r\n    point |> Point3d.translateIn Direction3d.x 2\r\n    --> Point3d.fromCoordinates ( 5, 4, 5 )\r\n\r\n    point |> Point3d.translateIn Direction3d.y 2\r\n    --> Point3d.fromCoordinates ( 3, 6, 5 )\r\n\r\nThe distance can be negative:\r\n\r\n    Point3d.translateIn Direction3d.x -2\r\n    --> Point3d.fromCoordinates ( 1, 4, 5 )\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Quantity.Quantity Basics.Float units -> Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"xCoordinate","comment":" Get the X coordinate of a point.\r\n\r\n    Point3d.fromCoordinates ( 2, 1, 3 )\r\n        |> Point3d.xCoordinate\r\n    --> 2\r\n\r\n","type":"Point3d.Point3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"yCoordinate","comment":" Get the Y coordinate of a point.\r\n\r\n    Point3d.fromCoordinates ( 2, 1, 3 )\r\n        |> Point3d.yCoordinate\r\n    --> 1\r\n\r\n","type":"Point3d.Point3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"zCoordinate","comment":" Get the Z coordinate of a point.\r\n\r\n    Point3d.fromCoordinates ( 2, 1, 3 )\r\n        |> Point3d.zCoordinate\r\n    --> 3\r\n\r\n","type":"Point3d.Point3d units coordinates -> Quantity.Quantity Basics.Float units"}],"binops":[]},{"name":"Polygon2d","comment":" A `Polygon2d` represents a closed polygon in 2D, optionally with holes. It\r\nis defined by an outer loop of vertices and a list of inner loops defining any\r\nholes. This module contains a variety of polygon-related functionality, such as\r\n\r\n  - Computing the perimeter and area of polygons\r\n  - Scaling, rotating, translating and mirroring polygons\r\n  - Converting polygons between different coordinate systems\r\n  - Triangulating polygons\r\n\r\n@docs Polygon2d\r\n\r\n\r\n# Constructors\r\n\r\n@docs singleLoop, with, convexHull\r\n\r\n\r\n# Properties\r\n\r\n@docs outerLoop, innerLoops, vertices, edges, perimeter, area, boundingBox\r\n\r\n\r\n# Transformations\r\n\r\nTransforming a polygon is equivalent to transforming each of its vertices.\r\n\r\n@docs scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n\r\n# Triangulation\r\n\r\n@docs triangulate\r\n\r\n","unions":[],"aliases":[{"name":"Polygon2d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Polygon2d units coordinates"}],"values":[{"name":"area","comment":" Get the area of a polygon. This value will never be negative.\r\n\r\n    Polygon2d.area squareWithHole\r\n    --> 8\r\n\r\n","type":"Polygon2d.Polygon2d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Squared units)"},{"name":"boundingBox","comment":" Get the minimal bounding box containing a given polygon. Returns `Nothing`\r\nif the polygon has no vertices.\r\n\r\n    Polygon2d.boundingBox rectangle\r\n    --> Just\r\n    -->     (BoundingBox2d.fromExtrema\r\n    -->         { minX = 1\r\n    -->         , maxX = 3\r\n    -->         , minY = 1\r\n    -->         , maxY = 2\r\n    -->         }\r\n    -->     )\r\n\r\n","type":"Polygon2d.Polygon2d units coordinates -> Maybe.Maybe (BoundingBox2d.BoundingBox2d units coordinates)"},{"name":"convexHull","comment":" Build the [convex hull](https://en.wikipedia.org/wiki/Convex_hull) of a list\r\nof points:\r\n\r\n![Convex hull of a set of points](https://ianmackenzie.github.io/elm-geometry/1.0.0/Polygon2d/convexHull.svg)\r\n\r\nThis is an O(n log n) operation.\r\n\r\n","type":"List.List (Point2d.Point2d units coordinates) -> Polygon2d.Polygon2d units coordinates"},{"name":"edges","comment":" Get all edges of a polygon. This will include both outer edges and inner\r\n(hole) edges.\r\n\r\n    Polygon2d.edges squareWithHole\r\n    --> [ LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 0, 0 )\r\n    -->     , Point2d.fromCoordinates ( 3, 0 )\r\n    -->     )\r\n    --> , LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 3, 0 )\r\n    -->     , Point2d.fromCoordinates ( 3, 3 )\r\n    -->     )\r\n    --> , LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 3, 3 )\r\n    -->     , Point2d.fromCoordinates ( 0, 3 )\r\n    -->     )\r\n    --> , LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 0, 3 )\r\n    -->     , Point2d.fromCoordinates ( 0, 0 )\r\n    -->     )\r\n    --> , LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 1, 1 )\r\n    -->     , Point2d.fromCoordinates ( 1, 2 )\r\n    -->     )\r\n    --> , LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 1, 2 )\r\n    -->     , Point2d.fromCoordinates ( 2, 2 )\r\n    -->     )\r\n    --> , LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 2, 2 )\r\n    -->     , Point2d.fromCoordinates ( 2, 1 )\r\n    -->     )\r\n    --> , LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 2, 1 )\r\n    -->     , Point2d.fromCoordinates ( 1, 1 )\r\n    -->     )\r\n    --> ]\r\n\r\n","type":"Polygon2d.Polygon2d units coordinates -> List.List (LineSegment2d.LineSegment2d units coordinates)"},{"name":"innerLoops","comment":" Get the holes (if any) of a polygon, each defined by a list of vertices.\r\nEach list of vertices will be in clockwise order.\r\n\r\n    Polygon2d.innerLoops squareWithHole\r\n    --> [ [ Point2d.fromCoordinates ( 1, 1 )\r\n    -->   , Point2d.fromCoordinates ( 1, 2 )\r\n    -->   , Point2d.fromCoordinates ( 2, 2 )\r\n    -->   , Point2d.fromCoordinates ( 2, 1 )\r\n    -->   ]\r\n    --> ]\r\n\r\n","type":"Polygon2d.Polygon2d units coordinates -> List.List (List.List (Point2d.Point2d units coordinates))"},{"name":"mirrorAcross","comment":" Mirror a polygon across the given axis.\r\n\r\n    Polygon2d.mirrorAcross Axis2d.x rectangle\r\n    --> Polygon2d.singleLoop\r\n    -->     [ Point2d.fromCoordinates ( 1, -1 )\r\n    -->     , Point2d.fromCoordinates ( 3, -1 )\r\n    -->     , Point2d.fromCoordinates ( 3, -2 )\r\n    -->     , Point2d.fromCoordinates ( 1, -2 )\r\n    -->     ]\r\n\r\nThe order of the polygon's vertices will be reversed so that the resulting\r\npolygon still has its outer vertices in counterclockwise order and its inner\r\nvertices in clockwise order.\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> Polygon2d.Polygon2d units coordinates -> Polygon2d.Polygon2d units coordinates"},{"name":"outerLoop","comment":" Get the list of vertices definining the outer loop (border) of a polygon.\r\nThe vertices will be in counterclockwise order.\r\n\r\n    Polygon2d.outerLoop squareWithHole\r\n    --> [ Point2d.fromCoordinates ( 0, 0 )\r\n    --> , Point2d.fromCoordinates ( 3, 0 )\r\n    --> , Point2d.fromCoordinates ( 3, 3 )\r\n    --> , Point2d.fromCoordinates ( 0, 3 )\r\n    --> ]\r\n\r\n","type":"Polygon2d.Polygon2d units coordinates -> List.List (Point2d.Point2d units coordinates)"},{"name":"perimeter","comment":" Get the perimeter of a polygon (the sum of the lengths of its edges). This\r\nincludes the outer perimeter and the perimeter of any holes.\r\n\r\n    Polygon2d.perimeter squareWithHole\r\n    --> 16\r\n\r\n","type":"Polygon2d.Polygon2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"placeIn","comment":" Take a polygon considered to be defined in local coordinates relative\r\nto a given reference frame, and return that polygon expressed in global\r\ncoordinates.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    Polygon2d.placeIn localFrame rectangle\r\n    --> Polygon2d.singleLoop\r\n    -->     [ Point2d.fromCoordinates ( 2, 3 )\r\n    -->     , Point2d.fromCoordinates ( 4, 3 )\r\n    -->     , Point2d.fromCoordinates ( 4, 4 )\r\n    -->     , Point2d.fromCoordinates ( 2, 4 )\r\n    -->     ]\r\n\r\nIf the given frame is left-handed, the order of the polygon's vertices will be\r\nreversed so that the resulting polygon still has its outer vertices in\r\ncounterclockwise order and its inner vertices in clockwise order.\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> Polygon2d.Polygon2d units localCoordinates -> Polygon2d.Polygon2d units globalCoordinates"},{"name":"relativeTo","comment":" Take a polygon defined in global coordinates, and return it expressed\r\nin local coordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    Polygon2d.relativeTo localFrame rectangle\r\n    --> Polygon2d.singleLoop\r\n    -->     [ Point2d.fromCoordinates ( 0, -1 )\r\n    -->     , Point2d.fromCoordinates ( 2, -1 )\r\n    -->     , Point2d.fromCoordinates ( 2, 0 )\r\n    -->     , Point2d.fromCoordinates ( 0, 0 )\r\n    -->     ]\r\n\r\nIf the given frame is left-handed, the order of the polygon's vertices will be\r\nreversed so that the resulting polygon still has its outer vertices in\r\ncounterclockwise order and its inner vertices in clockwise order.\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> Polygon2d.Polygon2d units globalCoordinates -> Polygon2d.Polygon2d units localCoordinates"},{"name":"rotateAround","comment":" Rotate a polygon around the given center point counterclockwise by the given\r\nangle (in radians).\r\n\r\n    rectangle\r\n        |> Polygon2d.rotateAround Point2d.origin\r\n            (degrees 90)\r\n    --> Polygon2d.singleLoop\r\n    -->     [ Point2d.fromCoordinates ( -1, 1 )\r\n    -->     , Point2d.fromCoordinates ( -1, 3 )\r\n    -->     , Point2d.fromCoordinates ( -2, 3 )\r\n    -->     , Point2d.fromCoordinates ( -2, 1 )\r\n    -->     ]\r\n\r\n","type":"Point2d.Point2d units coordinates -> Angle.Angle -> Polygon2d.Polygon2d units coordinates -> Polygon2d.Polygon2d units coordinates"},{"name":"scaleAbout","comment":" Scale a polygon about a given center point by a given scale.\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 2, 1 )\r\n\r\n    Polygon2d.scaleAbout point 2 rectangle\r\n    --> Polygon2d.singleLoop\r\n    -->     [ Point2d.fromCoordinates ( 0, 1 )\r\n    -->     , Point2d.fromCoordinates ( 4, 1 )\r\n    -->     , Point2d.fromCoordinates ( 4, 3 )\r\n    -->     , Point2d.fromCoordinates ( 0, 3 )\r\n    -->     ]\r\n\r\nIf the given scale is negative, the order of the polygon's vertices will be\r\nreversed so that the resulting polygon still has its outer vertices in\r\ncounterclockwise order and its inner vertices in clockwise order.\r\n\r\n","type":"Point2d.Point2d units coordinates -> Basics.Float -> Polygon2d.Polygon2d units coordinates -> Polygon2d.Polygon2d units coordinates"},{"name":"singleLoop","comment":" Construct a polygon without holes from a list of its vertices:\r\n\r\n    rectangle =\r\n        Polygon2d.singleLoop\r\n            [ Point2d.fromCoordinates ( 1, 1 )\r\n            , Point2d.fromCoordinates ( 3, 1 )\r\n            , Point2d.fromCoordinates ( 3, 2 )\r\n            , Point2d.fromCoordinates ( 1, 2 )\r\n            ]\r\n\r\nThe last vertex is implicitly considered to be connected back to the first\r\nvertex (you do not have to close the polygon explicitly). Vertices should\r\nideally be provided in counterclockwise order; if they are provided in clockwise\r\norder they will be reversed.\r\n\r\n","type":"List.List (Point2d.Point2d units coordinates) -> Polygon2d.Polygon2d units coordinates"},{"name":"translateBy","comment":" Translate a polygon by the given displacement.\r\n\r\n    displacement =\r\n        Vector2d.fromComponents ( 2, 3 )\r\n\r\n    Polygon2d.translateBy displacement rectangle\r\n    --> Polygon2d.singleLoop\r\n    -->     [ Point2d.fromCoordinates ( 3, 4 )\r\n    -->     , Point2d.fromCoordinates ( 5, 4 )\r\n    -->     , Point2d.fromCoordinates ( 5, 5 )\r\n    -->     , Point2d.fromCoordinates ( 3, 5 )\r\n    -->     ]\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Polygon2d.Polygon2d units coordinates -> Polygon2d.Polygon2d units coordinates"},{"name":"translateIn","comment":" Translate a polygon in a given direction by a given distance;\r\n\r\n    Polygon2d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    Polygon2d.translateBy\r\n        (Vector2d.withLength distance direction)\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Quantity.Quantity Basics.Float units -> Polygon2d.Polygon2d units coordinates -> Polygon2d.Polygon2d units coordinates"},{"name":"triangulate","comment":" Triangulate a polygon. This uses the `TriangularMesh` data types from\r\n[`ianmackenzie/elm-triangular-mesh`](http://package.elm-lang.org/packages/ianmackenzie/elm-triangular-mesh/latest).\r\nTriangulation is useful for things like WebGL rendering; you can define a\r\npolygon just by specifying its outline (and holes, if it has any)\r\n\r\n![Polygon with hole](https://ianmackenzie.github.io/elm-geometry/1.0.0/Polygon2d/triangulate1.svg)\r\n\r\nthen use this function to turn that polygon into a list of triangles which you\r\ncan render using WebGL:\r\n\r\n![Polygon with hole](https://ianmackenzie.github.io/elm-geometry/1.0.0/Polygon2d/triangulate2.svg)\r\n\r\n","type":"Polygon2d.Polygon2d units coordinates -> TriangularMesh.TriangularMesh (Point2d.Point2d units coordinates)"},{"name":"vertices","comment":" Get all vertices of a polygon; this will include vertices from the outer\r\nloop of the polygon and all inner loops. The order of the returned vertices is\r\nundefined.\r\n\r\n    Polygon2d.vertices squareWithHole\r\n    --> [ Point2d ( 0, 0 )\r\n    --> , Point2d ( 3, 0 )\r\n    --> , Point2d ( 3, 3 )\r\n    --> , Point2d ( 0, 3 )\r\n    --> , Point2d ( 1, 1 )\r\n    --> , Point2d ( 1, 2 )\r\n    --> , Point2d ( 2, 2 )\r\n    --> , Point2d ( 2, 1 )\r\n    --> ]\r\n\r\n","type":"Polygon2d.Polygon2d units coordinates -> List.List (Point2d.Point2d units coordinates)"},{"name":"with","comment":" Construct a polygon with holes from one outer loop and a list of inner\r\nloops. The loops must not touch or intersect each other.\r\n\r\n    outerLoop =\r\n        [ Point2d.fromCoordinates ( 0, 0 )\r\n        , Point2d.fromCoordinates ( 3, 0 )\r\n        , Point2d.fromCoordinates ( 3, 3 )\r\n        , Point2d.fromCoordinates ( 0, 3 )\r\n        ]\r\n\r\n    innerLoop =\r\n        [ Point2d.fromCoordinates ( 1, 1 )\r\n        , Point2d.fromCoordinates ( 1, 2 )\r\n        , Point2d.fromCoordinates ( 2, 2 )\r\n        , Point2d.fromCoordinates ( 2, 1 )\r\n        ]\r\n\r\n    squareWithHole =\r\n        Polygon2d.with\r\n            { outerLoop = outerLoop\r\n            , innerLoops = [ innerLoop ]\r\n            }\r\n\r\nAs with `Polygon2d.singleLoop`, the last vertex of each loop is considered to be\r\nconnected back to the first. Vertices of the outer loop should ideally be\r\nprovided in counterclockwise order and vertices of the inner loops should\r\nideally be provided in clockwise order.\r\n\r\n","type":"{ outerLoop : List.List (Point2d.Point2d units coordinates), innerLoops : List.List (List.List (Point2d.Point2d units coordinates)) } -> Polygon2d.Polygon2d units coordinates"}],"binops":[]},{"name":"Polyline2d","comment":" A `Polyline2d` represents a sequence of vertices in 2D connected by line\r\nsegments. This module contains a variety of polyline-related functionality, such\r\nas\r\n\r\n  - Computing the length of polylines\r\n  - Scaling, rotating, translating and mirroring polylines\r\n  - Converting polylines between different coordinate systems\r\n\r\n@docs Polyline2d\r\n\r\n\r\n# Constructors\r\n\r\n@docs fromVertices\r\n\r\n\r\n# Properties\r\n\r\n@docs vertices, segments, length, boundingBox, centroid\r\n\r\n\r\n# Transformations\r\n\r\nTransforming a polyline is equivalent to transforming each of its vertices.\r\n\r\n@docs scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross, projectOnto, mapVertices\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n","unions":[],"aliases":[{"name":"Polyline2d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Polyline2d units coordinates"}],"values":[{"name":"boundingBox","comment":" Get the minimal bounding box containing a given polyline. Returns `Nothing`\r\nif the polyline has no vertices.\r\n\r\n    Polyline2d.boundingBox stepShape\r\n    --> Just\r\n    -->     (BoundingBox2d.fromExtrema\r\n    -->         { minX = 0\r\n    -->         , maxX = 2\r\n    -->         , minY = 0\r\n    -->         , maxY = 1\r\n    -->         }\r\n    -->     )\r\n\r\n","type":"Polyline2d.Polyline2d units coordinates -> Maybe.Maybe (BoundingBox2d.BoundingBox2d units coordinates)"},{"name":"centroid","comment":" Find the centroid of the polyline. Returns `Nothing` if the polyline\r\nhas no vertices.\r\n\r\n    Polyline2d.centroid stepShape\r\n    --> Just (Point2d.fromCoordinates ( 1.0, 0.5 ))\r\n\r\n","type":"Polyline2d.Polyline2d units coordinates -> Maybe.Maybe (Point2d.Point2d units coordinates)"},{"name":"fromVertices","comment":" Construct a polyline from a list of vertices:\r\n\r\n    stepShape =\r\n        Polyline2d.fromVertices\r\n            [ Point2d.fromCoordinates ( 0, 0 )\r\n            , Point2d.fromCoordinates ( 1, 0 )\r\n            , Point2d.fromCoordinates ( 1, 1 )\r\n            , Point2d.fromCoordinates ( 2, 1 )\r\n            ]\r\n\r\n","type":"List.List (Point2d.Point2d units coordinates) -> Polyline2d.Polyline2d units coordinates"},{"name":"length","comment":" Get the overall length of a polyline (the sum of the lengths of its\r\nsegments).\r\n\r\n    Polyline2d.length stepShape\r\n    --> 3\r\n\r\n","type":"Polyline2d.Polyline2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"mapVertices","comment":" Transform each vertex of a polyline by the given function. All other\r\ntransformations can be defined in terms of `mapVertices`; for example,\r\n\r\n    Polyline2d.mirrorAcross axis\r\n\r\nis equivalent to\r\n\r\n    Polyline2d.mapVertices (Point2d.mirrorAcross axis)\r\n\r\n","type":"(Point2d.Point2d units1 coordinates1 -> Point2d.Point2d units2 coordinates2) -> Polyline2d.Polyline2d units1 coordinates1 -> Polyline2d.Polyline2d units2 coordinates2"},{"name":"mirrorAcross","comment":" Mirror a polyline across the given axis.\r\n\r\n    Polyline2d.mirrorAcross Axis2d.x stepShape\r\n    --> Polyline2d.fromVertices\r\n    -->     [ Point2d.fromCoordinates ( 0, 0 )\r\n    -->     , Point2d.fromCoordinates ( 1, 0 )\r\n    -->     , Point2d.fromCoordinates ( 1, -1 )\r\n    -->     , Point2d.fromCoordinates ( 2, -1 )\r\n    -->     ]\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> Polyline2d.Polyline2d units coordinates -> Polyline2d.Polyline2d units coordinates"},{"name":"placeIn","comment":" Take a polyline considered to be defined in local coordinates relative\r\nto a given reference frame, and return that polyline expressed in global\r\ncoordinates.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    Polyline2d.placeIn localFrame stepShape\r\n    --> Polyline2d.fromVertices\r\n    -->     [ Point2d.fromCoordinates ( 1, 2 )\r\n    -->     , Point2d.fromCoordinates ( 2, 2 )\r\n    -->     , Point2d.fromCoordinates ( 2, 3 )\r\n    -->     , Point2d.fromCoordinates ( 3, 3 )\r\n    -->     ]\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> Polyline2d.Polyline2d units localCoordinates -> Polyline2d.Polyline2d units globalCoordinates"},{"name":"projectOnto","comment":" Project (flatten) a polyline onto the given axis.\r\n\r\n    Polyline2d.projectOnto Axis2d.x stepShape\r\n    --> Polyline2d.fromVertices\r\n    -->     [ Point2d.fromCoordinates ( 0, 0 )\r\n    -->     , Point2d.fromCoordinates ( 1, 0 )\r\n    -->     , Point2d.fromCoordinates ( 1, 0 )\r\n    -->     , Point2d.fromCoordinates ( 2, 0 )\r\n    -->     ]\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> Polyline2d.Polyline2d units coordinates -> Polyline2d.Polyline2d units coordinates"},{"name":"relativeTo","comment":" Take a polyline defined in global coordinates, and return it expressed\r\nin local coordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    Polyline2d.relativeTo localFrame stepShape\r\n    --> Polyline2d.fromVertices\r\n    -->     [ Point2d.fromCoordinates ( -1, -2 )\r\n    -->     , Point2d.fromCoordinates ( 0, -2 )\r\n    -->     , Point2d.fromCoordinates ( 0, -1 )\r\n    -->     , Point2d.fromCoordinates ( 1, -1 )\r\n    -->     ]\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> Polyline2d.Polyline2d units globalCoordinates -> Polyline2d.Polyline2d units localCoordinates"},{"name":"rotateAround","comment":" Rotate a polyline around the given center point counterclockwise by the\r\ngiven angle (in radians).\r\n\r\n    stepShape\r\n        |> Polyline2d.rotateAround Point2d.origin\r\n            (degrees 90)\r\n    --> Polyline2d.fromVertices\r\n    -->     [ Point2d.fromCoordinates ( 0, 0 )\r\n    -->     , Point2d.fromCoordinates ( 0, 1 )\r\n    -->     , Point2d.fromCoordinates ( -1, 1 )\r\n    -->     , Point2d.fromCoordinates ( -1, 2 )\r\n    -->     ]\r\n\r\n","type":"Point2d.Point2d units coordinates -> Angle.Angle -> Polyline2d.Polyline2d units coordinates -> Polyline2d.Polyline2d units coordinates"},{"name":"scaleAbout","comment":" Scale a polyline about a given center point by a given scale.\r\n\r\n    point =\r\n        Point2d.fromCoordinates ( 1, 0 )\r\n\r\n    Polyline2d.scaleAbout point 2 stepShape\r\n    --> Polyline2d.fromVertices\r\n    -->     [ Point2d.fromCoordinates ( -1, 0 )\r\n    -->     , Point2d.fromCoordinates ( 1, 0 )\r\n    -->     , Point2d.fromCoordinates ( 1, 2 )\r\n    -->     , Point2d.fromCoordinates ( 3, 2 )\r\n    -->     ]\r\n\r\n","type":"Point2d.Point2d units coordinates -> Basics.Float -> Polyline2d.Polyline2d units coordinates -> Polyline2d.Polyline2d units coordinates"},{"name":"segments","comment":" Get the individual segments of a polyline.\r\n\r\n    Polyline2d.segments stepShape\r\n    --> [ LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 0, 0 )\r\n    -->     , Point2d.fromCoordinates ( 1, 0 )\r\n    -->     )\r\n    --> , LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 1, 0 )\r\n    -->     , Point2d.fromCoordinates ( 1, 1 )\r\n    -->     )\r\n    --> , LineSegment2d.fromEndpoints\r\n    -->     ( Point2d.fromCoordinates ( 1, 1 )\r\n    -->     , Point2d.fromCoordinates ( 2, 1 )\r\n    -->     )\r\n    --> ]\r\n\r\n","type":"Polyline2d.Polyline2d units coordinates -> List.List (LineSegment2d.LineSegment2d units coordinates)"},{"name":"translateBy","comment":" Translate a polyline by the given displacement.\r\n\r\n    displacement =\r\n        Vector2d.fromComponents ( 2, 3 )\r\n\r\n    Polyline2d.translateBy displacement stepShape\r\n    --> Polyline2d.fromVertices\r\n    -->     [ Point2d.fromCoordinates ( 2, 3 )\r\n    -->     , Point2d.fromCoordinates ( 3, 3 )\r\n    -->     , Point2d.fromCoordinates ( 3, 4 )\r\n    -->     , Point2d.fromCoordinates ( 4, 4 )\r\n    -->     ]\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Polyline2d.Polyline2d units coordinates -> Polyline2d.Polyline2d units coordinates"},{"name":"translateIn","comment":" Translate a polyline in a given direction by a given distance;\r\n\r\n    Polyline2d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    Polyline2d.translateBy\r\n        (Vector2d.withLength distance direction)\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Quantity.Quantity Basics.Float units -> Polyline2d.Polyline2d units coordinates -> Polyline2d.Polyline2d units coordinates"},{"name":"vertices","comment":" Get the vertices of a polyline.\r\n\r\n    Polyline2d.vertices stepShape\r\n    --> [ Point2d.fromCoordinates ( 0, 0 )\r\n    --> , Point2d.fromCoordinates ( 1, 0 )\r\n    --> , Point2d.fromCoordinates ( 1, 1 )\r\n    --> , Point2d.fromCoordinates ( 2, 1 )\r\n    --> ]\r\n\r\n","type":"Polyline2d.Polyline2d units coordinates -> List.List (Point2d.Point2d units coordinates)"}],"binops":[]},{"name":"Polyline3d","comment":" A `Polyline3d` represents a sequence of vertices in 3D connected by line\r\nsegments. This module contains a variety of polyline-related functionality, such\r\nas\r\n\r\n  - Computing the length of polylines\r\n  - Scaling, rotating, translating and mirroring polylines\r\n  - Converting polylines between different coordinate systems\r\n\r\n@docs Polyline3d\r\n\r\n\r\n# Constructors\r\n\r\n@docs fromVertices, on\r\n\r\n\r\n# Properties\r\n\r\n@docs vertices, segments, length, boundingBox, centroid\r\n\r\n\r\n# Transformations\r\n\r\nTransforming a polyline is equivalent to transforming each of its vertices.\r\n\r\n@docs scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross, projectOnto, mapVertices\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn, projectInto\r\n\r\n","unions":[],"aliases":[{"name":"Polyline3d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Polyline3d units coordinates"}],"values":[{"name":"boundingBox","comment":" Get the minimal bounding box containing a given polyline. Returns `Nothing`\r\nif the polyline has no vertices.\r\n\r\n    Polyline3d.boundingBox examplePolyline\r\n    --> Just\r\n    -->     (BoundingBox3d.fromExtrema\r\n    -->         { minX = 0\r\n    -->         , maxX = 1\r\n    -->         , minY = 0\r\n    -->         , maxY = 2\r\n    -->         , minZ = 0\r\n    -->         , maxZ = 3\r\n    -->         }\r\n    -->     )\r\n\r\n","type":"Polyline3d.Polyline3d units coordinates -> Maybe.Maybe (BoundingBox3d.BoundingBox3d units coordinates)"},{"name":"centroid","comment":" Find the centroid of the polyline. Returns `Nothing` if the polyline\r\nhas no vertices.\r\n\r\n    Polyline3d.centroid examplePolyline\r\n    --> Just\r\n    -->     (Point3d.fromCoordinates (a,b,c))\r\n\r\n","type":"Polyline3d.Polyline3d units coordinates -> Maybe.Maybe (Point3d.Point3d units coordinates)"},{"name":"fromVertices","comment":" Construct a polyline from its vertices:\r\n\r\n    examplePolyline =\r\n        Polyline3d.fromVertices\r\n            [ Point3d.fromCoordinates ( 0, 0, 0 )\r\n            , Point3d.fromCoordinates ( 1, 0, 0 )\r\n            , Point3d.fromCoordinates ( 1, 2, 0 )\r\n            , Point3d.fromCoordinates ( 1, 2, 3 )\r\n            ]\r\n\r\n","type":"List.List (Point3d.Point3d units coordinates) -> Polyline3d.Polyline3d units coordinates"},{"name":"length","comment":" Get the overall length of a polyline (the sum of the lengths of its\r\nsegments).\r\n\r\n    Polyline3d.length examplePolyline\r\n    --> 6\r\n\r\n","type":"Polyline3d.Polyline3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"mapVertices","comment":" Transform each vertex of a polyline by the given function. All other\r\ntransformations can be defined in terms of `mapVertices`; for example,\r\n\r\n    Polyline3d.mirrorAcross plane\r\n\r\nis equivalent to\r\n\r\n    Polyline3d.mapVertices (Point3d.mirrorAcross plane)\r\n\r\n","type":"(Point3d.Point3d units1 coordinates1 -> Point3d.Point3d units2 coordinates2) -> Polyline3d.Polyline3d units1 coordinates1 -> Polyline3d.Polyline3d units2 coordinates2"},{"name":"mirrorAcross","comment":" Mirror a polyline across the given plane.\r\n\r\n    Polyline3d.mirrorAcross Plane3d.xz examplePolyline\r\n    --> Polyline3d.fromVertices\r\n    -->     [ Point3d.fromCoordinates ( 0, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 1, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 1, -2, 0 )\r\n    -->     , Point3d.fromCoordinates ( 1, -2, 3 )\r\n    -->     ]\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> Polyline3d.Polyline3d units coordinates -> Polyline3d.Polyline3d units coordinates"},{"name":"on","comment":" Construct a 3D polyline lying _on_ a sketch plane by providing a 2D polyline\r\nspecified in XY coordinates _within_ the sketch plane.\r\n\r\n    Polyline3d.on SketchPlane3d.yz <|\r\n        Polyline2d.fromVertices\r\n            [ Point2d.fromCoordinates ( 0, 0 )\r\n            , Point2d.fromCoordinates ( 1, 0 )\r\n            , Point2d.fromCoordinates ( 1, 1 )\r\n            , Point2d.fromCoordinates ( 2, 1 )\r\n            ]\r\n    --> Polyline3d.fromVertices\r\n    -->     [ Point3d.fromCoordinates ( 0, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 0, 1, 0 )\r\n    -->     , Point3d.fromCoordinates ( 0, 1, 1 )\r\n    -->     , Point3d.fromCoordinates ( 0, 2, 1 )\r\n    -->     ]\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates3d coordinates2d -> Polyline2d.Polyline2d units coordinates2d -> Polyline3d.Polyline3d units coordinates3d"},{"name":"placeIn","comment":" Take a polyline considered to be defined in local coordinates relative\r\nto a given reference frame, and return that polyline expressed in global\r\ncoordinates.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    Polyline3d.placeIn localFrame examplePolyline\r\n    --> Polyline3d.fromVertices\r\n    -->     [ Point3d.fromCoordinates ( 1, 2, 3 )\r\n    -->     , Point3d.fromCoordinates ( 2, 2, 3 )\r\n    -->     , Point3d.fromCoordinates ( 2, 4, 3 )\r\n    -->     , Point3d.fromCoordinates ( 2, 4, 6 )\r\n    -->     ]\r\n\r\n","type":"Frame3d.Frame3d units globalCoordinates localCoordinates -> Polyline3d.Polyline3d units localCoordinates -> Polyline3d.Polyline3d units globalCoordinates"},{"name":"projectInto","comment":" Project a polyline into a given sketch plane. Conceptually, this finds the\r\n[orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof the polyline onto the plane and then expresses the projected polyline in 2D\r\nsketch coordinates.\r\n\r\n    Polyline3d.projectInto Plane3d.xy examplePolyline\r\n    --> Polyline2d.fromVertices\r\n    -->     [ Point2d.fromCoordinates ( 0, 0 )\r\n    -->     , Point2d.fromCoordinates ( 1, 0 )\r\n    -->     , Point2d.fromCoordinates ( 1, 2 )\r\n    -->     , Point2d.fromCoordinates ( 1, 2 )\r\n    -->     ]\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates3d coordinates2d -> Polyline3d.Polyline3d units coordinates3d -> Polyline2d.Polyline2d units coordinates2d"},{"name":"projectOnto","comment":" Find the [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof a polyline onto a plane. This will flatten the polyline.\r\n\r\n    Polyline3d.projectOnto Plane3d.xz examplePolyline\r\n    --> Polyline3d.fromVertices\r\n    -->     [ Point3d.fromCoordinates ( 0, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 1, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 1, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 1, 0, 3 )\r\n    -->     ]\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> Polyline3d.Polyline3d units coordinates -> Polyline3d.Polyline3d units coordinates"},{"name":"relativeTo","comment":" Take a polyline defined in global coordinates, and return it expressed\r\nin local coordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    Polyline3d.relativeTo localFrame examplePolyline\r\n    --> Polyline3d.fromVertices\r\n    -->     [ Point3d.fromCoordinates ( -1, -2, -3 )\r\n    -->     , Point3d.fromCoordinates ( 0, -2, -3 )\r\n    -->     , Point3d.fromCoordinates ( 0, 0, -3 )\r\n    -->     , Point3d.fromCoordinates ( 0, 0, 0 )\r\n    -->     ]\r\n\r\n","type":"Frame3d.Frame3d units globalCoordinates localCoordinates -> Polyline3d.Polyline3d units globalCoordinates -> Polyline3d.Polyline3d units localCoordinates"},{"name":"rotateAround","comment":" Rotate a polyline around the given axis by the given angle (in radians).\r\n\r\n    examplePolyline\r\n        |> Polyline3d.rotateAround Axis3d.z (degrees 90)\r\n    --> Polyline3d.fromVertices\r\n    -->     [ Point3d.fromCoordinates ( 0, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 0, 1, 0 )\r\n    -->     , Point3d.fromCoordinates ( -2, 1, 0 )\r\n    -->     , Point3d.fromCoordinates ( -2, 1, 3 )\r\n    -->     ]\r\n\r\n","type":"Axis3d.Axis3d units coordinates -> Angle.Angle -> Polyline3d.Polyline3d units coordinates -> Polyline3d.Polyline3d units coordinates"},{"name":"scaleAbout","comment":" Scale a polyline about the given center point by the given scale.\r\n\r\n    point =\r\n        Point3d.fromCoordinates ( 1, 0, 0 )\r\n\r\n    Polyline3d.scaleAbout point 2 examplePolyline\r\n    --> Polyline3d.fromVertices\r\n    -->     [ Point3d.fromCoordinates ( -1, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 1, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 1, 4, 0 )\r\n    -->     , Point3d.fromCoordinates ( 1, 4, 6 )\r\n    -->     ]\r\n\r\n","type":"Point3d.Point3d units coordinates -> Basics.Float -> Polyline3d.Polyline3d units coordinates -> Polyline3d.Polyline3d units coordinates"},{"name":"segments","comment":" Get the individual segments of a polyline.\r\n\r\n    Polyline3d.segments examplePolyline\r\n    --> [ LineSegment3d.fromEndpoints\r\n    -->     ( Point3d.fromCoordinates ( 0, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 1, 0, 0 )\r\n    -->     )\r\n    --> , LineSegment3d.fromEndpoints\r\n    -->     ( Point3d.fromCoordinates ( 1, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 1, 2, 0 )\r\n    -->     )\r\n    --> , LineSegment3d.fromEndpoints\r\n    -->     ( Point3d.fromCoordinates ( 1, 2, 0 )\r\n    -->     , Point3d.fromCoordinates ( 1, 2, 3 )\r\n    -->     )\r\n    --> ]\r\n\r\n","type":"Polyline3d.Polyline3d units coordinates -> List.List (LineSegment3d.LineSegment3d units coordinates)"},{"name":"translateBy","comment":" Translate a polyline by the given displacement.\r\n\r\n    displacement =\r\n        Vector3d.fromComponents ( 1, 2, 3 )\r\n\r\n    Polyline3d.translateBy displacement examplePolyline\r\n    --> Polyline3d.fromVertices\r\n    -->     [ Point3d.fromCoordinates ( 1, 2, 3 )\r\n    -->     , Point3d.fromCoordinates ( 2, 2, 3 )\r\n    -->     , Point3d.fromCoordinates ( 2, 4, 3 )\r\n    -->     , Point3d.fromCoordinates ( 2, 4, 6 )\r\n    -->     ]\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Polyline3d.Polyline3d units coordinates -> Polyline3d.Polyline3d units coordinates"},{"name":"translateIn","comment":" Translate a polyline in a given direction by a given distance;\r\n\r\n    Polyline3d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    Polyline3d.translateBy\r\n        (Vector3d.withLength distance direction)\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Quantity.Quantity Basics.Float units -> Polyline3d.Polyline3d units coordinates -> Polyline3d.Polyline3d units coordinates"},{"name":"vertices","comment":" Get the vertices of a polyline.\r\n\r\n    Polyline3d.vertices examplePolyline\r\n    --> [ Point3d.fromCoordinates ( 0, 0, 0 )\r\n    --> , Point3d.fromCoordinates ( 1, 0, 0 )\r\n    --> , Point3d.fromCoordinates ( 1, 2, 0 )\r\n    --> , Point3d.fromCoordinates ( 1, 2, 3 )\r\n    --> ]\r\n\r\n","type":"Polyline3d.Polyline3d units coordinates -> List.List (Point3d.Point3d units coordinates)"}],"binops":[]},{"name":"QuadraticSpline2d","comment":" A `QuadraticSpline2d` is a quadratic [Bzier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)\r\nin 2D defined by a start point, control point and end point. This module\r\ncontains functionality for\r\n\r\n  - Evaluating points and derivatives along a spline\r\n  - Scaling, rotating, translating or mirroring a spline\r\n  - Converting a spline between local and global coordinates in different\r\n    reference frames\r\n\r\n@docs QuadraticSpline2d\r\n\r\n\r\n# Constructors\r\n\r\n@docs with\r\n\r\n\r\n# Properties\r\n\r\n@docs startPoint, endPoint, controlPoint, startDerivative, endDerivative, boundingBox\r\n\r\n\r\n# Evaluation\r\n\r\n@docs pointOn, pointsAt\r\n@docs Nondegenerate, nondegenerate, fromNondegenerate\r\n@docs tangentDirection, tangentDirectionsAt, sample, samplesAt\r\n\r\n\r\n# Transformations\r\n\r\n@docs reverse, scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n\r\n# Subdivision\r\n\r\n@docs bisect, splitAt\r\n\r\n\r\n# Arc length parameterization\r\n\r\n@docs ArcLengthParameterized, arcLengthParameterized, arcLength, pointAlong, midpoint, tangentDirectionAlong, sampleAlong\r\n\r\n\r\n## Low level\r\n\r\nAn `ArcLengthParameterized` value is a combination of an\r\n[`ArcLengthParameterization`](Geometry-ArcLengthParameterization) and an\r\nunderlying `QuadraticSpline2d`. If you need to do something fancy, you can\r\nextract these two values separately.\r\n\r\n@docs arcLengthParameterization, fromArcLengthParameterized\r\n\r\n\r\n# Differentiation\r\n\r\nYou are unlikely to need to use these functions directly, but they are useful if\r\nyou are writing low-level geometric algorithms.\r\n\r\n@docs firstDerivative, firstDerivativesAt, secondDerivative\r\n\r\n","unions":[{"name":"ArcLengthParameterized","comment":" A spline that has been parameterized by arc length.\r\n","args":["units","coordinates"],"cases":[]},{"name":"Nondegenerate","comment":" If a curve has zero length (consists of just a single point), then we say\r\nthat it is 'degenerate'. Some operations such as computing tangent directions\r\nare not defined on degenerate curves.\r\n\r\nA `Nondegenerate` value represents a spline that is definitely not degenerate.\r\nIt is used as input to functions such as `QuadraticSpline2d.tangentDirection`\r\nand can be constructed using `QuadraticSpline2d.nondegenerate`.\r\n\r\n","args":["units","coordinates"],"cases":[]}],"aliases":[{"name":"QuadraticSpline2d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.QuadraticSpline2d units coordinates"}],"values":[{"name":"arcLength","comment":" Find the total arc length of a spline:\r\n\r\n    QuadraticSpline2d.arcLength parameterizedSpline\r\n    --> 5.1986\r\n\r\nIn this example, the result will be accurate to within `1.0e-4` since that was\r\nthe tolerance used when constructing `parameterizedSpline`.\r\n\r\n","type":"QuadraticSpline2d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"arcLengthParameterization","comment":" ","type":"QuadraticSpline2d.ArcLengthParameterized units coordinates -> Curve.ArcLengthParameterization.ArcLengthParameterization units"},{"name":"arcLengthParameterized","comment":" Build an arc length parameterization of the given spline, with a given\r\naccuracy. Generally speaking, all operations on the resulting\r\n`ArcLengthParameterized` value will be accurate to within the specified maximum\r\nerror.\r\n\r\n    parameterizedSpline =\r\n        exampleSpline\r\n            |> QuadraticSpline2d.arcLengthParameterized\r\n                { maxError = 1.0e-4 }\r\n\r\n","type":"{ maxError : Quantity.Quantity Basics.Float units } -> QuadraticSpline2d.QuadraticSpline2d units coordinates -> QuadraticSpline2d.ArcLengthParameterized units coordinates"},{"name":"bisect","comment":" Split a spline into two roughly equal halves.\r\n\r\n    QuadraticSpline2d.bisect exampleSpline\r\n    --> ( QuadraticSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 1, 1 )\r\n    -->     , controlPoint =\r\n    -->         Point2d.fromCoordinates ( 2, 2.5 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 3, 2.5 )\r\n    -->     }\r\n    --> , QuadraticSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 3, 2.5 )\r\n    -->     , controlPoint =\r\n    -->         Point2d.fromCoordinates ( 4, 2.5 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 5, 1 )\r\n    -->     }\r\n    --> )\r\n\r\nEquivalent to `QuadraticSpline2d.splitAt ParameterValue.half`.\r\n\r\n","type":"QuadraticSpline2d.QuadraticSpline2d units coordinates -> ( QuadraticSpline2d.QuadraticSpline2d units coordinates, QuadraticSpline2d.QuadraticSpline2d units coordinates )"},{"name":"boundingBox","comment":" Compute a bounding box for a given spline. It is not guaranteed that the\r\nresult will be the _smallest_ possible bounding box, since for efficiency the\r\nbounding box is computed from the spline's control points (which cover a larger\r\narea than the spline itself).\r\n\r\n    QuadraticSpline2d.boundingBox exampleSpline\r\n    --> BoundingBox2d.fromExtrema\r\n    -->     { minX = 1\r\n    -->     , maxX = 5\r\n    -->     , minY = 1\r\n    -->     , maxY = 4\r\n    -->     }\r\n\r\n","type":"QuadraticSpline2d.QuadraticSpline2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates"},{"name":"controlPoint","comment":" Get the control point of a spline.\r\n\r\n    QuadraticSpline2d.controlPoint exampleSpline\r\n    --> Point2d.fromCoordinates ( 3, 4 )\r\n\r\n","type":"QuadraticSpline2d.QuadraticSpline2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"endDerivative","comment":" Get the end derivative of a spline. This is equal to twice the vector from\r\nthe spline's second control point to its third.\r\n\r\n    QuadraticSpline2d.endDerivative exampleSpline\r\n    --> Vector2d.fromComponents ( 4, -6 )\r\n\r\n","type":"QuadraticSpline2d.QuadraticSpline2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"endPoint","comment":" Get the end point of a spline.\r\n\r\n    QuadraticSpline2d.endPoint exampleSpline\r\n    --> Point2d.fromCoordinates ( 5, 1 )\r\n\r\n","type":"QuadraticSpline2d.QuadraticSpline2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"firstDerivative","comment":" Get the first derivative of a spline at a given parameter value.\r\n\r\n    QuadraticSpline2d.derivative exampleSpline\r\n        ParameterValue.zero\r\n    --> Vector2d.fromComponents ( 4, 6 )\r\n\r\n    QuadraticSpline2d.derivative exampleSpline\r\n        ParameterValue.half\r\n    --> Vector2d.fromComponents ( 4, 0 )\r\n\r\n    QuadraticSpline2d.derivative exampleSpline\r\n        ParameterValue.one\r\n    --> Vector2d.fromComponents ( 4, -6 )\r\n\r\nNote that the derivative interpolates linearly from end to end.\r\n\r\n","type":"QuadraticSpline2d.QuadraticSpline2d units coordinates -> Curve.ParameterValue.ParameterValue -> Vector2d.Vector2d units coordinates"},{"name":"firstDerivativesAt","comment":" Evaluate the first derivative of a spline at a range of parameter values:\r\n\r\n    exampleSpline\r\n        |> QuadraticSpline2d.firstDerivativesAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Vector2d.fromComponents ( 4, 6 )\r\n    --> , Vector2d.fromComponents ( 4, 0 )\r\n    --> , Vector2d.fromComponents ( 4, -6 )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> QuadraticSpline2d.QuadraticSpline2d units coordinates -> List.List (Vector2d.Vector2d units coordinates)"},{"name":"fromArcLengthParameterized","comment":" Get the original `QuadraticSpline2d` from which an `ArcLengthParameterized`\r\nvalue was constructed.\r\n","type":"QuadraticSpline2d.ArcLengthParameterized units coordinates -> QuadraticSpline2d.QuadraticSpline2d units coordinates"},{"name":"fromNondegenerate","comment":" Convert a nondegenerate spline back to a general `QuadraticSpline2d`.\r\n\r\n    QuadraticSpline2d.fromNondegenerate\r\n        nondegenerateExampleSpline\r\n    --> exampleSpline\r\n\r\n","type":"QuadraticSpline2d.Nondegenerate units coordinates -> QuadraticSpline2d.QuadraticSpline2d units coordinates"},{"name":"midpoint","comment":" Get the midpoint of the Spline.\r\n\r\n    QuadraticSpline2d.midpoint parameterizedSpline\r\n    --> Point2d.fromCoordinates (2.999999999999984, 2.5)\r\n\r\n","type":"QuadraticSpline2d.ArcLengthParameterized units coordinates -> Point2d.Point2d units coordinates"},{"name":"mirrorAcross","comment":" Mirror a spline across an axis.\r\n\r\n    QuadraticSpline2d.mirrorAcross Axis2d.x exampleSpline\r\n    --> QuadraticSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 1, -1 )\r\n    -->     , controlPoint =\r\n    -->         Point2d.fromCoordinates ( 3, -4 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 5, -1 )\r\n    -->     }\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> QuadraticSpline2d.QuadraticSpline2d units coordinates -> QuadraticSpline2d.QuadraticSpline2d units coordinates"},{"name":"nondegenerate","comment":" Attempt to construct a nondegenerate spline from a general\r\n`QuadraticSpline2d`. If the spline is in fact degenerate (consists of a single\r\npoint), returns an `Err` with that point.\r\n\r\n    QuadraticSpline2d.nondegenerate exampleSpline\r\n    --> Ok nondegenerateExampleSpline\r\n\r\n","type":"QuadraticSpline2d.QuadraticSpline2d units coordinates -> Result.Result (Point2d.Point2d units coordinates) (QuadraticSpline2d.Nondegenerate units coordinates)"},{"name":"placeIn","comment":" Take a spline considered to be defined in local coordinates relative to a\r\ngiven reference frame, and return that spline expressed in global coordinates.\r\n\r\n    localFrame =\r\n        Frame2d.atCoordinates ( 1, 2 )\r\n\r\n    QuadraticSpline2d.placeIn localFrame exampleSpline\r\n    --> QuadraticSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 2, 3 )\r\n    -->     , controlPoint =\r\n    -->         Point2d.fromCoordinates ( 4, 6 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 6, 3 )\r\n    -->     }\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> QuadraticSpline2d.QuadraticSpline2d units localCoordinates -> QuadraticSpline2d.QuadraticSpline2d units globalCoordinates"},{"name":"pointAlong","comment":" Try to get the point along a spline at a given arc length. For example, to\r\nget the point a quarter of the way along `exampleSpline`:\r\n\r\n    QuadraticSpline2d.pointAlong parameterizedSpline\r\n        (arcLength / 4)\r\n    --> Just (Point2d.fromCoordinates ( 1.8350, 1.9911 ))\r\n\r\nNote that this is not the same as evaulating at a parameter value of 1/4:\r\n\r\n    QuadraticSpline2d.pointOn exampleSpline 0.25\r\n    --> Point2d.fromCoordinates ( 2, 2.125 )\r\n\r\nIf the given arc length is less than zero or greater than the arc length of the\r\nspline, returns `Nothing`.\r\n\r\n","type":"QuadraticSpline2d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units -> Maybe.Maybe (Point2d.Point2d units coordinates)"},{"name":"pointOn","comment":" Get the point along a spline at a given parameter value:\r\n\r\n    QuadraticSpline2d.pointOn exampleSpline 0\r\n    --> Point2d.fromCoordinates ( 1, 1 )\r\n\r\n    QuadraticSpline2d.pointOn exampleSpline 0.5\r\n    --> Point2d.fromCoordinates ( 3, 2.5 )\r\n\r\n    QuadraticSpline2d.pointOn exampleSpline 1\r\n    --> Point2d.fromCoordinates ( 5, 1 )\r\n\r\n","type":"QuadraticSpline2d.QuadraticSpline2d units coordinates -> Curve.ParameterValue.ParameterValue -> Point2d.Point2d units coordinates"},{"name":"pointsAt","comment":" Get points along a spline at a given set of parameter values:\r\n\r\n    exampleSpline\r\n        |> QuadraticSpline2d.pointsAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Point2d.fromCoordinates ( 1, 1 )\r\n    --> , Point2d.fromCoordinates ( 3, 2.5 )\r\n    --> , Point2d.fromCoordinates ( 5, 1 )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> QuadraticSpline2d.QuadraticSpline2d units coordinates -> List.List (Point2d.Point2d units coordinates)"},{"name":"relativeTo","comment":" Take a spline defined in global coordinates, and return it expressed in\r\nlocal coordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame2d.atCoordinates ( 1, 2 )\r\n\r\n    QuadraticSpline2d.relativeTo localFrame exampleSpline\r\n    --> QuadraticSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 0, -1 )\r\n    -->     , controlPoint =\r\n    -->         Point2d.fromCoordinates ( 2, 2 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 4, -1 )\r\n    -->     }\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> QuadraticSpline2d.QuadraticSpline2d units globalCoordinates -> QuadraticSpline2d.QuadraticSpline2d units localCoordinates"},{"name":"reverse","comment":" Reverse a spline so that the start point becomes the end point, and vice\r\nversa.\r\n\r\n    QuadraticSpline2d.reverse exampleSpline\r\n    --> QuadraticSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 5, 1 )\r\n    -->     , controlPoint =\r\n    -->         Point2d.fromCoordinates ( 3, 4 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 1, 1 )\r\n    -->     }\r\n\r\n","type":"QuadraticSpline2d.QuadraticSpline2d units coordinates -> QuadraticSpline2d.QuadraticSpline2d units coordinates"},{"name":"rotateAround","comment":" Rotate a spline counterclockwise around a given center point by a given\r\nangle (in radians).\r\n\r\n    examplePolyline\r\n        |> QuadraticSpline2d.rotateAround Point2d.origin\r\n            (degrees 90)\r\n    --> QuadraticSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( -1, 1 )\r\n    -->     , controlPoint =\r\n    -->         Point2d.fromCoordinates ( -4, 3 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( -1, 5 )\r\n    -->     }\r\n\r\n","type":"Point2d.Point2d units coordinates -> Angle.Angle -> QuadraticSpline2d.QuadraticSpline2d units coordinates -> QuadraticSpline2d.QuadraticSpline2d units coordinates"},{"name":"sample","comment":" Get both the point and tangent direction of a nondegenerate spline at a\r\ngiven parameter value:\r\n\r\n    QuadraticSpline2d.sample nondegenerateExampleSpline\r\n        ParameterValue.half\r\n    --> ( Point2d.fromCoordinates ( 3, 2.5 )\r\n    --> , Direction2d.x\r\n    --> )\r\n\r\n","type":"QuadraticSpline2d.Nondegenerate units coordinates -> Curve.ParameterValue.ParameterValue -> ( Point2d.Point2d units coordinates, Direction2d.Direction2d coordinates )"},{"name":"sampleAlong","comment":" Try to get the point and tangent direction along a spline at a given arc\r\nlength. To get the point and tangent direction a quarter of the way along\r\n`exampleSpline`:\r\n\r\n    QuadraticSpline2d.sampleAlong parameterizedSpline\r\n        (0.25 * arcLength)\r\n    --> Just\r\n    -->     ( Point2d.fromCoordinates ( 1.8350, 1.9911 )\r\n    -->     , Direction2d.fromAngle (degrees 41.145)\r\n    -->     )\r\n\r\nIf the given arc length is less than zero or greater than the arc length of the\r\nspline (or if the spline is degenerate), returns `Nothing`.\r\n\r\n","type":"QuadraticSpline2d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units -> Maybe.Maybe ( Point2d.Point2d units coordinates, Direction2d.Direction2d coordinates )"},{"name":"samplesAt","comment":" Get points and tangent directions of a nondegenerate spline at a given set\r\nof parameter values:\r\n\r\n    nondegenerateExampleSpline\r\n        |> QuadraticSpline2d.samplesAt\r\n            (ParameterValue.steps 2)\r\n    --> [ ( Point2d.fromCoordinates ( 1, 1 )\r\n    -->   , Direction2d.fromAngle (degrees 56.31)\r\n    -->   )\r\n    --> , ( Point2d.fromCoordinates ( 3, 2.5 )\r\n    -->   , Direction2d.x\r\n    -->   )\r\n    --> , ( Point2d.fromCoordinates ( 5, 1 )\r\n    -->   , Direction2d.fromAngle (degrees -56.31)\r\n    -->   )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> QuadraticSpline2d.Nondegenerate units coordinates -> List.List ( Point2d.Point2d units coordinates, Direction2d.Direction2d coordinates )"},{"name":"scaleAbout","comment":" Scale a spline about the given center point by the given scale.\r\n\r\n    examplePolyline\r\n        |> QuadraticSpline2d.scaleAbout Point2d.origin 2\r\n    --> QuadraticSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 2, 2 )\r\n    -->     , controlPoint =\r\n    -->         Point2d.fromCoordinates ( 6, 8 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 10, 2 )\r\n    -->     }\r\n\r\n","type":"Point2d.Point2d units coordinates -> Basics.Float -> QuadraticSpline2d.QuadraticSpline2d units coordinates -> QuadraticSpline2d.QuadraticSpline2d units coordinates"},{"name":"secondDerivative","comment":" Get the second derivative of a spline (for a quadratic spline, this is a\r\nconstant).\r\n","type":"QuadraticSpline2d.QuadraticSpline2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"splitAt","comment":" Split a spline at a particular parameter value, resulting in two smaller\r\nsplines.\r\n\r\n    parameterValue =\r\n        ParameterValue.clamped 0.75\r\n\r\n    QuadraticSpline2d.splitAt parameterValue exampleSpline\r\n    --> ( QuadraticSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 1, 1 )\r\n    -->     , controlPoint =\r\n    -->         Point2d.fromCoordinates ( 2.5, 3.25 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 4, 2.125 )\r\n    -->     }\r\n    --> , QuadraticSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 4, 2.125 )\r\n    -->     , controlPoint =\r\n    -->         Point2d.fromCoordinates ( 4.5, 1.75 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 5, 1 )\r\n    -->     }\r\n    --> )\r\n\r\n","type":"Curve.ParameterValue.ParameterValue -> QuadraticSpline2d.QuadraticSpline2d units coordinates -> ( QuadraticSpline2d.QuadraticSpline2d units coordinates, QuadraticSpline2d.QuadraticSpline2d units coordinates )"},{"name":"startDerivative","comment":" Get the start derivative of a spline. This is equal to twice the vector from\r\nthe spline's first control point to its second.\r\n\r\n    QuadraticSpline2d.startDerivative exampleSpline\r\n    --> Vector2d.fromComponents ( 4, 6 )\r\n\r\n","type":"QuadraticSpline2d.QuadraticSpline2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"startPoint","comment":" Get the start point of a spline.\r\n\r\n    QuadraticSpline2d.startPoint exampleSpline\r\n    --> Point2d.fromCoordinates ( 1, 1 )\r\n\r\n","type":"QuadraticSpline2d.QuadraticSpline2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"tangentDirection","comment":" Get the tangent direction to a nondegenerate spline at a given parameter\r\nvalue:\r\n\r\n    QuadraticSpline2d.tangentDirection\r\n        nondegenerateExampleSpline\r\n        ParameterValue.zero\r\n    --> Direction2d.fromAngle (degrees 56.31)\r\n\r\n    QuadraticSpline2d.tangentDirection\r\n        nondegenerateExampleSpline\r\n        ParameterValue.half\r\n    --> Direction2d.x\r\n\r\n    QuadraticSpline2d.tangentDirection\r\n        nondegenerateExampleSpline\r\n        ParameterValue.one\r\n    --> Direction2d.fromAngle (degrees -56.31)\r\n\r\n","type":"QuadraticSpline2d.Nondegenerate units coordinates -> Curve.ParameterValue.ParameterValue -> Direction2d.Direction2d coordinates"},{"name":"tangentDirectionAlong","comment":" Try to get the tangent direction along a spline at a given arc length. To\r\nget the tangent direction a quarter of the way along `exampleSpline`:\r\n\r\n    QuadraticSpline2d.tangentDirectionAlong\r\n        parameterizedSpline\r\n        (arcLength / 4)\r\n    --> Just (Direction2d.fromAngle (degrees 41.145))\r\n\r\nIf the given arc length is less than zero or greater than the arc length of the\r\nspline (or if the derivative of the spline happens to be exactly zero at the\r\ngiven arc length), returns `Nothing`.\r\n\r\n","type":"QuadraticSpline2d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units -> Maybe.Maybe (Direction2d.Direction2d coordinates)"},{"name":"tangentDirectionsAt","comment":" Get tangent directions to a nondegenerate spline at a given set of parameter\r\nvalues:\r\n\r\n    nondegenerateExampleSpline\r\n        |> QuadraticSpline2d.tangentDirectionsAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Direction2d.fromAngle (degrees 56.31)\r\n    --> , Direction2d.x\r\n    --> , Direction2d.fromAngle (degrees -56.31)\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> QuadraticSpline2d.Nondegenerate units coordinates -> List.List (Direction2d.Direction2d coordinates)"},{"name":"translateBy","comment":" Translate a spline by a given displacement.\r\n\r\n    displacement =\r\n        Vector2d.fromComponents ( 2, 3 )\r\n\r\n    exampleSpline\r\n        |> QuadraticSpline2d.translateBy displacement\r\n    --> QuadraticSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 3, 4 )\r\n    -->     , controlPoint =\r\n    -->         Point2d.fromCoordinates ( 5, 7 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 7, 4 )\r\n    -->     )\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> QuadraticSpline2d.QuadraticSpline2d units coordinates -> QuadraticSpline2d.QuadraticSpline2d units coordinates"},{"name":"translateIn","comment":" Translate a spline in a given direction by a given distance;\r\n\r\n    QuadraticSpline2d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    QuadraticSpline2d.translateBy\r\n        (Vector2d.withLength distance direction)\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Quantity.Quantity Basics.Float units -> QuadraticSpline2d.QuadraticSpline2d units coordinates -> QuadraticSpline2d.QuadraticSpline2d units coordinates"},{"name":"with","comment":" Construct a spline from its start point, control point and end point:\r\n\r\n    exampleSpline =\r\n        QuadraticSpline2d.with\r\n            { startPoint =\r\n                Point2d.fromCoordinates ( 1, 1 )\r\n            , controlPoint =\r\n                Point2d.fromCoordinates ( 3, 4 )\r\n            , endPoint =\r\n                Point2d.fromCoordinates ( 5, 1 )\r\n            }\r\n\r\n","type":"{ startPoint : Point2d.Point2d units coordinates, controlPoint : Point2d.Point2d units coordinates, endPoint : Point2d.Point2d units coordinates } -> QuadraticSpline2d.QuadraticSpline2d units coordinates"}],"binops":[]},{"name":"QuadraticSpline3d","comment":" A `QuadraticSpline3d` is a quadratic [Bzier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)\r\nin 3D defined by a start point, control point and end point. This module\r\ncontains functionality for\r\n\r\n  - Evaluating points and derivatives along a spline\r\n  - Scaling, rotating, translating or mirroring a spline\r\n  - Converting a spline between local and global coordinates in different\r\n    reference frames\r\n\r\n@docs QuadraticSpline3d\r\n\r\n\r\n# Constructors\r\n\r\n@docs with, on\r\n\r\n\r\n# Properties\r\n\r\n@docs startPoint, endPoint, controlPoint, startDerivative, endDerivative, boundingBox\r\n\r\n\r\n# Evaluation\r\n\r\n@docs pointOn, pointsAt\r\n@docs Nondegenerate, nondegenerate, fromNondegenerate\r\n@docs tangentDirection, tangentDirectionsAt, sample, samplesAt\r\n\r\n\r\n# Transformations\r\n\r\n@docs reverse, scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross, projectOnto\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n\r\n# Sketch planes\r\n\r\n@docs projectInto\r\n\r\n\r\n# Subdivision\r\n\r\n@docs bisect, splitAt\r\n\r\n\r\n# Arc length parameterization\r\n\r\n@docs ArcLengthParameterized, arcLengthParameterized, arcLength, pointAlong, midpoint, tangentDirectionAlong, sampleAlong\r\n\r\n\r\n## Low level\r\n\r\nAn `ArcLengthParameterized` value is a combination of an\r\n[`ArcLengthParameterization`](Geometry-ArcLengthParameterization) and an\r\nunderlying `QuadraticSpline3d`. If you need to do something fancy, you can\r\nextract these two values separately.\r\n\r\n@docs arcLengthParameterization, fromArcLengthParameterized\r\n\r\n\r\n# Differentiation\r\n\r\nYou are unlikely to need to use these functions directly, but they are useful if\r\nyou are writing low-level geometric algorithms.\r\n\r\n@docs firstDerivative, firstDerivativesAt, secondDerivative\r\n\r\n","unions":[{"name":"ArcLengthParameterized","comment":" A spline that has been parameterized by arc length.\r\n","args":["units","coordinates"],"cases":[]},{"name":"Nondegenerate","comment":" If a curve has zero length (consists of just a single point), then we say\r\nthat it is 'degenerate'. Some operations such as computing tangent directions\r\nare not defined on degenerate curves.\r\n\r\nA `Nondegenerate` value represents a spline that is definitely not degenerate.\r\nIt is used as input to functions such as `QuadraticSpline3d.tangentDirection`\r\nand can be constructed using `QuadraticSpline3d.nondegenerate`.\r\n\r\n","args":["units","coordinates"],"cases":[]}],"aliases":[{"name":"QuadraticSpline3d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.QuadraticSpline3d units coordinates"}],"values":[{"name":"arcLength","comment":" Find the total arc length of a spline.\r\n\r\n    QuadraticSpline3d.arcLength parameterizedSpline\r\n    --> 3.8175\r\n\r\nIn this example, the result will be accurate to within `1.0e-4` since that was\r\nthe tolerance used when constructing `parameterizedSpline`.\r\n\r\n","type":"QuadraticSpline3d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"arcLengthParameterization","comment":" ","type":"QuadraticSpline3d.ArcLengthParameterized units coordinates -> Curve.ArcLengthParameterization.ArcLengthParameterization units"},{"name":"arcLengthParameterized","comment":" Build an arc length parameterization of the given spline, with a given\r\naccuracy. Generally speaking, all operations on the resulting\r\n`ArcLengthParameterized` value will be accurate to within the specified maximum\r\nerror.\r\n\r\n    parameterizedSpline =\r\n        exampleSpline\r\n            |> QuadraticSpline3d.arcLengthParameterized\r\n                { maxError = 1.0e-4 }\r\n\r\n","type":"{ maxError : Quantity.Quantity Basics.Float units } -> QuadraticSpline3d.QuadraticSpline3d units coordinates -> QuadraticSpline3d.ArcLengthParameterized units coordinates"},{"name":"bisect","comment":" Split a spline into two roughly equal halves.\r\n\r\n    QuadraticSpline3d.bisect exampleSpline\r\n    --> ( QuadraticSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 1, 1, 1 )\r\n    -->     , controlPoint =\r\n    -->         Point3d.fromCoordinates ( 2, 2.5 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 2.5 )\r\n    -->     }\r\n    --> , QuadraticSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 2.5 )\r\n    -->     , controlPoint =\r\n    -->         Point3d.fromCoordinates ( 4, 2.5 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 3, 3 )\r\n    -->     }\r\n    --> )\r\n\r\nEquivalent to `QuadraticSpline3d.splitAt ParameterValue.half`.\r\n\r\n","type":"QuadraticSpline3d.QuadraticSpline3d units coordinates -> ( QuadraticSpline3d.QuadraticSpline3d units coordinates, QuadraticSpline3d.QuadraticSpline3d units coordinates )"},{"name":"boundingBox","comment":" Compute a bounding box for a given spline. It is not guaranteed that the\r\nresult will be the _smallest_ possible bounding box, since for efficiency the\r\nbounding box is computed from the spline's control points (which cover a larger\r\nvolume than the spline itself).\r\n\r\n    QuadraticSpline3d.boundingBox exampleSpline\r\n    --> BoundingBox3d.fromExtrema\r\n    -->     { minX = 1\r\n    -->     , maxX = 3\r\n    -->     , minY = 1\r\n    -->     , maxY = 3\r\n    -->     , minZ = 1\r\n    -->     , maxZ = 3\r\n    -->     }\r\n\r\n","type":"QuadraticSpline3d.QuadraticSpline3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates"},{"name":"controlPoint","comment":" Get the control point of a spline.\r\n\r\n    QuadraticSpline3d.controlPoint exampleSpline\r\n    --> Point3d.fromCoordinates ( 3, 2, 1 )\r\n\r\n","type":"QuadraticSpline3d.QuadraticSpline3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"endDerivative","comment":" Get the end derivative of a spline. This is equal to twice the vector from\r\nthe spline's second control point to its third.\r\n\r\n    QuadraticSpline3d.endDerivative exampleSpline\r\n    --> Vector3d.fromComponents ( 0, 2, 4 )\r\n\r\n","type":"QuadraticSpline3d.QuadraticSpline3d units coordinates -> Vector3d.Vector3d units coordinates"},{"name":"endPoint","comment":" Get the end point of a spline. This is equal to the spline's last control\r\npoint.\r\n\r\n    QuadraticSpline3d.endPoint exampleSpline\r\n    --> Point3d.fromCoordinates ( 3, 3, 3 )\r\n\r\n","type":"QuadraticSpline3d.QuadraticSpline3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"firstDerivative","comment":" Get the first derivative of a spline at a given parameter value:\r\n\r\n    QuadraticSpline3d.derivative exampleSpline\r\n        ParameterValue.zero\r\n    --> Vector3d.fromComponents ( 4, 2, 0 )\r\n\r\n    QuadraticSpline3d.derivative exampleSpline\r\n        ParameterValue.half\r\n    --> Vector3d.fromComponents ( 2, 2, 2 )\r\n\r\n    QuadraticSpline3d.derivative exampleSpline\r\n        ParameterValue.one\r\n    --> Vector3d.fromComponents ( 0, 2, 4 )\r\n\r\nNote that the derivative interpolates linearly from end to end.\r\n\r\n","type":"QuadraticSpline3d.QuadraticSpline3d units coordinates -> Curve.ParameterValue.ParameterValue -> Vector3d.Vector3d units coordinates"},{"name":"firstDerivativesAt","comment":" Evaluate the first derivative of a spline at a range of parameter values:\r\n\r\n    exampleSpline\r\n        |> QuadraticSpline3d.firstDerivativesAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Vector3d.fromComponents ( 4, 2, 0 )\r\n    --> , Vector3d.fromComponents ( 2, 2, 2 )\r\n    --> , Vector3d.fromComponents ( 0, 2, 4 )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> QuadraticSpline3d.QuadraticSpline3d units coordinates -> List.List (Vector3d.Vector3d units coordinates)"},{"name":"fromArcLengthParameterized","comment":" Get the original `QuadraticSpline3d` from which an `ArcLengthParameterized`\r\nvalue was constructed.\r\n","type":"QuadraticSpline3d.ArcLengthParameterized units coordinates -> QuadraticSpline3d.QuadraticSpline3d units coordinates"},{"name":"fromNondegenerate","comment":" Convert a nondegenerate spline back to a general `QuadraticSpline3d`.\r\n\r\n    QuadraticSpline3d.fromNondegenerate\r\n        nondegenerateExampleSpline\r\n    --> exampleSpline\r\n\r\n","type":"QuadraticSpline3d.Nondegenerate units coordinates -> QuadraticSpline3d.QuadraticSpline3d units coordinates"},{"name":"midpoint","comment":" Get the midpoint of the Spline.\r\n\r\n    QuadraticSpline3d.midpoint parameterizedSpline\r\n    --> Point3d.fromCoordinates (2.4999999999999982, 1.9999999999999982, 1.499999999999998)\r\n\r\n","type":"QuadraticSpline3d.ArcLengthParameterized units coordinates -> Point3d.Point3d units coordinates"},{"name":"mirrorAcross","comment":" Mirror a spline across a plane.\r\n\r\n    QuadraticSpline3d.mirrorAcross Plane3d.xy exampleSpline\r\n    --> QuadraticSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 1, 1, -1 )\r\n    -->     , controlPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 2, -1 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 3, -3 )\r\n    -->     }\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> QuadraticSpline3d.QuadraticSpline3d units coordinates -> QuadraticSpline3d.QuadraticSpline3d units coordinates"},{"name":"nondegenerate","comment":" Attempt to construct a nondegenerate spline from a general\r\n`QuadraticSpline3d`. If the spline is in fact degenerate (consists of a single\r\npoint), returns an `Err` with that point.\r\n\r\n    QuadraticSpline3d.nondegenerate exampleSpline\r\n    --> Ok nondegenerateExampleSpline\r\n\r\n","type":"QuadraticSpline3d.QuadraticSpline3d units coordinates -> Result.Result (Point3d.Point3d units coordinates) (QuadraticSpline3d.Nondegenerate units coordinates)"},{"name":"on","comment":" Construct a 3D spline lying _on_ a sketch plane by providing a 2D spline\r\nspecified in XY coordinates _within_ the sketch plane.\r\n\r\n    QuadraticSpline3d.on SketchPlane3d.xz <|\r\n        QuadraticSpline2d.with\r\n            { startPoint =\r\n                Point2d.fromCoordinates ( 1, 1 )\r\n            , controlPoint =\r\n                Point2d.fromCoordinates ( 3, 4 )\r\n            , endPoint =\r\n                Point2d.fromCoordinates ( 5, 1 )\r\n            }\r\n    --> QuadraticSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 1, 0, 1 )\r\n    -->     , controlPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 0, 4 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 5, 0, 1 )\r\n    -->     }\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates3d coordinates2d -> QuadraticSpline2d.QuadraticSpline2d units coordinates2d -> QuadraticSpline3d.QuadraticSpline3d units coordinates3d"},{"name":"placeIn","comment":" Take a spline considered to be defined in local coordinates relative to a\r\ngiven reference frame, and return that spline expressed in global coordinates.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    QuadraticSpline3d.placeIn localFrame exampleSpline\r\n    --> QuadraticSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 2, 3, 4 )\r\n    -->     , controlPoint =\r\n    -->         Point3d.fromCoordinates ( 4, 4, 4 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 4, 5, 6 )\r\n    -->     }\r\n\r\n","type":"Frame3d.Frame3d units globalCoordinates localCoordinates -> QuadraticSpline3d.QuadraticSpline3d units localCoordinates -> QuadraticSpline3d.QuadraticSpline3d units globalCoordinates"},{"name":"pointAlong","comment":" Try to get the point along a spline at a given arc length. For example, to\r\nget the point a quarter of the way along `exampleSpline`:\r\n\r\n    QuadraticSpline3d.pointAlong parameterizedSpline\r\n        (arcLength / 4)\r\n    --> Just <|\r\n    -->     Point3d.fromCoordinates\r\n    -->         ( 1.8227, 1.4655, 1.1083 )\r\n\r\nNote that this is not the same as evaulating at a parameter value of 1/4:\r\n\r\n    QuadraticSpline3d.pointOn exampleSpline 0.25\r\n    --> Point3d.fromCoordinates ( 1.875, 1.5, 1.125 )\r\n\r\nIf the given arc length is less than zero or greater than the arc length of the\r\nspline, returns `Nothing`.\r\n\r\n","type":"QuadraticSpline3d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units -> Maybe.Maybe (Point3d.Point3d units coordinates)"},{"name":"pointOn","comment":" Get the point along a spline at a given parameter value:\r\n\r\n    QuadraticSpline3d.pointOn exampleSpline 0\r\n    --> Point3d.fromCoordinates ( 1, 1, 1 )\r\n\r\n    QuadraticSpline3d.pointOn exampleSpline 0.5\r\n    --> Point3d.fromCoordinates ( 2.5, 2, 1.5 )\r\n\r\n    QuadraticSpline3d.pointOn exampleSpline 1\r\n    --> Point3d.fromCoordinates ( 3, 3, 3 )\r\n\r\n","type":"QuadraticSpline3d.QuadraticSpline3d units coordinates -> Curve.ParameterValue.ParameterValue -> Point3d.Point3d units coordinates"},{"name":"pointsAt","comment":" Get points along a spline at a given set of parameter values:\r\n\r\n    exampleSpline\r\n        |> QuadraticSpline3d.pointsAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Point3d.fromCoordinates ( 1, 1, 1 )\r\n    --> , Point3d.fromCoordinates ( 2.5, 2, 1.5 )\r\n    --> , Point3d.fromCoordinates ( 3, 3, 3 )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> QuadraticSpline3d.QuadraticSpline3d units coordinates -> List.List (Point3d.Point3d units coordinates)"},{"name":"projectInto","comment":" Project a spline into a given sketch plane. Conceptually, finds the\r\n[orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof the spline onto the plane and then expresses the projected spline in 2D\r\nsketch coordinates.\r\n\r\n    exampleSpline\r\n        |> QuadraticSpline3d.projectInto SketchPlane3d.yz\r\n    --> QuadraticSpline2d.with\r\n    -->     { startPoint =\r\n    -->         Point2d.fromCoordinates ( 1, 1 )\r\n    -->     , controlPoint =\r\n    -->         Point2d.fromCoordinates ( 2, 1 )\r\n    -->     , endPoint =\r\n    -->         Point2d.fromCoordinates ( 3, 3 )\r\n    -->     }\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates3d coordinates2d -> QuadraticSpline3d.QuadraticSpline3d units coordinates3d -> QuadraticSpline2d.QuadraticSpline2d units coordinates2d"},{"name":"projectOnto","comment":" Find the [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof a spline onto a plane.\r\n\r\n    QuadraticSpline3d.projectOnto Plane3d.xy exampleSpline\r\n    --> QuadraticSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 1, 1, 0 )\r\n    -->     , controlPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 2, 0 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 3, 0 )\r\n    -->     }\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> QuadraticSpline3d.QuadraticSpline3d units coordinates -> QuadraticSpline3d.QuadraticSpline3d units coordinates"},{"name":"relativeTo","comment":" Take a spline defined in global coordinates, and return it expressed in\r\nlocal coordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n\r\n    QuadraticSpline3d.relativeTo localFrame exampleSpline\r\n    --> QuadraticSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 0, -1, -2 )\r\n    -->     , controlPoint =\r\n    -->         Point3d.fromCoordinates ( 2, 0, -2 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 2, 1, 0 )\r\n    -->     }\r\n\r\n","type":"Frame3d.Frame3d units globalCoordinates localCoordinates -> QuadraticSpline3d.QuadraticSpline3d units globalCoordinates -> QuadraticSpline3d.QuadraticSpline3d units localCoordinates"},{"name":"reverse","comment":" Reverse a spline so that the start point becomes the end point, and vice\r\nversa.\r\n\r\n    QuadraticSpline3d.reverse exampleSpline\r\n    --> QuadraticSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 3, 3 )\r\n    -->     , controlPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 2, 1 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 1, 1, 1 )\r\n    -->     }\r\n\r\n","type":"QuadraticSpline3d.QuadraticSpline3d units coordinates -> QuadraticSpline3d.QuadraticSpline3d units coordinates"},{"name":"rotateAround","comment":" Rotate a spline counterclockwise around a given axis by a given angle (in\r\nradians).\r\n\r\n    exampleSpline\r\n        |> QuadraticSpline3d.rotateAround Axis3d.z\r\n            (degrees 90)\r\n    --> QuadraticSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( -1, 1, 1 )\r\n    -->     , controlPoint =\r\n    -->         Point3d.fromCoordinates ( -2, 3, 1 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( -3, 3, 3 )\r\n    -->     }\r\n\r\n","type":"Axis3d.Axis3d units coordinates -> Angle.Angle -> QuadraticSpline3d.QuadraticSpline3d units coordinates -> QuadraticSpline3d.QuadraticSpline3d units coordinates"},{"name":"sample","comment":" Get both the point and tangent direction of a nondegenerate spline at a\r\ngiven parameter value:\r\n\r\n    QuadraticSpline3d.sample nondegenerateExampleSpline\r\n        ParameterValue.half\r\n    --> ( Point3d.fromCoordinates ( 2.5, 2, 1.5 )\r\n    --> , Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 45)\r\n    -->     (degrees 35.26)\r\n    --> )\r\n\r\n","type":"QuadraticSpline3d.Nondegenerate units coordinates -> Curve.ParameterValue.ParameterValue -> ( Point3d.Point3d units coordinates, Direction3d.Direction3d coordinates )"},{"name":"sampleAlong","comment":" Try to get the point and tangent direction along a spline at a given arc\r\nlength. To get the point and tangent direction a quarter of the way along\r\n`exampleSpline`:\r\n\r\n    QuadraticSpline3d.sampleAlong parameterizedSpline\r\n        (0.25 * arcLength)\r\n    --> Just\r\n    -->     ( Point3d.fromCoordinates\r\n    -->         ( 1.8227, 1.4655, 1.1083 )\r\n    -->     , Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 33.09)\r\n    -->         (degrees 14.26)\r\n    -->     )\r\n\r\nIf the given arc length is less than zero or greater than the arc length of the\r\nspline (or if the spline is degenerate), `Nothing` is returned.\r\n\r\n","type":"QuadraticSpline3d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units -> Maybe.Maybe ( Point3d.Point3d units coordinates, Direction3d.Direction3d coordinates )"},{"name":"samplesAt","comment":" Get points and tangent directions of a nondegenerate spline at a given set\r\nof parameter values:\r\n\r\n    nondegenerateExampleSpline\r\n        |> QuadraticSpline3d.samplesAt\r\n            (ParameterValue.steps 2)\r\n    --> [ ( Point3d.fromCoordinates ( 1, 1, 1 )\r\n    -->   , Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 26.57)\r\n    -->         (degrees 0)\r\n    -->   )\r\n    --> , ( Point3d.fromCoordinates ( 2.5, 2, 1.5 )\r\n    -->   , Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 45)\r\n    -->         (degrees 35.26)\r\n    -->   )\r\n    --> , ( Point3d.fromCoordinates ( 3, 3, 3 )\r\n    -->   , Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 90)\r\n    -->         (degrees 63.43)\r\n    -->   )\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> QuadraticSpline3d.Nondegenerate units coordinates -> List.List ( Point3d.Point3d units coordinates, Direction3d.Direction3d coordinates )"},{"name":"scaleAbout","comment":" Scale a spline about the given center point by the given scale.\r\n\r\n    exampleSpline\r\n        |> QuadraticSpline3d.scaleAbout Point3d.origin 2\r\n    --> QuadraticSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 2, 2, 2 )\r\n    -->     , controlPoint =\r\n    -->         Point3d.fromCoordinates ( 6, 4, 2 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 6, 6, 6 )\r\n    -->     }\r\n\r\n","type":"Point3d.Point3d units coordinates -> Basics.Float -> QuadraticSpline3d.QuadraticSpline3d units coordinates -> QuadraticSpline3d.QuadraticSpline3d units coordinates"},{"name":"secondDerivative","comment":" Get the second derivative of a spline (for a quadratic spline, this is a\r\nconstant).\r\n","type":"QuadraticSpline3d.QuadraticSpline3d units coordinates -> Vector3d.Vector3d units coordinates"},{"name":"splitAt","comment":" Split a spline at a particular parameter value, resulting in two smaller\r\nsplines.\r\n\r\n    parameterValue =\r\n        ParameterValue.clamped 0.75\r\n\r\n    QuadraticSpline3d.splitAt parameterValue exampleSpline\r\n    --> ( QuadraticSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 1, 1, 1 )\r\n    -->     , controlPoint =\r\n    -->         Point3d.fromCoordinates ( 2, 1.5, 1 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 2.5, 2, 1.5 )\r\n    -->     }\r\n    --> , QuadraticSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 2.5, 2, 1.5 )\r\n    -->     , controlPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 2.5, 2 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 3, 3 )\r\n    -->     }\r\n    --> )\r\n\r\n","type":"Curve.ParameterValue.ParameterValue -> QuadraticSpline3d.QuadraticSpline3d units coordinates -> ( QuadraticSpline3d.QuadraticSpline3d units coordinates, QuadraticSpline3d.QuadraticSpline3d units coordinates )"},{"name":"startDerivative","comment":" Get the start derivative of a spline. This is equal to twice the vector from\r\nthe spline's first control point to its second.\r\n\r\n    QuadraticSpline3d.startDerivative exampleSpline\r\n    --> Vector3d.fromComponents ( 4, 2, 0 )\r\n\r\n","type":"QuadraticSpline3d.QuadraticSpline3d units coordinates -> Vector3d.Vector3d units coordinates"},{"name":"startPoint","comment":" Get the start point of a spline.\r\n\r\n    QuadraticSpline3d.startPoint exampleSpline\r\n    --> Point3d.fromCoordinates ( 1, 1, 1 )\r\n\r\n","type":"QuadraticSpline3d.QuadraticSpline3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"tangentDirection","comment":" Get the tangent direction to a nondegenerate spline at a given parameter\r\nvalue:\r\n\r\n    QuadraticSpline3d.tangentDirection\r\n        nondegenerateExampleSpline\r\n        ParameterValue.zero\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 26.57)\r\n    -->     (degrees 0)\r\n\r\n    QuadraticSpline3d.tangentDirection\r\n        nondegenerateExampleSpline\r\n        ParameterValue.half\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 45)\r\n    -->     (degrees 35.26)\r\n\r\n    QuadraticSpline3d.tangentDirection\r\n        nondegenerateExampleSpline\r\n        ParameterValue.one\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 90)\r\n    -->     (degrees 63.43)\r\n\r\n","type":"QuadraticSpline3d.Nondegenerate units coordinates -> Curve.ParameterValue.ParameterValue -> Direction3d.Direction3d coordinates"},{"name":"tangentDirectionAlong","comment":" Try to get the tangent direction along a spline at a given arc length. To\r\nget the tangent direction a quarter of the way along `exampleSpline`:\r\n\r\n    QuadraticSpline3d.tangentDirectionAlong\r\n        parameterizedSpline\r\n        (arcLength / 4)\r\n    --> Just <|\r\n    -->     Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 33.09)\r\n    -->         (degrees 14.26)\r\n\r\nIf the given arc length is less than zero or greater than the arc length of the\r\nspline (or if the spline is degenerate), returns `Nothing`.\r\n\r\n","type":"QuadraticSpline3d.ArcLengthParameterized units coordinates -> Quantity.Quantity Basics.Float units -> Maybe.Maybe (Direction3d.Direction3d coordinates)"},{"name":"tangentDirectionsAt","comment":" Get tangent directions to a nondegenerate spline at a given set of parameter\r\nvalues:\r\n\r\n    nondegenerateExampleSpline\r\n        |> QuadraticSpline3d.tangentDirectionsAt\r\n            (ParameterValue.steps 2)\r\n    --> [ Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 26.57)\r\n    -->     (degrees 0)\r\n    --> , Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 45)\r\n    -->     (degrees 35.26)\r\n    --> , Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 90)\r\n    -->     (degrees 63.43)\r\n    --> ]\r\n\r\n","type":"List.List Curve.ParameterValue.ParameterValue -> QuadraticSpline3d.Nondegenerate units coordinates -> List.List (Direction3d.Direction3d coordinates)"},{"name":"translateBy","comment":" Translate a spline by a given displacement.\r\n\r\n    displacement =\r\n        Vector3d.fromComponents ( 2, 3, 1 )\r\n\r\n    exampleSpline\r\n        |> QuadraticSpline3d.translateBy displacement\r\n    --> QuadraticSpline3d.with\r\n    -->     { startPoint =\r\n    -->         Point3d.fromCoordinates ( 3, 4, 2 )\r\n    -->     , controlPoint =\r\n    -->         Point3d.fromCoordinates ( 5, 5, 2 )\r\n    -->     , endPoint =\r\n    -->         Point3d.fromCoordinates ( 5, 6, 4 )\r\n    -->     }\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> QuadraticSpline3d.QuadraticSpline3d units coordinates -> QuadraticSpline3d.QuadraticSpline3d units coordinates"},{"name":"translateIn","comment":" Translate an arc in a given direction by a given distance;\r\n\r\n    QuadraticSpline3d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    QuadraticSpline3d.translateBy\r\n        (Vector3d.withLength distance direction)\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Quantity.Quantity Basics.Float units -> QuadraticSpline3d.QuadraticSpline3d units coordinates -> QuadraticSpline3d.QuadraticSpline3d units coordinates"},{"name":"with","comment":" Construct a spline from its start point, control point and end point:\r\n\r\n    exampleSpline =\r\n        QuadraticSpline3d.with\r\n            { startPoint =\r\n                Point3d.fromCoordinates ( 1, 1, 1 )\r\n            , controlPoint =\r\n                Point3d.fromCoordinates ( 3, 2, 1 )\r\n            , endPoint =\r\n                Point3d.fromCoordinates ( 3, 3, 3 )\r\n            }\r\n\r\n","type":"{ startPoint : Point3d.Point3d units coordinates, controlPoint : Point3d.Point3d units coordinates, endPoint : Point3d.Point3d units coordinates } -> QuadraticSpline3d.QuadraticSpline3d units coordinates"}],"binops":[]},{"name":"Rectangle2d","comment":" A `Rectangle2d` represents a rectangle in 2D space. This module contains\r\nrectangle-related functionality such as:\r\n\r\n  - Constructing rectangles in various ways\r\n  - Extracting rectangle vertices and edges\r\n  - Scaling, rotating, translating and mirroring rectangles\r\n  - Converting rectangles between different coordinate systems\r\n\r\nUnlike bounding boxes, rectangles are _not_ constrained to be axis-aligned -\r\nthey can have arbitrary orientation and so can be rotated, mirrored etc.\r\n\r\n@docs Rectangle2d, RectangleCoordinates\r\n\r\n\r\n# Construction\r\n\r\n@docs from, centeredOn, fromExtrema, fromExtremaIn\r\n\r\n\r\n# Properties\r\n\r\n@docs dimensions, axes, xAxis, yAxis, centerPoint, area\r\n@docs vertices, bottomLeftVertex, bottomRightVertex, topLeftVertex, topRightVertex\r\n@docs edges, leftEdge, bottomEdge, rightEdge, topEdge\r\n@docs boundingBox\r\n\r\n\r\n# Querying\r\n\r\n@docs contains\r\n\r\n\r\n# Conversion\r\n\r\n@docs toPolygon\r\n\r\n\r\n# Transformation\r\n\r\n@docs scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n","unions":[],"aliases":[{"name":"Rectangle2d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Rectangle2d units coordinates"},{"name":"RectangleCoordinates","comment":" The coordinate system associated with the central axes of a rectangle.\r\n","args":[],"type":"Geometry.Types.RectangleCoordinates"}],"values":[{"name":"area","comment":" Get the area of a rectangle:\r\n\r\n    rectangle =\r\n        Rectangle2d.fromExtrema\r\n            { minX = 2\r\n            , maxX = 5\r\n            , minY = 1\r\n            , maxY = 3\r\n            }\r\n\r\n    Rectangle2d.area rectangle\r\n    --> 6\r\n\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Squared units)"},{"name":"axes","comment":" Get the central axes of a rectangle as a `Frame2d`:\r\n\r\n    rectangle =\r\n        Rectangle2d.fromExtrema\r\n            { minX = 2\r\n            , maxX = 5\r\n            , minY = 1\r\n            , maxY = 3\r\n            }\r\n\r\n    Rectangle2d.axes rectangle\r\n    --> Frame2d.atCoordinates ( 3.5, 2 )\r\n\r\nThe origin point of the frame will be the center point of the rectangle.\r\n\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> Frame2d.Frame2d units coordinates Rectangle2d.RectangleCoordinates"},{"name":"bottomEdge","comment":" Get the bottom edge of a rectangle;\r\n\r\n    Rectangle2d.bottomEdge rectangle\r\n\r\nis equivalent to\r\n\r\n    (Rectangle2d.edges rectangle).bottom\r\n\r\nbut is more efficient.\r\n\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> LineSegment2d.LineSegment2d units coordinates"},{"name":"bottomLeftVertex","comment":" Get the bottom left vertex of a rectangle;\r\n\r\n    Rectangle2d.bottomLeftVertex rectangle\r\n\r\nis equivalent to\r\n\r\n    (Rectangle2d.vertices rectangle).bottomLeft\r\n\r\nbut is more efficient.\r\n\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"bottomRightVertex","comment":" Get the bottom right vertex of a rectangle;\r\n\r\n    Rectangle2d.bottomRightVertex rectangle\r\n\r\nis equivalent to\r\n\r\n    (Rectangle2d.vertices rectangle).bottomRight\r\n\r\nbut is more efficient.\r\n\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"boundingBox","comment":" Get the minimal bounding box containing a given rectangle. This have\r\nexactly the same shape and size as the rectangle itself if the rectangle is\r\naxis-aligned, but will be larger than the rectangle if the rectangle is at an\r\nangle.\r\n\r\n    square =\r\n        Rectangle2d.fromExtrema\r\n            { minX = 0\r\n            , maxX = 1\r\n            , minY = 0\r\n            , maxY = 1\r\n            }\r\n\r\n    diamond =\r\n        square\r\n            |> Rectangle2d.rotateAround Point2d.origin\r\n                (degrees 45)\r\n\r\n    Rectangle2d.boundingBox diamond\r\n    --> BoundingBox2d.fromExtrema\r\n    -->     { minX = -0.7071\r\n    -->     , maxX = 0.7071\r\n    -->     , minY = 0\r\n    -->     , maxY = 1.4142\r\n    -->     }\r\n\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates"},{"name":"centerPoint","comment":" Get the center point of a rectangle.\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"centeredOn","comment":" Construct a rectangle centered on the given axes (frame), with the given\r\noverall X/Y dimensions (width/height).\r\n\r\n    frame =\r\n        Frame2d.atCoordinates ( 3, 2 )\r\n\r\n    rectangle =\r\n        Rectangle2d.centeredOn frame ( 4, 3 )\r\n\r\n    Rectangle2d.vertices rectangle\r\n    --> { bottomLeft = Point2d.fromCoordinates ( 1, 0.5 )\r\n    --> , bottomRight = Point2d.fromCoordinates ( 5, 0.5 )\r\n    --> , topLeft = Point2d.fromCoordinates ( 1, 3.5 )\r\n    --> , topRight = Point2d.fromCoordinates ( 5, 3.5 )\r\n    --> }\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> ( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units ) -> Rectangle2d.Rectangle2d units globalCoordinates"},{"name":"contains","comment":" Check if a rectangle contains a given point:\r\n\r\n    rectangle =\r\n        Rectangle2d.fromExtrema\r\n            { minX = 2\r\n            , maxX = 5\r\n            , minY = 1\r\n            , maxY = 3\r\n            }\r\n\r\n    p1 =\r\n        Point2d.fromCoordinates ( 3, 2 )\r\n\r\n    p2 =\r\n        Point2d.fromCoordinates ( 3, 4 )\r\n\r\n    rectangle |> Rectangle2d.contains p1\r\n    --> True\r\n\r\n    rectangle |> Rectangle2d.contains p2\r\n    --> False\r\n\r\n","type":"Point2d.Point2d units coordinates -> Rectangle2d.Rectangle2d units coordinates -> Basics.Bool"},{"name":"dimensions","comment":" Get the overall dimensions (width and height) of a rectangle:\r\n\r\n    rectangle =\r\n        Rectangle2d.fromExtrema\r\n            { minX = 2\r\n            , maxX = 5\r\n            , minY = 1\r\n            , maxY = 3\r\n            }\r\n\r\n    Rectangle2d.dimensions rectangle\r\n    --> ( 3, 2 )\r\n\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> ( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units )"},{"name":"edges","comment":" Get the edges of a rectangle as a record. Note that 'bottom', 'top',\r\n'left' and 'right' are with respect to the rectangle's axes, so the may not\r\ncorrespond to global up/down or left/right if the rectangle has been rotated or\r\nmirrored. The orientation of each edge is chosen so that it will be in a\r\ncounterclockwise direction (unless the rectangle has been mirrored):\r\n\r\n  - The `bottom` edge is from the bottom left to bottom right vertex\r\n  - The `right` edge is from the bottom right to top right vertex\r\n  - The `top` edge is from the top right to top left vertex\r\n  - The `left` edge is from the top left to bottom left vertex\r\n\r\n(Note that this ordering will lead to each edge being in a clockwise direction\r\nif the rectangle _has_ been mirrored.)\r\n\r\n    rectangle =\r\n        Rectangle2d.fromExtrema\r\n            { minX = 2\r\n            , maxX = 5\r\n            , minY = 1\r\n            , maxY = 3\r\n            }\r\n\r\n    Rectangle2d.edges rectangle\r\n    --> { bottom =\r\n    -->     LineSegment2d.fromEndpoints\r\n    -->         ( Point2d.fromCoordinates ( 2, 1 )\r\n    -->         , Point2d.fromCoordinates ( 5, 1 )\r\n    -->         )\r\n    --> , right =\r\n    -->     LineSegment2d.fromEndpoints\r\n    -->         ( Point2d.fromCoordinates ( 5, 1 )\r\n    -->         , Point2d.fromCoordinates ( 5, 3 )\r\n    -->         )\r\n    --> , top =\r\n    -->     LineSegment2d.fromEndpoints\r\n    -->         ( Point2d.fromCoordinates ( 5, 3 )\r\n    -->         , Point2d.fromCoordinates ( 2, 3 )\r\n    -->         )\r\n    --> , left =\r\n    -->     LineSegment2d.fromEndpoints\r\n    -->         ( Point2d.fromCoordinates ( 2, 3 )\r\n    -->         , Point2d.fromCoordinates ( 2, 1 )\r\n    -->         )\r\n    --> }\r\n\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> { bottom : LineSegment2d.LineSegment2d units coordinates, right : LineSegment2d.LineSegment2d units coordinates, top : LineSegment2d.LineSegment2d units coordinates, left : LineSegment2d.LineSegment2d units coordinates }"},{"name":"from","comment":" Construct an axis-aligned rectangle stretching from one point to another.\r\nThe order of the points does not matter, and they can represent either the\r\nlower left and upper right vertices or the upper left and lower right.\r\n\r\n    p1 =\r\n        Point2d.fromCoordinates ( 5, 2 )\r\n\r\n    p2 =\r\n        Point2d.fromCoordinates ( 1, 4 )\r\n\r\n    Rectangle2d.from p1 p2\r\n    --> Rectangle2d.fromExtrema\r\n    -->     { minX = 1\r\n    -->     , maxX = 5\r\n    -->     , minY = 2\r\n    -->     , maxY = 4\r\n    -->     }\r\n\r\n","type":"Point2d.Point2d units coordinates -> Point2d.Point2d units coordinates -> Rectangle2d.Rectangle2d units coordinates"},{"name":"fromExtrema","comment":" Construct an axis-aligned rectangle by specifying its minimum and maximum\r\nX and Y coordinates. If the min and max are given in the wrong order, they will\r\nbe swapped.\r\n\r\n    rectangle =\r\n        Rectangle2d.fromExtrema\r\n            { minX = 2\r\n            , maxX = 5\r\n            , minY = 1\r\n            , maxY = 3\r\n            }\r\n\r\n    Rectangle2d.vertices rectangle\r\n    --> { bottomLeft = Point2d.fromCoordinates ( 2, 1 )\r\n    --> , bottomRight = Point2d.fromCoordinates ( 5, 1 )\r\n    --> , topLeft = Point2d.fromCoordinates ( 2, 3 )\r\n    --> , topRight = Point2d.fromCoordinates ( 5, 3 )\r\n    --> }\r\n\r\n","type":"{ minX : Quantity.Quantity Basics.Float units, maxX : Quantity.Quantity Basics.Float units, minY : Quantity.Quantity Basics.Float units, maxY : Quantity.Quantity Basics.Float units } -> Rectangle2d.Rectangle2d units coordinates"},{"name":"fromExtremaIn","comment":" Construct a rectangle by supplying its maximum and minimum X and Y values\r\nwithin a particular frame:\r\n\r\n    frame =\r\n        Frame2d.atCoordinates ( 5, 4 )\r\n\r\n    Rectangle2d.fromExtremaIn frame\r\n        { minX = -1\r\n        , minY = -1\r\n        , maxX = 3\r\n        , maxY = 2\r\n        }\r\n    --> Rectangle2d.fromExtrema\r\n    -->     { minX = 4\r\n    -->     , minY = 3\r\n    -->     , maxX = 8\r\n    -->     , maxY = 6\r\n    -->     }\r\n\r\nNote that for simplicity we used a non-rotated frame in the above example - if\r\nwe had used a rotated frame, the result could not have been expressed using\r\n`Rectangle2d.fromExtrema` since it would no longer have been axis-aligned.\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> { minX : Quantity.Quantity Basics.Float units, maxX : Quantity.Quantity Basics.Float units, minY : Quantity.Quantity Basics.Float units, maxY : Quantity.Quantity Basics.Float units } -> Rectangle2d.Rectangle2d units globalCoordinates"},{"name":"leftEdge","comment":" Get the left edge of a rectangle;\r\n\r\n    Rectangle2d.leftEdge rectangle\r\n\r\nis equivalent to\r\n\r\n    (Rectangle2d.edges rectangle).left\r\n\r\nbut is more efficient.\r\n\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> LineSegment2d.LineSegment2d units coordinates"},{"name":"mirrorAcross","comment":" Mirror a rectangle across a given axis.\r\n\r\n    rectangle =\r\n        Rectangle2d.fromExtrema\r\n            { minX = 2\r\n            , maxX = 5\r\n            , minY = 1\r\n            , maxY = 3\r\n            }\r\n\r\n    Rectangle2d.mirrorAcross Axis2d.x rectangle\r\n    --> Rectangle2d.fromExtrema\r\n    -->     { minX = 2\r\n    -->     , maxX = 5\r\n    -->     , minY = -3\r\n    -->     , maxY = -1\r\n    -->     }\r\n\r\nNote that this will flip the handedness of the rectangle's axes, and therefore\r\nthe order/direction of results from `Rectangle2d.vertices` and\r\n`Rectangle2d.edges` will change.\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> Rectangle2d.Rectangle2d units coordinates -> Rectangle2d.Rectangle2d units coordinates"},{"name":"placeIn","comment":" Take a rectangle considered to be defined in local coordinates relative to a\r\ngiven reference frame, and return that rectangle expressed in global\r\ncoordinates.\r\n\r\n    rectangle =\r\n        Rectangle2d.fromExtrema\r\n            { minX = 2\r\n            , maxX = 5\r\n            , minY = 1\r\n            , maxY = 3\r\n            }\r\n\r\n    localFrame =\r\n        Frame2d.atCoordinates ( 1, 2 )\r\n\r\n    Rectangle2d.placeIn localFrame rectangle\r\n    --> Rectangle2d.fromExtrema\r\n    -->     { minX = 3\r\n    -->     , maxX = 6\r\n    -->     , minY = 3\r\n    -->     , maxY = 5\r\n    -->     }\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> Rectangle2d.Rectangle2d units localCoordinates -> Rectangle2d.Rectangle2d units globalCoordinates"},{"name":"relativeTo","comment":" Take a rectangle defined in global coordinates, and return it expressed\r\nin local coordinates relative to a given reference frame.\r\n\r\n    rectangle =\r\n        Rectangle2d.fromExtrema\r\n            { minX = 2\r\n            , maxX = 5\r\n            , minY = 1\r\n            , maxY = 3\r\n            }\r\n\r\n    localFrame =\r\n        Frame2d.atCoordinates ( 1, 2 )\r\n\r\n    Rectangle2d.relativeTo localFrame rectangle\r\n    --> Rectangle2d.fromExtrema\r\n    -->     { minX = 1\r\n    -->     , maxX = 4\r\n    -->     , minY = -1\r\n    -->     , maxY = 1\r\n    -->     }\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> Rectangle2d.Rectangle2d units globalCoordinates -> Rectangle2d.Rectangle2d units localCoordinates"},{"name":"rightEdge","comment":" Get the right edge of a rectangle;\r\n\r\n    Rectangle2d.rightEdge rectangle\r\n\r\nis equivalent to\r\n\r\n    (Rectangle2d.edges rectangle).right\r\n\r\nbut is more efficient.\r\n\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> LineSegment2d.LineSegment2d units coordinates"},{"name":"rotateAround","comment":" Rotate a rectangle around a given point by a given angle (in radians).\r\n\r\n    rectangle =\r\n        Rectangle2d.fromExtrema\r\n            { minX = 0\r\n            , maxX = 1\r\n            , minY = 0\r\n            , maxY = 1\r\n            }\r\n\r\n    rotated =\r\n        rectangle\r\n            |> Rectangle2d.rotateAround Point2d.origin\r\n                (degrees 45)\r\n\r\n    Rectangle2d.centerPoint rotated\r\n    --> Point2d.fromCoordinates ( 0, 0.7071 )\r\n\r\n    Rectangle2d.xDirection rotated\r\n    --> Direction2d.fromAngle (degrees 45)\r\n\r\n    Rectangle2d.vertices rotated\r\n    --> { bottomLeft =\r\n    -->     Point2d.origin\r\n    --> , bottomRight =\r\n    -->     Point2d.fromCoordinates ( 0.7071, 0.7071 )\r\n    --> , topRight =\r\n    -->     Point2d.fromCoordinates ( 0, 1.4142 )\r\n    --> , topLeft =\r\n    -->     Point2d.fromCoordinates ( -0.7071, 0.7071 )\r\n    --> }\r\n\r\n","type":"Point2d.Point2d units coordinates -> Angle.Angle -> Rectangle2d.Rectangle2d units coordinates -> Rectangle2d.Rectangle2d units coordinates"},{"name":"scaleAbout","comment":" Scale a rectangle about a given point by a given scale.\r\n\r\n    rectangle =\r\n        Rectangle2d.fromExtrema\r\n            { minX = 2\r\n            , maxX = 5\r\n            , minY = 1\r\n            , maxY = 3\r\n            }\r\n\r\n    rectangle\r\n        |> Rectangle2d.scaleAbout Point2d.origin 2\r\n    --> Rectangle2d.fromExtrema\r\n    -->     { minX = 4\r\n    -->     , maxX = 10\r\n    -->     , minY = 2\r\n    -->     , maxY = 6\r\n    -->     }\r\n\r\nNote that scaling by a negative value will flip the handedness of the\r\nrectangle's axes, and therefore the order/direction of results from\r\n`Rectangle2d.vertices` and `Rectangle2d.edges` will change.\r\n\r\n","type":"Point2d.Point2d units coordinates -> Basics.Float -> Rectangle2d.Rectangle2d units coordinates -> Rectangle2d.Rectangle2d units coordinates"},{"name":"toPolygon","comment":" Convert a rectangle to a [`Polygon2d`](Polygon2d#Polygon2d).\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> Polygon2d.Polygon2d units coordinates"},{"name":"topEdge","comment":" Get the top edge of a rectangle;\r\n\r\n    Rectangle2d.topEdge rectangle\r\n\r\nis equivalent to\r\n\r\n    (Rectangle2d.edges rectangle).top\r\n\r\nbut is more efficient.\r\n\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> LineSegment2d.LineSegment2d units coordinates"},{"name":"topLeftVertex","comment":" Get the top left vertex of a rectangle;\r\n\r\n    Rectangle2d.topLeftVertex rectangle\r\n\r\nis equivalent to\r\n\r\n    (Rectangle2d.vertices rectangle).topLeft\r\n\r\nbut is more efficient.\r\n\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"topRightVertex","comment":" Get the top right vertex of a rectangle;\r\n\r\n    Rectangle2d.topRightVertex rectangle\r\n\r\nis equivalent to\r\n\r\n    (Rectangle2d.vertices rectangle).topRight\r\n\r\nbut is more efficient.\r\n\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"translateBy","comment":" Translate a rectangle by a given displacement.\r\n\r\n    rectangle =\r\n        Rectangle2d.fromExtrema\r\n            { minX = 2\r\n            , maxX = 5\r\n            , minY = 1\r\n            , maxY = 3\r\n            }\r\n\r\n    displacement =\r\n        Vector2d.fromComponents ( 2, -3 )\r\n\r\n    Rectangle2d.translateBy displacement rectangle\r\n    --> Rectangle2d.fromExtrema\r\n    -->     { minX = 4\r\n    -->     , maxX = 7\r\n    -->     , minY = -2\r\n    -->     , maxY = 0\r\n    -->     }\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Rectangle2d.Rectangle2d units coordinates -> Rectangle2d.Rectangle2d units coordinates"},{"name":"translateIn","comment":" Translate a rectangle in a given direction by a given distance;\r\n\r\n    Rectangle2d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    Rectangle2d.translateBy\r\n        (Vector2d.withLength distance direction)\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Quantity.Quantity Basics.Float units -> Rectangle2d.Rectangle2d units coordinates -> Rectangle2d.Rectangle2d units coordinates"},{"name":"vertices","comment":" Get the vertices of a rectangle as a record. Note that 'bottom', 'top',\r\n'left' and 'right' are with respect to the rectangle's axes, so the may not\r\ncorrespond to global up/down or left/right if the rectangle has been rotated or\r\nmirrored.\r\n\r\n    rectangle =\r\n        Rectangle2d.fromExtrema\r\n            { minX = 2\r\n            , maxX = 5\r\n            , minY = 1\r\n            , maxY = 3\r\n            }\r\n\r\n    Rectangle2d.vertices rectangle\r\n    --> { bottomLeft = Point2d.fromCoordinates ( 2, 1 )\r\n    --> , bottomRight = Point2d.fromCoordinates ( 5, 1 )\r\n    --> , topLeft = Point2d.fromCoordinates ( 2, 3 )\r\n    --> , topRight = Point2d.fromCoordinates ( 5, 3 )\r\n    --> }\r\n\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> { bottomLeft : Point2d.Point2d units coordinates, bottomRight : Point2d.Point2d units coordinates, topRight : Point2d.Point2d units coordinates, topLeft : Point2d.Point2d units coordinates }"},{"name":"xAxis","comment":" Get the X axis of a rectangle;\r\n\r\n    Rectangle2d.xAxis rectangle\r\n\r\nis equivalent to\r\n\r\n    Frame2d.xAxis (Rectangle2d.axes rectangle)\r\n\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> Axis2d.Axis2d units coordinates"},{"name":"yAxis","comment":" Get the Y axis of a rectangle;\r\n\r\n    Rectangle2d.yAxis rectangle\r\n\r\nis equivalent to\r\n\r\n    Frame2d.yAxis (Rectangle2d.axes rectangle)\r\n\r\n","type":"Rectangle2d.Rectangle2d units coordinates -> Axis2d.Axis2d units coordinates"}],"binops":[]},{"name":"SketchPlane3d","comment":" A `SketchPlane3d` represents a 2D planar coordinate system in 3D space, and\r\nis defined by its origin point and X and Y directions (which are always\r\nperpendicular to each other). Sketch planes are the primary tool for converting\r\nback and forth between 2D and 3D coordinates:\r\n\r\n  - 3D geometry such as points, directions and line segments can be projected\r\n    _into_ a sketch plane, which effectively projects the geometry _onto_ the\r\n    sketch plane and then expresses the projected geometry _in_ 2D coordinates.\r\n  - 2D geometry can be place _onto_ a sketch plane to result in 3D geometry. For\r\n    example, a 2D point placed onto a sketch plane will result in a 3D point\r\n    _on_ that sketch plane that has the given 2D coordinate _in_ the sketch\r\n    plane.\r\n\r\nThis allows you to create algorithms that project from 3D into 2D, perform some\r\ncalculations in 2D, then convert the result back to 3D.\r\n\r\nMany 3D data types have `projectInto` functions that return the corresponding 2D\r\ndata type, and `on` functions for converting back to 3D. For example,\r\n[`Triangle3d.projectInto`](Triangle3d#projectInto) returns a `Triangle2d` and\r\n[`Triangle3d.on`](Triangle3d#on) returns a `Triangle3d`. These pairs of\r\nfunctions are almost, but not quite, inverses of each other:\r\n\r\n    triangle2d\r\n        |> Triangle3d.on sketchPlane\r\n        |> Triangle3d.projectInto sketchPlane\r\n\r\nwill just return the original `triangle2d` value (within roundoff error), while\r\n\r\n    triangle3d\r\n        |> Triangle3d.projectInto sketchPlane\r\n        |> Triangle3d.on sketchPlane\r\n\r\nis equivalent to\r\n\r\n    triangle3d\r\n        |> Triangle3d.projectOnto\r\n            (SketchPlane3d.toPlane sketchPlane)\r\n\r\n@docs SketchPlane3d\r\n\r\n\r\n# Constants\r\n\r\nThese predefined sketch planes all have the global origin point as their origin\r\npoint, and use the two indicated global axes as their X and Y axes. For example,\r\n\r\n    SketchPlane3d.originPoint SketchPlane3d.yz\r\n    --> Point3d.origin\r\n\r\n    SketchPlane3d.xDirection SketchPlane3d.yz\r\n    --> Direction3d.y\r\n\r\n    SketchPlane3d.yDirection SketchPlane3d.yz\r\n    --> Direction3d.z\r\n\r\n@docs xy, yx, yz, zy, zx, xz\r\n\r\n\r\n# Constructors\r\n\r\nSketch planes can also be constructed from `Frame3d` values using\r\n`Frame3d.xySketchPlane` etc.\r\n\r\n@docs withNormalDirection, on, throughPoints, fromPlane, copy, unsafe\r\n\r\n\r\n# Conversions\r\n\r\n@docs toPlane\r\n\r\n\r\n# Properties\r\n\r\n@docs originPoint, xDirection, yDirection, normalDirection, xAxis, yAxis, normalAxis\r\n\r\n\r\n# Transformations\r\n\r\n@docs offsetBy, reverseX, reverseY, moveTo, rotateAround, rotateAroundOwn, translateBy, translateIn, translateAlongOwn, mirrorAcross\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n","unions":[],"aliases":[{"name":"SketchPlane3d","comment":" ","args":["units","coordinates1","coordinates2"],"type":"Geometry.Types.SketchPlane3d units coordinates1 coordinates2"}],"values":[{"name":"copy","comment":" Create a 'fresh copy' of a sketch plane: one with the same origin point and\r\nX/Y directions, but that can be used to define a different local coordinate\r\nsystem. Sometimes useful in generic/library code.\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"fromPlane","comment":" Construct a SketchPlane3d from the given plane;\r\n\r\n    SketchPlane3d.fromPlane plane\r\n\r\nis equivalent to\r\n\r\n    SketchPlane3d.withNormalDirection\r\n        (Plane3d.normalDirection plane)\r\n        (Plane3d.originPoint plane)\r\n\r\nNote that because the X and Y directions of the resulting sketch plane are\r\nchosen arbitrarily, conversions may not work exactly as you expect. For example,\r\nin the current implementation,\r\n\r\n    sketchPlane =\r\n        SketchPlane3d.fromPlane Plane3d.xy\r\n\r\nis not equal to `SketchPlane3d.xy` (although the two sketch planes have the same\r\norigin point and are coplanar):\r\n\r\n    SketchPlane3d.originPoint sketchPlane\r\n    --> Point3d.origin\r\n\r\n    SketchPlane3d.xDirection sketchPlane\r\n    --> Direction3d.negativeY\r\n\r\n    SketchPlane3d.yDirection sketchPlane\r\n    --> Direction3d.positiveX\r\n\r\n","type":"Plane3d.Plane3d units coordinates1 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates2"},{"name":"mirrorAcross","comment":" Mirror a sketch plane across a plane.\r\n\r\n    sketchPlane =\r\n        SketchPlane3d.yz\r\n            |> SketchPlane3d.moveTo\r\n                (Point2d.fromCoordinates ( 2, 1, 3 ))\r\n\r\n    mirroredSketchPlane =\r\n        SketchPlane3d.mirrorAcross Plane3d.xy sketchPlane\r\n\r\n    SketchPlane3d.originPoint sketchPlane\r\n    --> Point2d.fromCoordinates ( 2, 1, -3 )\r\n\r\n    SketchPlane3d.xDirection sketchPlane\r\n    --> Direction3d.y\r\n\r\n    SketchPlane3d.yDirection sketchPlane\r\n    --> Direction3d.negativeZ\r\n\r\n","type":"Plane3d.Plane3d units coordinates1 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"moveTo","comment":" Set the origin point of the given sketch plane to the given point, leaving\r\nits X and Y directions unchanged.\r\n\r\n    newOrigin =\r\n        Point3d.fromCoordinates ( 2, 1, 3 )\r\n\r\n    sketchPlane =\r\n        SketchPlane3d.moveTo newOrigin SketchPlane3d.yz\r\n\r\n    SketchPlane3d.originPoint sketchPlane\r\n    --> newOrigin\r\n\r\n    SketchPlane3d.xDirection sketchPlane\r\n    --> Direction3d.y\r\n\r\n    SketchPlane3d.yDirection sketchPlane\r\n    --> Direction3d.z\r\n\r\n","type":"Point3d.Point3d units coordinates1 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"normalAxis","comment":" Get the normal axis to a sketch plane (the axis formed from the sketch\r\nplane's origin point and normal direction).\r\n\r\n    SketchPlane3d.normalAxis SketchPlane3d.xy\r\n    --> Axis3d.z\r\n\r\n    SketchPlane3d.normalAxis SketchPlane3d.xz\r\n    --> Axis3d.reverse Axis3d.y\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> Axis3d.Axis3d units coordinates1"},{"name":"normalDirection","comment":" Get the normal direction to a sketch plane. This is equal to the cross\r\nproduct of the sketch plane's X and Y directions.\r\n\r\n    SketchPlane3d.normalDirection SketchPlane3d.xy\r\n    --> Direction3d.z\r\n\r\n    SketchPlane3d.normalDirection SketchPlane3d.xz\r\n    --> Direction3d.negativeY\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> Direction3d.Direction3d coordinates1"},{"name":"offsetBy","comment":" Shift a sketch plane in its own normal direction by the given (signed)\r\ndistance.\r\n\r\n    SketchPlane3d.offsetBy -2.0 SketchPlane3d.xy\r\n        |> SketchPlane3d.originPoint\r\n    --> Point3d.fromCoordinates ( 0, 0, -2 )\r\n\r\n    SketchPlane3d.offsetBy 1.0 SketchPlane3d.zx\r\n        |> SketchPlane3d.originPoint\r\n    --> Point3d.fromCoordinates ( 0, 1, 0 )\r\n\r\n","type":"Quantity.Quantity Basics.Float units -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"on","comment":" Construct one sketch plane lying on another sketch plane, but with a\r\ndifferent origin point and X/Y directions. To do this, a `Frame2d` must be\r\nprovided that specifies the origin point and X/Y directions of the new sketch\r\nplane, in 2D coordinates within the existing sketch plane. Whew!\r\n\r\n    frame2d =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 2, 3 ))\r\n            |> Frame2d.rotateBy (degrees -30)\r\n\r\n    sketchPlane =\r\n        SketchPlane3d.on SketchPlane3d.yz frame2d\r\n\r\n    SketchPlane3d.originPoint sketchPlane\r\n    --> Point3d.fromCoordinates ( 0, 2, 3 )\r\n\r\n    SketchPlane3d.xDirection sketchPlane\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 90)\r\n    -->     (degrees -30)\r\n\r\n    SketchPlane3d.yDirection sketchPlane\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 90)\r\n    -->     (degrees 60)\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> Frame2d.Frame2d units coordinates2 coordinates3 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"originPoint","comment":" Get the origin point of a sketch plane.\r\n\r\n    SketchPlane3d.originPoint SketchPlane3d.xy\r\n    --> Point3d.origin\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> Point3d.Point3d units coordinates1"},{"name":"placeIn","comment":" Take a sketch plane defined in local coordinates relative to a given\r\nreference frame, and return that sketch plane expressed in global coordinates.\r\n","type":"Geometry.Types.Frame3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates2 coordinates3 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"relativeTo","comment":" Take a sketch plane defined in global coordinates, and return it expressed\r\nin local coordinates relative to a given reference frame.\r\n","type":"Geometry.Types.Frame3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3 -> SketchPlane3d.SketchPlane3d units coordinates2 coordinates3"},{"name":"reverseX","comment":" Reverse the X direction of a sketch plane, leaving its Y direction and\r\norigin point unchanged.\r\n\r\n    sketchPlane =\r\n        SketchPlane3d.reverseX SketchPlane3d.yz\r\n\r\n    SketchPlane3d.originPoint sketchPlane\r\n    --> Point3d.origin\r\n\r\n    SketchPlane3d.xDirection sketchPlane\r\n    --> Direction3d.negativeY\r\n\r\n    SketchPlane3d.yDirection sketchPlane\r\n    --> Direction3d.z\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"reverseY","comment":" Reverse the Y direction of a sketch plane, leaving its X direction and\r\norigin point unchanged.\r\n\r\n    sketchPlane =\r\n        SketchPlane3d.reverseY SketchPlane3d.yz\r\n\r\n    SketchPlane3d.originPoint sketchPlane\r\n    --> Point3d.origin\r\n\r\n    SketchPlane3d.xDirection sketchPlane\r\n    --> Direction3d.y\r\n\r\n    SketchPlane3d.yDirection sketchPlane\r\n    --> Direction3d.negativeZ\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"rotateAround","comment":" Rotate a sketch plane around an axis by a given angle (in radians). The\r\nsketch plane's origin point and X and Y directions will all be rotated around\r\nthe given axis.\r\n\r\n    SketchPlane3d.xy\r\n        |> SketchPlane3d.rotateAround Axis3d.x (degrees 90)\r\n    --> SketchPlane3d.xz\r\n\r\n","type":"Axis3d.Axis3d units coordinates1 -> Angle.Angle -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"rotateAroundOwn","comment":" Rotate a sketch plane around one of its own axes by a given angle (in\r\nradians).\r\n\r\nThe first argument is a function that returns the axis to rotate around, given\r\nthe current sketch plane. The majority of the time this will be either\r\n`SketchPlane3d.xAxis` or `SketchPlane3d.yAxis`.\r\n\r\nThis function is convenient when constructing sketch planes via a series of\r\ntransformations. For example,\r\n\r\n    sketchPlane =\r\n        SketchPlane3d.xy\r\n            |> SketchPlane3d.translateBy\r\n                (Vector3d.fromComponents ( 1, 0, 0 ))\r\n            |> SketchPlane3d.rotateAroundOwn\r\n                SketchPlane3d.yAxis\r\n                (degrees -45)\r\n\r\n    SketchPlane3d.originPoint sketchPlane\r\n    --> Point3d.fromCoordinates ( 1, 0, 0 )\r\n\r\n    SketchPlane3d.xDirection sketchPlane\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 0)\r\n    -->     (degrees 45)\r\n\r\n    SketchPlane3d.yDirection sketchPlane\r\n    --> Direction3d.y\r\n\r\nNote that since the rotation was around the sketch plane's own Y axis (which\r\npasses through the sketch plane's origin point) instead of the global Y axis,\r\nthe origin point itself was not affected by the rotation.\r\n\r\n","type":"(SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> Axis3d.Axis3d units coordinates1) -> Angle.Angle -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"throughPoints","comment":" Attempt to construct a sketch plane that passes through the three given\r\npoints. Returns a sketch plane where:\r\n\r\n  - The origin point is the first given point\r\n  - The X direction is equal to the direction from the first given point to the\r\n    second\r\n  - The Y direction is chosen such that the third given point lies on the sketch\r\n    plane and has a positive Y coordinate within the sketch plane (that is, it\r\n    is on the positive Y side of the sketch plane's X axis)\r\n\r\nIf the three given points are collinear, returns `Nothing`.\r\n\r\n    SketchPlane3d.throughPoints\r\n        (Point3d.fromCoordinates ( 2, 0, 0 ))\r\n        (Point3d.fromCoordinates ( 3, 0, 0 ))\r\n        (Point3d.fromCoordinates ( 4, 1, 1 ))\r\n    --> Just sketchPlane\r\n\r\n    SketchPlane3d.originPoint sketchPlane\r\n    --> Point3d.fromCoordinates ( 2, 0, 0 )\r\n\r\n    SketchPlane3d.xDirection sketchPlane\r\n    --> Direction3d.x\r\n\r\n    SketchPlane3d.yDirection sketchPlane\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 90)\r\n    -->     (degrees 45)\r\n\r\n    SketchPlane3d.throughPoints\r\n        (Point3d.fromCoordinates ( 2, 0, 0 ))\r\n        (Point3d.fromCoordinates ( 3, 0, 0 ))\r\n        (Point3d.fromCoordinates ( 4, 0, 0 ))\r\n    --> Nothing\r\n\r\n","type":"Point3d.Point3d units coordinates1 -> Point3d.Point3d units coordinates1 -> Point3d.Point3d units coordinates1 -> Maybe.Maybe (SketchPlane3d.SketchPlane3d units coordinates1 coordinates2)"},{"name":"toPlane","comment":" Convert a `SketchPlane3d` to a `Plane3d` with the same origin point and\r\nnormal direction.\r\n\r\n    SketchPlane3d.toPlane SketchPlane3d.xy\r\n    --> Plane3d.xy\r\n\r\n    SketchPlane3d.toPlane SketchPlane3d.yx\r\n    --> Plane3d.reverseNormal Plane3d.xy\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> Plane3d.Plane3d units coordinates1"},{"name":"translateAlongOwn","comment":" Translate a sketch plane along one of its own axes by a given distance.\r\n\r\nThe first argument is a function that returns the axis to translate along, given\r\nthe current sketch plane. The majority of the time this will be either\r\n`SketchPlane3d.xAxis` or `SketchPlane3d.yAxis`.\r\n\r\nThis function is convenient when constructing frames via a series of\r\ntransformations. For example,\r\n\r\n    sketchPlane =\r\n        SketchPlane3d.xy\r\n            |> SketchPlane3d.rotateAround\r\n                Axis3d.x\r\n                (degrees 45)\r\n            |> SketchPlane3d.translateAlongOwn\r\n                SketchPlane3d.yAxis\r\n                2\r\n\r\nmeans 'take the global XY sketch plane, rotate it around the global X axis by\r\n45 degrees, then translate the result 2 units along its own (rotated) Y axis',\r\nresulting in\r\n\r\n    SketchPlane3d.originPoint sketchPlane\r\n    --> Point3d.fromCoordinates ( 0, 1.4142, 1.4142 )\r\n\r\n    SketchPlane3d.xDirection sketchPlane\r\n    --> Direction3d.x\r\n\r\n    SketchPlane3d.yDirection sketchPlane\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 90)\r\n    -->     (degrees 45)\r\n\r\n","type":"(SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> Axis3d.Axis3d units coordinates1) -> Quantity.Quantity Basics.Float units -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"translateBy","comment":" Translate a sketch plane by a given displacement.\r\n\r\n    displacement =\r\n        Vector3d.fromComponents ( 2, 1, 3 )\r\n\r\n    sketchPlane =\r\n        SketchPlane3d.xy\r\n            |> SketchPlane3d.translateBy displacement\r\n\r\n    SketchPlane3d.originPoint sketchPlane\r\n    --> Point3d.fromCoordinates ( 2, 1, 3 )\r\n\r\n    SketchPlane3d.xDirection sketchPlane\r\n    --> Direction3d.x\r\n\r\n    SketchPlane3d.yDirection sketchPlane\r\n    --> Direction3d.y\r\n\r\n","type":"Vector3d.Vector3d units coordinates1 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"translateIn","comment":" Translate a sketch plane in a given direction by a given distance;\r\n\r\n    SketchPlane3d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    SketchPlane3d.translateBy\r\n        (Vector3d.withLength distance direction)\r\n\r\n","type":"Direction3d.Direction3d coordinates1 -> Quantity.Quantity Basics.Float units -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates3"},{"name":"unsafe","comment":" Construct a sketch plane directly from its origin point and X and Y\r\ndirections:\r\n\r\n    sketchPlane =\r\n        SketchPlane3d.unsafe\r\n            { originPoint =\r\n                Point3d.fromCoordinates ( 2, 1, 3 )\r\n            , xDirection = Direction3d.positiveY\r\n            , yDirection = Direction3d.negativeZ\r\n            }\r\n\r\nIf you construct a `SketchPlane3d` this way, **you must ensure that the X and Y\r\nbasis directions are perpendicular to each other**.\r\n\r\n","type":"{ originPoint : Point3d.Point3d units coordinates1, xDirection : Direction3d.Direction3d coordinates1, yDirection : Direction3d.Direction3d coordinates1 } -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates2"},{"name":"withNormalDirection","comment":" Construct a sketch plane with the given normal direction, having the given\r\norigin point. The X and Y basis directions of the sketch plane will:\r\n\r\n  - be perpendicular to each other,\r\n  - both be perpendicular to the given normal direction, and\r\n  - have a cross product equal to the given normal direction.\r\n\r\nThis is useful when constructing 'scratch' sketch planes where the specific X/Y\r\ndirections are unimportant.\r\n\r\n    sketchPlane =\r\n        SketchPlane3d.withNormalDirection\r\n            (Direction3d.fromAzimuthAndElevation\r\n                (degrees 0)\r\n                (degrees 60)\r\n            )\r\n            Point3d.origin\r\n\r\n    SketchPlane3d.originPoint sketchPlane\r\n    --> Point3d.origin\r\n\r\n    SketchPlane3d.xDirection sketchPlane\r\n    --> Direction3d.fromAzimuthAndElevation\r\n    -->     (degrees 0)\r\n    -->     (degrees -30)\r\n\r\n    SketchPlane3d.yDirection sketchPlane\r\n    --> Direction3d.y\r\n\r\n","type":"Direction3d.Direction3d coordinates1 -> Point3d.Point3d units coordinates1 -> SketchPlane3d.SketchPlane3d units coordinates1 coordinates2"},{"name":"xAxis","comment":" Get the X axis of a sketch plane. A 2D X coordinate within the sketch plane\r\ncorresponds to a distance along this axis in 3D.\r\n\r\n    SketchPlane3d.xAxis SketchPlane3d.zx\r\n    --> Axis3d.z\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> Axis3d.Axis3d units coordinates1"},{"name":"xDirection","comment":" Get the X direction of a sketch plane (the direction of the sketch plane's\r\nX axis).\r\n\r\n    SketchPlane3d.xDirection SketchPlane3d.zx\r\n    --> Direction3d.z\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> Direction3d.Direction3d coordinates1"},{"name":"xy","comment":" A sketch plane formed from the global X and Y axes.\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2"},{"name":"xz","comment":" A sketch plane formed from the global X and Z axes.\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2"},{"name":"yAxis","comment":" Get the Y axis of a sketch plane. A 2D Y coordinate within the sketch plane\r\ncorresponds to a distance along this axis in 3D.\r\n\r\n    SketchPlane3d.yAxis SketchPlane3d.zx\r\n    --> Axis3d.x\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> Axis3d.Axis3d units coordinates1"},{"name":"yDirection","comment":" Get the Y direction of a sketch plane (the direction of the sketch plane's\r\nY axis).\r\n\r\n    SketchPlane3d.yDirection SketchPlane3d.zx\r\n    --> Direction3d.x\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2 -> Direction3d.Direction3d coordinates1"},{"name":"yx","comment":" A sketch plane formed from the global Y and X axes.\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2"},{"name":"yz","comment":" A sketch plane formed from the global Y and Z axes.\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2"},{"name":"zx","comment":" A sketch plane formed from the global Z and X axes.\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2"},{"name":"zy","comment":" A sketch plane formed from the global Z and Y axes.\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates1 coordinates2"}],"binops":[]},{"name":"Sphere3d","comment":" A `Sphere3d` is defined by its center point and radius. This module contains\r\nfunctionality for:\r\n\r\n  - Constructing spheres through points\r\n  - Scaling, rotating and translating spheres\r\n  - Extracting sphere properties like center point and volume\r\n\r\n@docs Sphere3d\r\n\r\n\r\n# Constructors\r\n\r\n@docs withRadius, throughPoints\r\n\r\n\r\n# Properties\r\n\r\n@docs centerPoint, radius, diameter, volume, surfaceArea, circumference, boundingBox\r\n\r\n\r\n# Queries\r\n\r\n@docs contains\r\n\r\n\r\n# Transformations\r\n\r\n@docs scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross, projectOnto, projectInto\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n","unions":[],"aliases":[{"name":"Sphere3d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Sphere3d units coordinates"}],"values":[{"name":"boundingBox","comment":" Get the minimal bounding box containing a given sphere.\r\n\r\n    Sphere3d.boundingBox exampleSphere\r\n    --> BoundingBox3d.fromExtrema\r\n    -->     { minX = -2\r\n    -->     , maxX = 4\r\n    -->     , minY = -1\r\n    -->     , maxY = 5\r\n    -->     , minZ = -2\r\n    -->     , maxZ = 4\r\n    -->     }\r\n\r\n","type":"Sphere3d.Sphere3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates"},{"name":"centerPoint","comment":" Get the center point of a sphere.\r\n\r\n    Sphere3d.centerPoint exampleSphere\r\n    --> Point3d.fromCoordinates ( 1, 2, 1 )\r\n\r\n","type":"Sphere3d.Sphere3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"circumference","comment":" Get the circumference of a sphere (the circumference of a [great circle](https://en.wikipedia.org/wiki/Great_circle)\r\nof the sphere).\r\n\r\n    Sphere3d.circumference exampleSphere\r\n    --> 18.8496\r\n\r\n","type":"Sphere3d.Sphere3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"contains","comment":" Check if a sphere contains a given point.\r\n\r\n    Sphere3d.contains\r\n        (Point3d.fromCoordinates ( 4, 2, 1 ))\r\n        exampleSphere\r\n    --> True\r\n\r\n    Sphere3d.contains\r\n        (Point3d.fromCoordinates ( 4.00001, 2, 1 ))\r\n        exampleSphere\r\n    --> False\r\n\r\n","type":"Point3d.Point3d units coordinates -> Sphere3d.Sphere3d units coordinates -> Basics.Bool"},{"name":"diameter","comment":" Get the diameter of a sphere.\r\n\r\n    Sphere3d.diameter exampleSphere\r\n    --> 6\r\n\r\n","type":"Sphere3d.Sphere3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"mirrorAcross","comment":" Mirror a sphere across a given plane.\r\n\r\n    Sphere3d.mirrorAcross Plane3d.xy exampleSphere\r\n    --> Sphere3d.withRadius 3\r\n    -->     (Point3d.fromCoordinates ( 1, 2, -1 ))\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> Sphere3d.Sphere3d units coordinates -> Sphere3d.Sphere3d units coordinates"},{"name":"placeIn","comment":" Take a sphere considered to be defined in local coordinates relative to a\r\ngiven reference frame, and return that sphere expressed in global coordinates.\r\n\r\n    exampleSphere\r\n        |> Sphere3d.placeIn\r\n            (Frame3d.atPoint\r\n                (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n            )\r\n    --> Sphere3d.withRadius 3\r\n    -->     (Point3d.fromCoordinates ( 2, 4, 4 ))\r\n\r\n","type":"Frame3d.Frame3d units globalCoordinates localCoordinates -> Sphere3d.Sphere3d units localCoordinates -> Sphere3d.Sphere3d units globalCoordinates"},{"name":"projectInto","comment":" Find the [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof a sphere into a sketch plane.\r\n\r\n    Sphere3d.projectInto SketchPlane3d.xy exampleSphere\r\n    --> Circle2d.withRadius 3\r\n    -->     (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates3d coordinates2d -> Sphere3d.Sphere3d units coordinates3d -> Circle2d.Circle2d units coordinates2d"},{"name":"projectOnto","comment":" Find the [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof a sphere onto a plane.\r\n\r\n    Sphere3d.projectOnto Plane3d.xy exampleSphere\r\n    --> Circle3d.withRadius 3\r\n    -->     Direction3d.z\r\n    -->     (Point3d.fromCoordinates ( 1, 2, 0 ))\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> Sphere3d.Sphere3d units coordinates -> Circle3d.Circle3d units coordinates"},{"name":"radius","comment":" Get the radius of a sphere.\r\n\r\n    Sphere3d.radius exampleSphere\r\n    --> 3\r\n\r\n","type":"Sphere3d.Sphere3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"relativeTo","comment":" Take a sphere defined in global coordinates, and return it expressed in\r\nlocal coordinates relative to a given reference frame.\r\n\r\n    exampleSphere\r\n        |> Sphere3d.relativeTo\r\n            (Frame3d.atPoint\r\n                (Point3d.fromCoordinates ( 1, 2, 3 ))\r\n            )\r\n    --> Sphere3d.withRadius 3\r\n    -->     (Point3d.fromCoordinates ( 0, 0, -2 ))\r\n\r\n","type":"Frame3d.Frame3d units globalCoordinates localCoordinates -> Sphere3d.Sphere3d units globalCoordinates -> Sphere3d.Sphere3d units localCoordinates"},{"name":"rotateAround","comment":" Rotate a sphere around a given axis by a given angle (in radians).\r\n\r\n    exampleSphere\r\n        |> Sphere3d.rotateAround Axis3d.y (degrees 90)\r\n    --> Sphere3d.withRadius 3\r\n    -->     (Point3d.fromCoordinates ( 1, 2, -1 ))\r\n\r\n","type":"Axis3d.Axis3d units coordinates -> Angle.Angle -> Sphere3d.Sphere3d units coordinates -> Sphere3d.Sphere3d units coordinates"},{"name":"scaleAbout","comment":" Scale a sphere around a given point by a given scale.\r\n\r\n    Sphere3d.scaleAbout Point3d.origin 3 exampleSphere\r\n    --> Sphere3d.withRadius 9\r\n    -->     (Point3d.fromCoordinates ( 3, 6, 3 ))\r\n\r\n","type":"Point3d.Point3d units coordinates -> Basics.Float -> Sphere3d.Sphere3d units coordinates -> Sphere3d.Sphere3d units coordinates"},{"name":"surfaceArea","comment":" Get the surface area of a sphere.\r\n\r\n    Sphere3d.surfaceArea exampleSphere\r\n    --> 113.0973\r\n\r\n","type":"Sphere3d.Sphere3d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Squared units)"},{"name":"throughPoints","comment":" Attempt to construct a sphere that passes through the four given points.\r\nReturns `Nothing` if four given points are coplanar.\r\n\r\n    Sphere3d.throughPoints\r\n        (Point3d.fromCoordinates ( 1, 0, 0 ))\r\n        (Point3d.fromCoordinates ( -1, 0, 0 ))\r\n        (Point3d.fromCoordinates ( 0, 1, 0 ))\r\n        (Point3d.fromCoordinates ( 0, 0, 0.5 ))\r\n    --> Just\r\n    -->     (Sphere3d.withRadius 1.25\r\n    -->         (Point3d.fromCoordinates ( 0, 0, -0.75 ))\r\n    -->     )\r\n\r\n    Sphere3d.throughPoints\r\n        (Point3d.fromCoordinates ( 1, 0, 0 ))\r\n        (Point3d.fromCoordinates ( -1, 0, 0 ))\r\n        (Point3d.fromCoordinates ( 0, 1, 0 ))\r\n        (Point3d.fromCoordinates ( 0, -1, 0 ))\r\n    --> Nothing\r\n\r\n","type":"Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> Point3d.Point3d units coordinates -> Maybe.Maybe (Sphere3d.Sphere3d units coordinates)"},{"name":"translateBy","comment":" Translate a sphere by a given displacement.\r\n\r\n    exampleSphere\r\n        |> Sphere3d.translateBy\r\n            (Vector3d.fromComponents ( 2, 1, 3 ))\r\n    --> Sphere3d.withRadius 3\r\n    -->     (Point3d.fromCoordinates ( 3, 3, 4 ))\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Sphere3d.Sphere3d units coordinates -> Sphere3d.Sphere3d units coordinates"},{"name":"translateIn","comment":" Translate a sphere in a given direction by a given distance;\r\n\r\n    Sphere3d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    Sphere3d.translateBy\r\n        (Vector3d.withLength distance direction)\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Quantity.Quantity Basics.Float units -> Sphere3d.Sphere3d units coordinates -> Sphere3d.Sphere3d units coordinates"},{"name":"volume","comment":" Get the volume of a sphere.\r\n\r\n    Sphere3d.volume exampleSphere\r\n    --> 113.0973\r\n\r\n","type":"Sphere3d.Sphere3d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Cubed units)"},{"name":"withRadius","comment":" Construct a sphere from its radius and center point:\r\n\r\n    exampleSphere =\r\n        Sphere3d.withRadius 3\r\n            (Point3d.fromCoordinates ( 1, 2, 1 ))\r\n\r\nIf you pass a negative radius, the absolute value will be used.\r\n\r\n","type":"Quantity.Quantity Basics.Float units -> Point3d.Point3d units coordinates -> Sphere3d.Sphere3d units coordinates"}],"binops":[]},{"name":"Triangle2d","comment":" A `Triangle2d` represents a triangle in 2D space, and is defined by its\r\nthree vertices. This module contains triangle-related functionality such as:\r\n\r\n  - Finding the area and centroid of triangles\r\n  - Scaling, rotating, translating and mirroring triangles\r\n  - Converting triangles between different coordinate systems\r\n\r\n@docs Triangle2d\r\n\r\n\r\n# Constructors\r\n\r\n@docs fromVertices\r\n\r\n\r\n# Properties\r\n\r\n@docs vertices, edges, centroid, area, counterclockwiseArea, clockwiseArea, boundingBox, circumcircle\r\n\r\n\r\n# Queries\r\n\r\n@docs contains\r\n\r\n\r\n# Transformations\r\n\r\nTransforming a triangle is equivalent to transforming its vertices.\r\n\r\n@docs scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross, mapVertices\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn\r\n\r\n","unions":[],"aliases":[{"name":"Triangle2d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Triangle2d units coordinates"}],"values":[{"name":"area","comment":" Get the area of a triangle. The result will always be positive regardless of\r\nwhether the triangle's vertices are in clockwise or counterclockwise order.\r\n\r\n    Triangle2d.area exampleTriangle\r\n    --> 1.0\r\n\r\n","type":"Triangle2d.Triangle2d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Squared units)"},{"name":"boundingBox","comment":" Get the minimal bounding box containing a given triangle.\r\n\r\n    Triangle2d.boundingBox exampleTriangle\r\n    --> BoundingBox2d.fromExtrema\r\n    -->     { minX = 1\r\n    -->     , maxX = 2\r\n    -->     , minY = 1\r\n    -->     , maxY = 3\r\n    -->     }\r\n\r\n","type":"Triangle2d.Triangle2d units coordinates -> BoundingBox2d.BoundingBox2d units coordinates"},{"name":"centroid","comment":" Get the centroid (center of mass) of a triangle.\r\n\r\n    Triangle2d.centroid exampleTriangle\r\n    --> Point2d.fromCoordinates ( 1.3333, 1.6667 )\r\n\r\n","type":"Triangle2d.Triangle2d units coordinates -> Point2d.Point2d units coordinates"},{"name":"circumcircle","comment":" Attempt to find the circumcircle of a triangle, a circle that passes through\r\neach of the triangle's vertices;\r\n\r\n    Triangle2d.circumcircle triangle\r\n\r\nis equivalent to\r\n\r\n    ( p1, p2, p3 ) =\r\n        Triangle2d.vertices triangle\r\n\r\n    Circle2d.throughPoints p1 p2 p3\r\n\r\nIf the triangle is degenerate (its three vertices are collinear), returns\r\n`Nothing`.\r\n\r\n","type":"Triangle2d.Triangle2d units coordinates -> Maybe.Maybe (Circle2d.Circle2d units coordinates)"},{"name":"clockwiseArea","comment":" Get the signed area of a triangle, returning a positive value if the\r\ntriangle's vertices are in clockwise order and a negative value otherwise.\r\n\r\n    Triangle2d.clockwiseArea exampleTriangle\r\n    --> -1.0\r\n\r\n","type":"Triangle2d.Triangle2d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Squared units)"},{"name":"contains","comment":" Check whether a given point is inside a given triangle.\r\n\r\n    interiorPoint =\r\n        Point2d.fromCoordinates ( 1.5, 1.5 )\r\n\r\n    Triangle2d.contains interiorPoint exampleTriangle\r\n    --> True\r\n\r\n    Triangle2d.contains Point2d.origin exampleTriangle\r\n    --> False\r\n\r\nIt does not matter whether the triangle's vertices are in clockwise or\r\ncounterclockwise order.\r\n\r\n","type":"Point2d.Point2d units coordinates -> Triangle2d.Triangle2d units coordinates -> Basics.Bool"},{"name":"counterclockwiseArea","comment":" Get the signed area of a triangle, returning a positive value if the\r\ntriangle's vertices are in counterclockwise order and a negative value\r\notherwise.\r\n\r\n    Triangle2d.counterclockwiseArea exampleTriangle\r\n    --> 1.0\r\n\r\n","type":"Triangle2d.Triangle2d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Squared units)"},{"name":"edges","comment":" Get the edges of a triangle: from the first vertex to the second, from the\r\nsecond to the third, and from the third back to the first.\r\n\r\n\r\n    ( e1, e2, e3 ) =\r\n        Triangle2d.edges exampleTriangle\r\n\r\n    --> e1 =\r\n    -->     LineSegment2d.fromEndpoints\r\n    -->         ( Point2d.fromCoordinates ( 1, 1 )\r\n    -->         , Point2d.fromCoordinates ( 2, 1 )\r\n    -->         )\r\n    -->\r\n    --> e2 =\r\n    -->     LineSegment2d.fromEndpoints\r\n    -->         ( Point2d.fromCoordinates ( 2, 1 )\r\n    -->         , Point2d.fromCoordinates ( 1, 3 )\r\n    -->         )\r\n    -->\r\n    --> e3 =\r\n    -->     LineSegment2d.fromEndpoints\r\n    -->         ( Point2d.fromCoordinates ( 1, 3 )\r\n    -->         , Point2d.fromCoordinates ( 1, 1 )\r\n    -->         )\r\n\r\n","type":"Triangle2d.Triangle2d units coordinates -> ( LineSegment2d.LineSegment2d units coordinates, LineSegment2d.LineSegment2d units coordinates, LineSegment2d.LineSegment2d units coordinates )"},{"name":"fromVertices","comment":" Construct a triangle from its three vertices:\r\n\r\n    exampleTriangle =\r\n        Triangle2d.fromVertices\r\n            ( Point2d.fromCoordinates ( 1, 1 )\r\n            , Point2d.fromCoordinates ( 2, 1 )\r\n            , Point2d.fromCoordinates ( 1, 3 )\r\n            )\r\n\r\n","type":"( Point2d.Point2d units coordinates, Point2d.Point2d units coordinates, Point2d.Point2d units coordinates ) -> Triangle2d.Triangle2d units coordinates"},{"name":"mapVertices","comment":" Transform each vertex of a triangle by a given function and create a new\r\ntriangle from the resulting points. Most other transformation functions can be\r\ndefined in terms of `mapVertices`; for example,\r\n\r\n    Triangle2d.mirrorAcross axis\r\n\r\nis equivalent to\r\n\r\n    Triangle2d.mapVertices (Point2d.mirrorAcross axis)\r\n\r\n","type":"(Point2d.Point2d unitsA coordinatesA -> Point2d.Point2d unitsB coordinatesB) -> Triangle2d.Triangle2d unitsA coordinatesA -> Triangle2d.Triangle2d unitsB coordinatesB"},{"name":"mirrorAcross","comment":" Mirror a triangle across a given axis.\r\n\r\n    Triangle2d.mirrorAcross Axis2d.y exampleTriangle\r\n    --> Triangle2d.fromVertices\r\n    -->     ( Point2d.fromCoordinates ( -1, 1 )\r\n    -->     , Point2d.fromCoordinates ( -2, 1 )\r\n    -->     , Point2d.fromCoordinates ( -1, 3 )\r\n    -->     )\r\n\r\nNote that mirroring a triangle will result in its 'winding direction' being\r\nflipped - if the triangle's vertices were in counterclockwise order before\r\nmirroring, they will be in clockwise order afterwards and vice versa.\r\n\r\n","type":"Axis2d.Axis2d units coordinates -> Triangle2d.Triangle2d units coordinates -> Triangle2d.Triangle2d units coordinates"},{"name":"placeIn","comment":" Take a triangle considered to be defined in local coordinates relative to a\r\ngiven reference frame, and return that triangle expressed in global coordinates.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    Triangle2d.placeIn localFrame exampleTriangle\r\n    --> Triangle2d.fromVertices\r\n    -->     ( Point2d.fromCoordinates ( 2, 3 )\r\n    -->     , Point2d.fromCoordinates ( 3, 3 )\r\n    -->     , Point2d.fromCoordinates ( 2, 5 )\r\n    -->     )\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> Triangle2d.Triangle2d units localCoordinates -> Triangle2d.Triangle2d units globalCoordinates"},{"name":"relativeTo","comment":" Take a triangle defined in global coordinates, and return it expressed\r\nin local coordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame2d.atPoint (Point2d.fromCoordinates ( 1, 2 ))\r\n\r\n    Triangle2d.relativeTo localFrame exampleTriangle\r\n    --> Triangle2d.fromVertices\r\n    -->     ( Point2d.fromCoordinates ( 0, -1 )\r\n    -->     , Point2d.fromCoordinates ( 1, -1 )\r\n    -->     , Point2d.fromCoordinates ( 0, 1 )\r\n    -->     )\r\n\r\n","type":"Frame2d.Frame2d units globalCoordinates localCoordinates -> Triangle2d.Triangle2d units globalCoordinates -> Triangle2d.Triangle2d units localCoordinates"},{"name":"rotateAround","comment":" Rotate a triangle around a given point by a given angle (in radians).\r\n\r\n    exampleTriangle\r\n        |> Triangle2d.rotateAround Point2d.origin\r\n            (degrees 90)\r\n    --> Triangle2d.fromVertices\r\n    -->     ( Point2d.fromCoordinates ( -1, 1 )\r\n    -->     , Point2d.fromCoordinates ( -1, 2 )\r\n    -->     , Point2d.fromCoordinates ( -3, 1 )\r\n    -->     )\r\n\r\n","type":"Point2d.Point2d units coordinates -> Angle.Angle -> Triangle2d.Triangle2d units coordinates -> Triangle2d.Triangle2d units coordinates"},{"name":"scaleAbout","comment":" Scale a triangle about a given point by a given scale.\r\n\r\n    Triangle2d.scaleAbout Point2d.origin 2 exampleTriangle\r\n    --> Triangle2d.fromVertices\r\n    -->     ( Point2d.fromCoordinates ( 2, 2 )\r\n    -->     , Point2d.fromCoordinates ( 4, 2 )\r\n    -->     , Point2d.fromCoordinates ( 2, 6 )\r\n    -->     )\r\n\r\nNote that scaling by a negative value will result in the 'winding direction' of\r\nthe triangle being flipped - if the triangle's vertices were in counterclockwise\r\norder before the negative scaling, they will be in clockwise order afterwards\r\nand vice versa.\r\n\r\n","type":"Point2d.Point2d units coordinates -> Basics.Float -> Triangle2d.Triangle2d units coordinates -> Triangle2d.Triangle2d units coordinates"},{"name":"translateBy","comment":" Translate a triangle by a given displacement.\r\n\r\n    displacement =\r\n        Vector2d.fromComponents ( 2, -3 )\r\n\r\n    Triangle2d.translateBy displacement exampleTriangle\r\n    --> Triangle2d.fromVertices\r\n    -->     ( Point2d.fromCoordinates ( 3, -2 )\r\n    -->     , Point2d.fromCoordinates ( 4, -2 )\r\n    -->     , Point2d.fromCoordinates ( 3, 0 )\r\n    -->     )\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Triangle2d.Triangle2d units coordinates -> Triangle2d.Triangle2d units coordinates"},{"name":"translateIn","comment":" Translate a triangle in a given direction by a given distance;\r\n\r\n    Triangle2d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    Triangle2d.translateBy\r\n        (Vector2d.withLength distance direction)\r\n\r\n","type":"Direction2d.Direction2d coordinates -> Quantity.Quantity Basics.Float units -> Triangle2d.Triangle2d units coordinates -> Triangle2d.Triangle2d units coordinates"},{"name":"vertices","comment":" Get the vertices of a triangle.\r\n\r\n\r\n    ( p1, p2, p3 ) =\r\n        Triangle2d.vertices exampleTriangle\r\n\r\n    --> p1 = Point2d.fromCoordinates ( 1, 1 )\r\n    --> p2 = Point2d.fromCoordinates ( 2, 1 )\r\n    --> p3 = Point2d.fromCoordinates ( 1, 3 )\r\n\r\n","type":"Triangle2d.Triangle2d units coordinates -> ( Point2d.Point2d units coordinates, Point2d.Point2d units coordinates, Point2d.Point2d units coordinates )"}],"binops":[]},{"name":"Triangle3d","comment":" A `Triangle3d` represents a triangle in 3D space, and is defined by its\r\nthree vertices. This module contains triangle-related functionality such as:\r\n\r\n  - Finding the area and centroid of triangles\r\n  - Scaling, rotating, translating, mirroring and projecting triangles\r\n  - Converting triangles between different coordinate systems\r\n\r\n@docs Triangle3d\r\n\r\n\r\n# Constructors\r\n\r\n@docs fromVertices, on\r\n\r\n\r\n# Properties\r\n\r\n@docs vertices, edges, centroid, area, normalDirection, boundingBox, circumcircle\r\n\r\n\r\n# Transformations\r\n\r\nTransforming a triangle is equivalent to transforming its vertices.\r\n\r\n@docs scaleAbout, rotateAround, translateBy, translateIn, mirrorAcross, projectOnto, mapVertices\r\n\r\n\r\n# Coordinate conversions\r\n\r\n@docs relativeTo, placeIn, projectInto\r\n\r\n","unions":[],"aliases":[{"name":"Triangle3d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Triangle3d units coordinates"}],"values":[{"name":"area","comment":" Get the area of a triangle. This value is always positive.\r\n\r\n    Triangle3d.area exampleTriangle\r\n    --> 1.5811\r\n\r\n","type":"Triangle3d.Triangle3d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Squared units)"},{"name":"boundingBox","comment":" Get the minimal bounding box containing a given triangle.\r\n\r\n    Triangle3d.boundingBox exampleTriangle\r\n    --> BoundingBox3d.fromExtrema\r\n    -->     { minX = 1\r\n    -->     , maxX = 2\r\n    -->     , minY = 0\r\n    -->     , maxY = 1\r\n    -->     , minZ = 0\r\n    -->     , maxZ = 3\r\n    -->     }\r\n\r\n","type":"Triangle3d.Triangle3d units coordinates -> BoundingBox3d.BoundingBox3d units coordinates"},{"name":"centroid","comment":" Get the centroid (center of mass) of a triangle.\r\n\r\n    Triangle3d.centroid exampleTriangle\r\n    --> Point3d.fromCoordinates ( 1.6667, 0.6667, 1 )\r\n\r\n","type":"Triangle3d.Triangle3d units coordinates -> Point3d.Point3d units coordinates"},{"name":"circumcircle","comment":" Attempt to find the circumcircle of a triangle, a circle that passes through\r\neach of the triangle's vertices;\r\n\r\n    Triangle3d.circumcircle triangle\r\n\r\nis equivalent to\r\n\r\n    ( p1, p2, p3 ) =\r\n        Triangle3d.vertices triangle\r\n\r\n    Circle3d.throughPoints p1 p2 p3\r\n\r\nIf the triangle is degenerate (its three vertices are collinear), returns\r\n`Nothing`.\r\n\r\n","type":"Triangle3d.Triangle3d units coordinates -> Maybe.Maybe (Circle3d.Circle3d units coordinates)"},{"name":"edges","comment":" Get the edges of a triangle: from the first vertex to the second, from the\r\nsecond to the third, and from the third back to the first.\r\n\r\n\r\n    ( e1, e2, e3 ) =\r\n        Triangle3d.edges exampleTriangle\r\n\r\n    --> e1 =\r\n    -->     LineSegment3d.fromEndpoints\r\n    -->         ( Point3d.fromCoordinates ( 1, 0, 0 )\r\n    -->         , Point3d.fromCoordinates ( 2, 0, 0 )\r\n    -->         )\r\n    -->\r\n    --> e2 =\r\n    -->     LineSegment3d.fromEndpoints\r\n    -->         ( Point3d.fromCoordinates ( 2, 0, 0 )\r\n    -->         , Point3d.fromCoordinates ( 2, 1, 3 )\r\n    -->         )\r\n    -->\r\n    --> e3 =\r\n    -->     LineSegment3d.fromEndpoints\r\n    -->         ( Point3d.fromCoordinates ( 2, 1, 3 )\r\n    -->         , Point3d.fromCoordinates ( 1, 0, 0 )\r\n    -->         )\r\n\r\n","type":"Triangle3d.Triangle3d units coordinates -> ( LineSegment3d.LineSegment3d units coordinates, LineSegment3d.LineSegment3d units coordinates, LineSegment3d.LineSegment3d units coordinates )"},{"name":"fromVertices","comment":" Construct a triangle from its three vertices:\r\n\r\n    exampleTriangle =\r\n        Triangle3d.fromVertices\r\n            ( Point3d.fromCoordinates ( 1, 0, 0 )\r\n            , Point3d.fromCoordinates ( 2, 0, 0 )\r\n            , Point3d.fromCoordinates ( 2, 1, 3 )\r\n            )\r\n\r\n","type":"( Point3d.Point3d units coordinates, Point3d.Point3d units coordinates, Point3d.Point3d units coordinates ) -> Triangle3d.Triangle3d units coordinates"},{"name":"mapVertices","comment":" Transform each vertex of a triangle by a given function and create a new\r\ntriangle from the resulting points. Most other transformation functions can be\r\ndefined in terms of `mapVertices`; for example,\r\n\r\n    Triangle3d.projectOnto plane\r\n\r\nis equivalent to\r\n\r\n    Triangle3d.mapVertices (Point3d.projectOnto plane)\r\n\r\n","type":"(Point3d.Point3d units1 coordinates1 -> Point3d.Point3d units2 coordinates2) -> Triangle3d.Triangle3d units1 coordinates1 -> Triangle3d.Triangle3d units2 coordinates2"},{"name":"mirrorAcross","comment":" Mirror a triangle across a given plane.\r\n\r\n    Triangle3d.mirrorAcross Plane3d.yz exampleTriangle\r\n    --> Triangle3d.fromVertices\r\n    -->     ( Point3d.fromCoordinates ( -1, 0, 0 )\r\n    -->     ( Point3d.fromCoordinates ( -2, 0, 0 )\r\n    -->     ( Point3d.fromCoordinates ( -2, 1, 3 )\r\n    -->     )\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> Triangle3d.Triangle3d units coordinates -> Triangle3d.Triangle3d units coordinates"},{"name":"normalDirection","comment":" Attempt to find the normal direction to a triangle. The resulting direction\r\nwill be oriented such that the triangle vertices are in counterclockwise order\r\naround it according to the right-hand rule. If the triangle is degenerate (its\r\nthree vertices are collinear), returns `Nothing`.\r\n\r\n    Triangle3d.normalDirection exampleTriangle\r\n    --> Just\r\n    -->     (Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees -90)\r\n    -->         (degrees 18.43)\r\n    -->     )\r\n\r\n","type":"Triangle3d.Triangle3d units coordinates -> Maybe.Maybe (Direction3d.Direction3d coordinates)"},{"name":"on","comment":" Construct a 3D triangle lying _on_ a sketch plane by providing a 2D triangle\r\nspecified in XY coordinates _within_ the sketch plane.\r\n\r\n    Triangle3d.on SketchPlane3d.xz <|\r\n        Triangle2d.fromVertices\r\n            ( Point2d.fromCoordinates ( 1, 1 )\r\n            , Point2d.fromCoordinates ( 2, 1 )\r\n            , Point2d.fromCoordinates ( 1, 3 )\r\n            )\r\n    --> Triangle3d.fromVertices\r\n    -->     ( Point3d.fromCoordinates ( 1, 0, 1 )\r\n    -->     , Point3d.fromCoordinates ( 2, 0, 1 )\r\n    -->     , Point3d.fromCoordinates ( 1, 0, 3 )\r\n    -->     )\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates3d coordinates2d -> Triangle2d.Triangle2d units coordinates2d -> Triangle3d.Triangle3d units coordinates3d"},{"name":"placeIn","comment":" Take a triangle considered to be defined in local coordinates relative to a\r\ngiven reference frame, and return that triangle expressed in global coordinates.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 2, 1, 3 ))\r\n\r\n    Triangle3d.placeIn localFrame exampleTriangle\r\n    --> Triangle3d.fromVertices\r\n    -->     ( Point3d.fromCoordinates ( 3, 1, 3 )\r\n    -->     , Point3d.fromCoordinates ( 4, 1, 3 )\r\n    -->     , Point3d.fromCoordinates ( 4, 2, 6 )\r\n    -->     )\r\n\r\n","type":"Frame3d.Frame3d units globalCoordinates localCoordinates -> Triangle3d.Triangle3d units localCoordinates -> Triangle3d.Triangle3d units globalCoordinates"},{"name":"projectInto","comment":" Project a triangle into a given sketch plane. Conceptually, this finds the\r\n[orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof the triangle onto the plane and then expresses the projected triangle in 2D\r\nsketch coordinates.\r\n\r\n    Triangle3d.projectInto SketchPlane3d.xy exampleTriangle\r\n    --> Triangle2d.fromVertices\r\n    -->     ( Point2d.fromCoordinates ( 1, 0 )\r\n    -->     , Point2d.fromCoordinates ( 2, 0 )\r\n    -->     , Point2d.fromCoordinates ( 2, 1 )\r\n    -->     )\r\n\r\n    Triangle3d.projectInto SketchPlane3d.zx exampleTriangle\r\n    --> Triangle2d.fromVertices\r\n    -->     ( Point2d.fromCoordinates ( 0, 1 )\r\n    -->     , Point2d.fromCoordinates ( 0, 2 )\r\n    -->     , Point2d.fromCoordinates ( 3, 2 )\r\n    -->     )\r\n\r\n","type":"SketchPlane3d.SketchPlane3d units coordinates3d coordinates2d -> Triangle3d.Triangle3d units coordinates3d -> Triangle2d.Triangle2d units coordinates2d"},{"name":"projectOnto","comment":" Find the [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof a triangle onto a plane.\r\n\r\n    Triangle3d.projectOnto Plane3d.xy exampleTriangle\r\n    --> Triangle3d.fromVertices\r\n    -->     ( Point3d.fromCoordinates ( 1, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 2, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 2, 1, 0 )\r\n    -->     )\r\n\r\n    Triangle3d.projectOnto Plane3d.xz exampleTriangle\r\n    --> Triangle3d.fromVertices\r\n    -->     ( Point3d.fromCoordinates ( 1, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 2, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 2, 0, 3 )\r\n    -->     )\r\n\r\n","type":"Plane3d.Plane3d units coordinates -> Triangle3d.Triangle3d units coordinates -> Triangle3d.Triangle3d units coordinates"},{"name":"relativeTo","comment":" Take a triangle defined in global coordinates, and return it expressed\r\nin local coordinates relative to a given reference frame.\r\n\r\n    localFrame =\r\n        Frame3d.atPoint\r\n            (Point3d.fromCoordinates ( 2, 1, 3 ))\r\n\r\n    Triangle3d.relativeTo localFrame exampleTriangle\r\n    --> Triangle3d.fromVertices\r\n    -->     ( Point3d.fromCoordinates ( -1, -1, -3 )\r\n    -->     , Point3d.fromCoordinates ( 0, -1, -3 )\r\n    -->     , Point3d.fromCoordinates ( 0, 0, 0 )\r\n    -->     )\r\n\r\n","type":"Frame3d.Frame3d units globalCoordinates localCoordinates -> Triangle3d.Triangle3d units globalCoordinates -> Triangle3d.Triangle3d units localCoordinates"},{"name":"rotateAround","comment":" Rotate a triangle around a given axis by a given angle (in radians).\r\n\r\n    exampleTriangle\r\n        |> Triangle3d.rotateAround Axis3d.z (degrees 90)\r\n    --> Triangle3d.fromVertices\r\n    -->     ( Point3d.fromCoordinates ( 0, 1, 0 )\r\n    -->     , Point3d.fromCoordinates ( 0, 2, 0 )\r\n    -->     , Point3d.fromCoordinates ( -1, 2, 3 )\r\n    -->     )\r\n\r\n","type":"Axis3d.Axis3d units coordinates -> Angle.Angle -> Triangle3d.Triangle3d units coordinates -> Triangle3d.Triangle3d units coordinates"},{"name":"scaleAbout","comment":" Scale a triangle about a given point by a given scale.\r\n\r\n    Triangle3d.scaleAbout Point3d.origin 2 exampleTriangle\r\n    --> Triangle3d.fromVertices\r\n    -->     ( Point3d.fromCoordinates ( 2, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 4, 0, 0 )\r\n    -->     , Point3d.fromCoordinates ( 4, 2, 6 )\r\n    -->     )\r\n\r\n","type":"Point3d.Point3d units coordinates -> Basics.Float -> Triangle3d.Triangle3d units coordinates -> Triangle3d.Triangle3d units coordinates"},{"name":"translateBy","comment":" Translate a triangle by a given displacement.\r\n\r\n    displacement =\r\n        Vector3d.fromComponents ( 2, -1, 3 )\r\n\r\n    Triangle3d.translateBy displacement exampleTriangle\r\n    --> Triangle3d.fromVertices\r\n    -->     ( Point3d.fromCoordinates ( 3, -1, 3 )\r\n    -->     , Point3d.fromCoordinates ( 4, -1, 3 )\r\n    -->     , Point3d.fromCoordinates ( 4, 0, 6 )\r\n    -->     )\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Triangle3d.Triangle3d units coordinates -> Triangle3d.Triangle3d units coordinates"},{"name":"translateIn","comment":" Translate a triangle in a given direction by a given distance;\r\n\r\n    Triangle3d.translateIn direction distance\r\n\r\nis equivalent to\r\n\r\n    Triangle3d.translateBy\r\n        (Vector3d.withLength distance direction)\r\n\r\n","type":"Direction3d.Direction3d coordinates -> Quantity.Quantity Basics.Float units -> Triangle3d.Triangle3d units coordinates -> Triangle3d.Triangle3d units coordinates"},{"name":"vertices","comment":" Get the vertices of a triangle.\r\n\r\n\r\n    ( p1, p2, p3 ) =\r\n        Triangle3d.vertices exampleTriangle\r\n\r\n    --> p1 = Point3d.fromCoordinates ( 1, 0, 0 )\r\n    --> p2 = Point3d.fromCoordinates ( 2, 0, 0 )\r\n    --> p3 = Point3d.fromCoordinates ( 2, 1, 3 )\r\n\r\n","type":"Triangle3d.Triangle3d units coordinates -> ( Point3d.Point3d units coordinates, Point3d.Point3d units coordinates, Point3d.Point3d units coordinates )"}],"binops":[]},{"name":"Vector2d","comment":" A `Vector2d` represents a quantity such as a displacement or velocity in 2D,\r\nand is defined by its X and Y components. This module contains a variety of\r\nvector-related functionality, such as\r\n\r\n  - Adding or subtracting vectors\r\n  - Finding the lengths of vectors\r\n  - Rotating vectors\r\n  - Converting vectors between different coordinate systems\r\n\r\nNote that unlike in many other geometry packages where vectors are used as a\r\ngeneral-purpose data type, `elm-geometry` has separate data types for vectors,\r\ndirections and points. In most code it is actually more common to use `Point2d`\r\nand `Direction2d` than `Vector2d`, and much code can avoid working directly with\r\n`Vector2d` values at all!\r\n\r\n@docs Vector2d\r\n\r\n\r\n# Constants\r\n\r\n@docs zero\r\n\r\nAlthough there are no predefined constants for the vectors with components\r\n(1,&nbsp;0) and (0,&nbsp;1), in most cases you will actually want their\r\n`Direction2d` versions [`Direction2d.x`](Direction2d#x) and [`Direction2d.y`](Direction2d#y).\r\n\r\n\r\n# Constructors\r\n\r\n@docs fromComponents, fromComponentsIn, fromPolarComponents, fromPolarComponentsIn, from, withLength, perpendicularTo, interpolateFrom\r\n\r\n\r\n# Interop\r\n\r\nThese functions are useful for interoperability with other Elm code that uses\r\nplain `Float` tuples or records to represent vectors. The resulting `Vector2d`\r\nvalues will have [unitless](https://package.elm-lang.org/packages/ianmackenzie/elm-units/latest/Quantity#unitless-quantities)\r\ncomponents.\r\n\r\n@docs fromTuple, toTuple, fromRecord, toRecord\r\n\r\n\r\n# Unit conversion\r\n\r\n@docs at, at_\r\n\r\n\r\n# Rates of change\r\n\r\n@docs per, for\r\n\r\n\r\n# Properties\r\n\r\n@docs components, componentsIn, xComponent, yComponent, componentIn, polarComponents, length, squaredLength, direction, lengthAndDirection\r\n\r\n\r\n# Comparison\r\n\r\n@docs equalWithin, lexicographicComparison\r\n\r\n\r\n# Arithmetic\r\n\r\n@docs plus, minus, dot, cross\r\n\r\n\r\n# Transformations\r\n\r\nNote that for `mirrorAcross` and `projectOnto`, only the direction of the axis\r\naffects the result, since vectors are position-independent. Think of\r\nmirroring/projecting a vector across/onto an axis as moving the vector so its\r\ntail is on the axis, then mirroring/projecting its tip across/onto the axis.\r\n\r\n@docs reverse, normalize, scaleBy, rotateBy, rotateClockwise, rotateCounterclockwise, mirrorAcross, projectionIn, projectOnto\r\n\r\n\r\n# Coordinate conversions\r\n\r\nLike other transformations, coordinate conversions of vectors depend only on the\r\norientations of the relevant frames, not the positions of their origin points.\r\n\r\nFor the examples, assume the following frame has been defined:\r\n\r\n    rotatedFrame =\r\n        Frame2d.atOrigin |> Frame2d.rotateBy (degrees 30)\r\n\r\n@docs relativeTo, placeIn\r\n\r\n","unions":[],"aliases":[{"name":"Vector2d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Vector2d units coordinates"}],"values":[{"name":"at","comment":" Convert a vector from one units type to another, by providing a conversion factor given as a\r\nrate of change of destination units with respect to source units.\r\n\r\n    worldVector =\r\n        Vector2d.fromComponents\r\n            ( Length.meters 2\r\n            , Length.meters 3\r\n            )\r\n\r\n    resolution : Quantity Float (Rate Pixels Meters)\r\n    resolution =\r\n        Pixels.pixels 100 |> Quantity.per (Length.meters 1)\r\n\r\n    worldVector |> Vector2d.at resolution\r\n    --> Vector2d.fromComponents\r\n    -->     ( Pixels.pixels 200\r\n    -->     , Pixels.pixels 300\r\n    -->     )\r\n\r\n","type":"Quantity.Quantity Basics.Float (Quantity.Rate destinationUnits sourceUnits) -> Vector2d.Vector2d sourceUnits coordinates -> Vector2d.Vector2d destinationUnits coordinates"},{"name":"at_","comment":" Convert a vector from one units type to another, by providing an 'inverse' conversion factor\r\ngiven as a rate of change of source units with respect to destination units.\r\n\r\n    screenVector =\r\n        Vector2d.fromComponents\r\n            ( Pixels.pixels 200\r\n            , Pixels.pixels 300\r\n            )\r\n\r\n    resolution : Quantity Float (Rate Pixels Meters)\r\n    resolution =\r\n        Pixels.pixels 50 |> Quantity.per (Length.meters 1)\r\n\r\n    screenVector |> Vector2d.at_ resolution\r\n    --> Vector2d.fromComponents\r\n    -->     ( Length.meters 4\r\n    -->     , Length.meters 6\r\n    -->     )\r\n\r\n","type":"Quantity.Quantity Basics.Float (Quantity.Rate sourceUnits destinationUnits) -> Vector2d.Vector2d sourceUnits coordinates -> Vector2d.Vector2d destinationUnits coordinates"},{"name":"componentIn","comment":" Find the component of a vector in an arbitrary direction, for example\r\n\r\n    forwardSpeed =\r\n        Vector2d.componentIn forwardDirection velocity\r\n\r\nThis is more general and flexible than using `xComponent` or `yComponent`, both\r\nof which can be expressed in terms of `componentIn`; for example,\r\n\r\n    Vector2d.xComponent vector\r\n\r\nis equivalent to\r\n\r\n    Vector2d.componentIn Direction2d.x vector\r\n\r\n","type":"Geometry.Types.Direction2d coordinates -> Vector2d.Vector2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"components","comment":" Extract the components of a vector.\r\n\r\n    Vector2d.components (Vector2d.fromComponents ( 2, 3 ))\r\n    --> ( 2, 3 )\r\n\r\nThis combined with Elm's built-in tuple destructuring provides a convenient way\r\nto extract both the X and Y components of a vector in one line of code:\r\n\r\n    ( x, y ) =\r\n        Vector2d.components vector\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> ( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units )"},{"name":"componentsIn","comment":" Find the components of a vector in a given frame;\r\n\r\n    Vector2d.componentsIn frame vector\r\n\r\nis equivalent to\r\n\r\n    ( Vector2d.componentIn (Frame2d.xDirection frame) vector\r\n    , Vector2d.componentIn (Frame2d.yDirection frame) vector\r\n    )\r\n\r\n","type":"Geometry.Types.Frame2d units globalCoordinates localCoordinates -> Vector2d.Vector2d units globalCoordinates -> ( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units )"},{"name":"cross","comment":" Find the scalar 'cross product' of two vectors in 2D. This is useful in many\r\nof the same ways as the 3D cross product:\r\n\r\n  - Its length is equal to the product of the lengths of the two given vectors\r\n    and the sine of the angle between them, so it can be used as a metric to\r\n    determine if two vectors are nearly parallel.\r\n  - The sign of the result indicates the direction of rotation from the first\r\n    vector to the second (positive indicates a counterclockwise rotation and\r\n    negative indicates a clockwise rotation), similar to how the direction of\r\n    the 3D cross product indicates the direction of rotation.\r\n\r\nNote the argument order - `v1 x v2` would be written as\r\n\r\n    v1 |> Vector2d.cross v2\r\n\r\nwhich is the same as\r\n\r\n    Vector2d.cross v2 v1\r\n\r\nbut the _opposite_ of\r\n\r\n    Vector2d.cross v1 v2\r\n\r\nSome examples:\r\n\r\n    firstVector =\r\n        Vector2d.fromComponents\r\n            ( Length.feet 2\r\n            , Length.feet 0\r\n            )\r\n\r\n    secondVector =\r\n        Vector2d.fromComponents\r\n            ( Length.feet 0\r\n            , Length.feet 3\r\n            )\r\n\r\n    firstVector |> Vector2d.cross secondVector\r\n    --> Area.squareFeet 6\r\n\r\n    secondVector |> Vector2d.cross firstVector\r\n    --> Area.squareFeet -6\r\n\r\n    firstVector |> Vector2d.cross firstVector\r\n    --> Area.squareFeet 0\r\n\r\n","type":"Vector2d.Vector2d units2 coordinates -> Vector2d.Vector2d units1 coordinates -> Quantity.Quantity Basics.Float (Quantity.Product units1 units2)"},{"name":"direction","comment":" Attempt to find the direction of a vector. In the case of a zero vector,\r\nreturn `Nothing`.\r\n\r\n    Vector2d.direction (Vector2d.fromComponents ( 3, 3 ))\r\n    --> Just (Direction2d.fromAngle (degrees 45))\r\n\r\n    Vector2d.direction Vector2d.zero\r\n    --> Nothing\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Maybe.Maybe (Geometry.Types.Direction2d coordinates)"},{"name":"dot","comment":" Find the dot product of two vectors.\r\n\r\n    firstVector =\r\n        Vector2d.fromComponents\r\n            ( Length.meters 1\r\n            , Length.meters 2\r\n            )\r\n\r\n    secondVector =\r\n        Vector2d.fromComponents\r\n            ( Length.meters 3\r\n            , Length.meters 4\r\n            )\r\n\r\n    firstVector |> Vector2d.dot secondVector\r\n    --> Area.squareMeters 11\r\n\r\n","type":"Vector2d.Vector2d units2 coordinates -> Vector2d.Vector2d units1 coordinates -> Quantity.Quantity Basics.Float (Quantity.Product units1 units2)"},{"name":"equalWithin","comment":" Compare two vectors within a tolerance. Returns true if the difference\r\nbetween the two given vectors has magnitude less than the given tolerance.\r\n\r\n    firstVector =\r\n        Vector2d.fromComponents ( 1, 2 )\r\n\r\n    secondVector =\r\n        Vector2d.fromComponents ( 0.9999, 2.0002 )\r\n\r\n    Vector2d.equalWithin 1e-3 firstVector secondVector\r\n    --> True\r\n\r\n    Vector2d.equalWithin 1e-6 firstVector secondVector\r\n    --> False\r\n\r\n","type":"Quantity.Quantity Basics.Float units -> Vector2d.Vector2d units coordinates -> Vector2d.Vector2d units coordinates -> Basics.Bool"},{"name":"for","comment":" Multiply a rate of change vector by an independent quantity to get a total vector. For example,\r\nmultiply a velocity by a duration to get a total displacement:\r\n\r\n    velocity =\r\n        Vector2d.fromComponents\r\n            ( Pixels.pixelsPerSecond 200\r\n            , Pixels.pixelsPerSecond 50\r\n            )\r\n\r\n    velocity |> Vector2d.for (Duration.seconds 0.1)\r\n    --> Vector2d.fromComponents\r\n    -->     ( Pixels.pixels 20\r\n    -->     , Pixels.pixels 5\r\n    -->     )\r\n\r\n","type":"Quantity.Quantity Basics.Float independentUnits -> Vector2d.Vector2d (Quantity.Rate dependentUnits independentUnits) coordinates -> Vector2d.Vector2d dependentUnits coordinates"},{"name":"from","comment":" Construct a vector from the first given point to the second.\r\n\r\n    startPoint =\r\n        Point2d.fromCoordinates ( 1, 1 )\r\n\r\n    endPoint =\r\n        Point2d.fromCoordinates ( 4, 5 )\r\n\r\n    Vector2d.from startPoint endPoint\r\n    --> Vector2d.fromComponents ( 3, 4 )\r\n\r\n","type":"Geometry.Types.Point2d units coordinates -> Geometry.Types.Point2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"fromComponents","comment":" Construct a vector from its X and Y components.\r\n\r\n    vector =\r\n        Vector2d.fromComponents ( 2, 3 )\r\n\r\n","type":"( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units ) -> Vector2d.Vector2d units coordinates"},{"name":"fromComponentsIn","comment":" Construct a vector given its local components within a particular frame:\r\n\r\n    rotatedFrame =\r\n        Frame2d.atOrigin\r\n            |> Frame2d.rotateBy (Angle.degrees 45)\r\n\r\n    Vector2d.fromComponentsIn rotatedFrame\r\n        ( Length.meters 2\r\n        , Length.meters 0\r\n        )\r\n    --> Vector2d.fromComponents\r\n    -->     ( Length.meters 1.4142\r\n    -->     , Length.meters 1.4142\r\n    -->     )\r\n\r\n","type":"Geometry.Types.Frame2d units globalCoordinates localCoordinates -> ( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units ) -> Vector2d.Vector2d units globalCoordinates"},{"name":"fromPolarComponents","comment":" Construct a vector from a length and angle. The angle is measured\r\ncounterclockwise from the positive X direction.\r\n\r\n    Vector2d.fromPolarComponents ( 2, degrees 135 )\r\n    -->Vector2d.fromComponents ( -1.4142, 1.4142 )\r\n\r\n","type":"( Quantity.Quantity Basics.Float units, Angle.Angle ) -> Vector2d.Vector2d units coordinates"},{"name":"fromPolarComponentsIn","comment":" Construct a vector given its local polar components within a particular\r\nframe:\r\n\r\n    rotatedFrame =\r\n        Frame2d.atOrigin\r\n            |> Frame2d.rotateBy (Angle.degrees 45)\r\n\r\n    Vector2d.fromPolarComponentsIn rotatedFrame\r\n        ( Length.meters 1\r\n        , Angle.degrees 0\r\n        )\r\n    --> Vector2d.fromComponents\r\n    -->     ( Length.meters 0.7071\r\n    -->     , Length.meters 0.7071\r\n    -->     )\r\n\r\n","type":"Geometry.Types.Frame2d units globalCoordinates localCoordinates -> ( Quantity.Quantity Basics.Float units, Angle.Angle ) -> Vector2d.Vector2d units globalCoordinates"},{"name":"fromRecord","comment":" Construct a unitless `Vector2d` from a record with `Float` fields.\r\n\r\n    Vector2d.fromRecord { x = 2, y = 3 }\r\n    --> Vector2d.fromComponents\r\n    -->     ( Quantity.float 2\r\n    -->     , Quantity.float 3\r\n    -- >    )\r\n\r\n","type":"{ x : Basics.Float, y : Basics.Float } -> Vector2d.Vector2d Quantity.Unitless coordinates"},{"name":"fromTuple","comment":" Construct a unitless `Vector2d` from a tuple of `Float` values.\r\n\r\n    Vector2d.fromTuple ( 2, 3 )\r\n    --> Vector2d.fromComponents\r\n    -->     ( Quantity.float 2\r\n    -->     , Quantity.float 3\r\n    -- >    )\r\n\r\n","type":"( Basics.Float, Basics.Float ) -> Vector2d.Vector2d Quantity.Unitless coordinates"},{"name":"interpolateFrom","comment":" Construct a vector by interpolating from the first given vector to the\r\nsecond, based on a parameter that ranges from zero to one.\r\n\r\n    startVector =\r\n        Vector2d.zero\r\n\r\n    endVector =\r\n        Vector2d.fromComponents ( 8, 12 )\r\n\r\n    Vector2d.interpolateFrom startVector endVector 0.25\r\n    --> Vector2d.fromComponents ( 2, 3 )\r\n\r\nPartial application may be useful:\r\n\r\n    interpolatedVector : Float -> Vector2d\r\n    interpolatedVector =\r\n        Vector2d.interpolateFrom startVector endVector\r\n\r\n    List.map interpolatedVector [ 0, 0.5, 1 ]\r\n    --> [ Vector2d.fromComponents ( 0, 0 )\r\n    --> , Vector2d.fromComponents ( 4, 6 )\r\n    --> , Vector2d.fromComponents ( 8, 12 )\r\n    --> ]\r\n\r\nYou can pass values less than zero or greater than one to extrapolate:\r\n\r\n    interpolatedVector -0.5\r\n    --> Vector2d.fromComponents ( -4, -6 )\r\n\r\n    interpolatedVector 1.25\r\n    --> Vector2d.fromComponents ( 10, 15 )\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Vector2d.Vector2d units coordinates -> Basics.Float -> Vector2d.Vector2d units coordinates"},{"name":"length","comment":" Get the length (magnitude) of a vector.\r\n\r\n    Vector2d.length (Vector2d.fromComponents ( 3, 4 ))\r\n    --> 5\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"lengthAndDirection","comment":" Attempt to find the length and direction of a vector. In the case of a zero\r\nvector, returns `Nothing`.\r\n\r\n    vector =\r\n        Vector2d.fromComponents ( 1, 1 )\r\n\r\n    Vector2d.lengthAndDirection vector\r\n    --> Just\r\n    -->     ( 1.4142\r\n    -->     , Direction2d.fromAngle (degrees 45)\r\n    -->     )\r\n\r\n    Vector2d.lengthAndDirection Vector2d.zero\r\n    --> Nothing\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Maybe.Maybe ( Quantity.Quantity Basics.Float units, Geometry.Types.Direction2d coordinates )"},{"name":"lexicographicComparison","comment":" Compare two `Vector2d` values lexicographically: first by X component, then\r\nby Y. Can be used to provide a sort order for `Vector2d` values.\r\n","type":"Vector2d.Vector2d units coordinates -> Vector2d.Vector2d units coordinates -> Basics.Order"},{"name":"minus","comment":" Find the difference between two vectors (the first vector minus the second).\r\n\r\n    firstVector =\r\n        Vector2d.fromComponents ( 5, 6 )\r\n\r\n    secondVector =\r\n        Vector2d.fromComponents ( 1, 3 )\r\n\r\n    Vector2d.difference firstVector secondVector\r\n    --> Vector2d.fromComponents ( 4, 3 )\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Vector2d.Vector2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"mirrorAcross","comment":" Mirror a vector across a given axis.\r\n\r\n    vector =\r\n        Vector2d.fromComponents ( 2, 3 )\r\n\r\n    Vector2d.mirrorAcross Axis2d.y vector\r\n    --> Vector2d.fromComponents ( -2, 3 )\r\n\r\nThe position of the axis doesn't matter, only its orientation:\r\n\r\n    horizontalAxis =\r\n        Axis2d.withDirection Direction2d.x\r\n            (Point2d.fromCoordinates ( 100, 200 ))\r\n\r\n    Vector2d.mirrorAcross horizontalAxis vector\r\n    --> Vector2d.fromComponents ( 2, -3 )\r\n\r\n","type":"Geometry.Types.Axis2d axisUnits coordinates -> Vector2d.Vector2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"normalize","comment":" Normalize a vector to have a length of one. Zero vectors are left as-is.\r\n\r\n    vector =\r\n        Vector2d.fromComponents ( 3, 4 )\r\n\r\n    Vector2d.normalize vector\r\n    --> Vector2d.fromComponents ( 0.6, 0.8 )\r\n\r\n    Vector2d.normalize Vector2d.zero\r\n    --> Vector2d.zero\r\n\r\n**Warning**: `Vector2d.direction` is safer since it forces you to explicitly\r\nconsider the case where the given vector is zero. `Vector2d.normalize` is\r\nprimarily useful for cases like generating WebGL meshes, where defaulting to a\r\nzero vector for degenerate cases is acceptable, and the overhead of something\r\nlike\r\n\r\n    Vector2d.direction vector\r\n        |> Maybe.map Direction2d.toVector\r\n        |> Maybe.withDefault Vector2d.zero\r\n\r\n(which is functionally equivalent to `Vector2d.normalize vector`) is too high.\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Vector2d.Vector2d Quantity.Unitless coordinates"},{"name":"per","comment":" Construct a vector representing a rate of change such as a speed:\r\n\r\n    displacement =\r\n        Vector2d.fromComponents\r\n            ( Length.meters 6\r\n            , Length.meters 8\r\n            )\r\n\r\n    velocity =\r\n        displacement |> Vector2d.per (Duration.seconds 2)\r\n\r\n    -- Get the magnitude of the velocity (the speed)\r\n    Vector2d.length velocity\r\n    --> Speed.metersPerSecond 5\r\n\r\n","type":"Quantity.Quantity Basics.Float independentUnits -> Vector2d.Vector2d dependentUnits coordinates -> Vector2d.Vector2d (Quantity.Rate dependentUnits independentUnits) coordinates"},{"name":"perpendicularTo","comment":" Construct a vector perpendicular to the given vector, by rotating the given\r\nvector 90 degrees counterclockwise. The constructed vector will have the same\r\nlength as the given vector. Alias for `Vector2d.rotateCounterclockwise`.\r\n\r\n    Vector2d.perpendicularTo\r\n        (Vector2d.fromComponents ( 1, 0 ))\r\n    --> Vector2d.fromComponents ( 0, 1 )\r\n\r\n    Vector2d.perpendicularTo\r\n        (Vector2d.fromComponents ( 0, 2 ))\r\n    --> Vector2d.fromComponents ( -2, 0 )\r\n\r\n    Vector2d.perpendicularTo\r\n        (Vector2d.fromComponents ( 3, 1 ))\r\n    --> Vector2d.fromComponents ( -1, 3 )\r\n\r\n    Vector2d.perpendicularTo Vector2d.zero\r\n    --> Vector2d.zero\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"placeIn","comment":" Take a vector defined in local coordinates relative to a given reference\r\nframe, and return that vector expressed in global coordinates.\r\n\r\n    Vector2d.fromComponents ( 2, 0 )\r\n        |> Vector2d.placeIn rotatedFrame\r\n    --> Vector2d.fromComponents ( 1.732, 1 )\r\n\r\n","type":"Geometry.Types.Frame2d frameUnits globalCoordinates localCoordinates -> Vector2d.Vector2d units localCoordinates -> Vector2d.Vector2d units globalCoordinates"},{"name":"plus","comment":" Find the sum of two vectors.\r\n\r\n    firstVector =\r\n        Vector2d.fromComponents ( 1, 2 )\r\n\r\n    secondVector =\r\n        Vector2d.fromComponents ( 3, 4 )\r\n\r\n    Vector2d.sum firstVector secondVector\r\n    --> Vector2d.fromComponents ( 4, 6 )\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Vector2d.Vector2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"polarComponents","comment":" Get the polar components (length, polar angle) of a vector.\r\n\r\n    Vector2d.polarComponents\r\n        (Vector2d.fromComponents ( 1, 1 ))\r\n    --> ( 1.4142, degrees 45 )\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> ( Quantity.Quantity Basics.Float units, Angle.Angle )"},{"name":"projectOnto","comment":" Project a vector onto an axis.\r\n\r\n    Vector2d.projectOnto Axis2d.y\r\n        (Vector2d.fromComponents ( 3, 4 ))\r\n    --> Vector2d.fromComponents ( 0, 4 )\r\n\r\n    Vector2d.projectOnto Axis2d.x\r\n        (Vector2d.fromComponents ( -1, 2 ))\r\n    --> Vector2d.fromComponents ( -1, 0 )\r\n\r\nThis is equivalent to finding the projection in the axis' direction.\r\n\r\n","type":"Geometry.Types.Axis2d units coordinates -> Vector2d.Vector2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"projectionIn","comment":" Find the projection of a vector in a particular direction. Conceptually,\r\nthis means splitting the original vector into a portion parallel to the given\r\ndirection and a portion perpendicular to it, then returning the parallel\r\nportion.\r\n\r\n    vector =\r\n        Vector2d.fromComponents ( 2, 3 )\r\n\r\n    Vector2d.projectionIn Direction2d.x vector\r\n    --> Vector2d.fromComponents ( 2, 0 )\r\n\r\n    Vector2d.projectionIn Direction2d.y vector\r\n    --> Vector2d.fromComponents ( 0, 3 )\r\n\r\n","type":"Geometry.Types.Direction2d coordinates -> Vector2d.Vector2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"relativeTo","comment":" Take a vector defined in global coordinates, and return it expressed in\r\nlocal coordinates relative to a given reference frame.\r\n\r\n    Vector2d.fromComponents ( 2, 0 )\r\n        |> Vector2d.relativeTo rotatedFrame\r\n    --> Vector2d.fromComponents ( 1.732, -1 )\r\n\r\n","type":"Geometry.Types.Frame2d frameUnits globalCoordinates localCoordinates -> Vector2d.Vector2d units globalCoordinates -> Vector2d.Vector2d units localCoordinates"},{"name":"reverse","comment":" Reverse the direction of a vector, negating its components.\r\n\r\n    Vector2d.reverse (Vector2d.fromComponents ( -1, 2 ))\r\n    --> Vector2d.fromComponents ( 1, -2 )\r\n\r\n(This could have been called `negate`, but `reverse` is more consistent with\r\nthe naming used in other modules.)\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"rotateBy","comment":" Rotate a vector counterclockwise by a given angle (in radians).\r\n\r\n    Vector2d.fromComponents ( 1, 1 )\r\n        |> Vector2d.rotateBy (degrees 45)\r\n    --> Vector2d.fromComponents ( 0, 1.4142 )\r\n\r\n    Vector2d.fromComponents ( 1, 0 )\r\n        |> Vector2d.rotateBy pi\r\n    --> Vector2d.fromComponents ( -1, 0 )\r\n\r\n","type":"Angle.Angle -> Vector2d.Vector2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"rotateClockwise","comment":" Rotate the given vector 90 degrees clockwise;\r\n\r\n    Vector2d.rotateClockwise vector\r\n\r\nis equivalent to\r\n\r\n    Vector2d.rotateBy (degrees -90) vector\r\n\r\nbut is more efficient.\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"rotateCounterclockwise","comment":" Rotate the given vector 90 degrees counterclockwise;\r\n\r\n    Vector2d.rotateCounterclockwise vector\r\n\r\nis equivalent to\r\n\r\n    Vector2d.rotateBy (degrees 90) vector\r\n\r\nbut is more efficient.\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"scaleBy","comment":" Scale the length of a vector by a given scale.\r\n\r\n    Vector2d.scaleBy 3 (Vector2d.fromComponents ( 1, 2 ))\r\n    --> Vector2d.fromComponents ( 3, 6 )\r\n\r\n(This could have been called `multiply` or `times`, but `scaleBy` was chosen as\r\na more geometrically meaningful name and to be consistent with the `scaleAbout`\r\nname used in other modules.)\r\n\r\n","type":"Basics.Float -> Vector2d.Vector2d units coordinates -> Vector2d.Vector2d units coordinates"},{"name":"squaredLength","comment":" Get the squared length of a vector. `squaredLength` is slightly faster than\r\n`length`, so for example\r\n\r\n    Vector2d.squaredLength vector > tolerance * tolerance\r\n\r\nis equivalent to but slightly more efficient than\r\n\r\n    Vector2d.length vector > tolerance\r\n\r\nsince the latter requires a square root under the hood. In many cases, however,\r\nthe speed difference will be negligible and using `length` is much more\r\nreadable!\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Squared units)"},{"name":"toRecord","comment":" Convert a unitless `Vector2d` to a record with `Float` fields.\r\n\r\n    vector =\r\n        Vector2d.fromComponents\r\n            ( Quantity.float 2\r\n            , Quantity.float 3\r\n            )\r\n\r\n    Vector2d.toRecord vector\r\n    --> { x = 2, y = 3 }\r\n\r\n","type":"Vector2d.Vector2d Quantity.Unitless coordinates -> { x : Basics.Float, y : Basics.Float }"},{"name":"toTuple","comment":" Convert a unitless `Vector2d` to a tuple of `Float` values.\r\n\r\n    vector =\r\n        Vector2d.fromComponents\r\n            ( Quantity.float 2\r\n            , Quantity.float 3\r\n            )\r\n\r\n    Vector2d.toTuple vector\r\n    --> ( 2, 3 )\r\n\r\n","type":"Vector2d.Vector2d Quantity.Unitless coordinates -> ( Basics.Float, Basics.Float )"},{"name":"withLength","comment":" Construct a vector with the given length in the given direction.\r\n\r\n    Vector2d.withLength 5 Direction2d.y\r\n    --> Vector2d.fromComponents ( 0, 5 )\r\n\r\n","type":"Quantity.Quantity Basics.Float units -> Geometry.Types.Direction2d coordinates -> Vector2d.Vector2d units coordinates"},{"name":"xComponent","comment":" Get the X component of a vector.\r\n\r\n    Vector2d.xComponent (Vector2d.fromComponents ( 2, 3 ))\r\n    --> 2\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"yComponent","comment":" Get the Y component of a vector.\r\n\r\n    Vector2d.yComponent (Vector2d.fromComponents ( 2, 3 ))\r\n    --> 3\r\n\r\n","type":"Vector2d.Vector2d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"zero","comment":" The zero vector.\r\n\r\n    Vector2d.zero\r\n    --> Vector2d.fromComponents ( 0, 0 )\r\n\r\n","type":"Vector2d.Vector2d units coordinates"}],"binops":[]},{"name":"Vector3d","comment":" A `Vector3d` represents a quantity such as a displacement or velocity in 3D,\r\nand is defined by its X, Y and Z components. This module contains a variety of\r\nvector-related functionality, such as\r\n\r\n  - Adding or subtracting vectors\r\n  - Finding the lengths of vectors\r\n  - Rotating vectors\r\n  - Converting vectors between different coordinate systems\r\n\r\nNote that unlike in many other geometry packages where vectors are used as a\r\ngeneral-purpose data type, `elm-geometry` has separate data types for vectors,\r\ndirections and points. In most code it is actually more common to use `Point3d`\r\nand `Direction3d` than `Vector3d`, and much code can avoid working directly with\r\n`Vector3d` values at all!\r\n\r\n@docs Vector3d\r\n\r\n\r\n# Predefined vectors\r\n\r\n@docs zero\r\n\r\nAlthough there are no predefined constants for the vectors with components\r\n(1,&nbsp;0,&nbsp;0), (0,&nbsp;1,&nbsp;0) and (0,&nbsp;0,&nbsp;1), in most cases\r\nyou will actually want their `Direction3d` versions [`Direction3d.x`](Direction3d#x),\r\n[`Direction3d.y`](Direction3d#y) and [`Direction3d.z`](Direction3d#z).\r\n\r\n\r\n# Constructors\r\n\r\n@docs fromComponents, fromComponentsIn, from, withLength, on, perpendicularTo, interpolateFrom\r\n\r\n\r\n# Interop\r\n\r\nThese functions are useful for interoperability with other Elm code that uses\r\nplain `Float` tuples or records to represent vectors. The resulting `Vector3d`\r\nvalues will have [unitless](https://package.elm-lang.org/packages/ianmackenzie/elm-units/latest/Quantity#unitless-quantities)\r\ncomponents.\r\n\r\n@docs fromTuple, toTuple, fromRecord, toRecord\r\n\r\n\r\n# Properties\r\n\r\n@docs components, componentsIn, xComponent, yComponent, componentIn, zComponent, length, squaredLength, direction, lengthAndDirection\r\n\r\n\r\n# Comparison\r\n\r\n@docs equalWithin, lexicographicComparison\r\n\r\n\r\n# Arithmetic\r\n\r\n@docs plus, minus, dot, cross\r\n\r\n\r\n# Transformations\r\n\r\nNote that for all transformations, only the orientation of the given axis or\r\nplane is relevant, since vectors are position-independent. Think of transforming\r\na vector as placing its tail on the relevant axis or plane and then transforming\r\nits tip.\r\n\r\n@docs reverse, normalize, scaleBy, rotateAround, mirrorAcross, projectionIn, projectOnto\r\n\r\n\r\n# Coordinate conversions\r\n\r\nLike other transformations, coordinate transformations of vectors depend only on\r\nthe orientations of the relevant frames/sketch planes, not their positions.\r\n\r\nFor the examples, assume the following definition of a local coordinate frame,\r\none that is rotated 30 degrees counterclockwise around the Z axis from the\r\nglobal XYZ frame:\r\n\r\n    rotatedFrame =\r\n        Frame3d.atOrigin |> Frame3d.rotateAround Axis3d.z (degrees 30)\r\n\r\n@docs relativeTo, placeIn, projectInto\r\n\r\n","unions":[],"aliases":[{"name":"Vector3d","comment":" ","args":["units","coordinates"],"type":"Geometry.Types.Vector3d units coordinates"}],"values":[{"name":"componentIn","comment":" Find the component of a vector in an arbitrary direction, for example\r\n\r\n    verticalSpeed =\r\n        Vector3d.componentIn upDirection velocity\r\n\r\nThis is more general and flexible than using `xComponent`, `yComponent` or\r\n`zComponent`, all of which can be expressed in terms of `componentIn`; for\r\nexample,\r\n\r\n    Vector3d.zComponent vector\r\n\r\nis equivalent to\r\n\r\n    Vector3d.componentIn Direction3d.z vector\r\n\r\n","type":"Geometry.Types.Direction3d coordinates -> Vector3d.Vector3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"components","comment":" Extract the components of a vector.\r\n\r\n    Vector3d.fromComponents ( 2, 3, 4 )\r\n        |> Vector3d.components\r\n    --> ( 2, 3, 4 )\r\n\r\nThis combined with Elm's built-in tuple destructuring provides a convenient way\r\nto extract the X, Y and Z components of a vector in one line of code:\r\n\r\n    ( x, y, z ) =\r\n        Vector3d.components vector\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> ( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units )"},{"name":"componentsIn","comment":" Find the components of a vector in a given frame;\r\n\r\n    Vector3d.componentsIn frame vector\r\n\r\nis equivalent to\r\n\r\n    ( Vector3d.componentIn (Frame3d.xDirection frame) vector\r\n    , Vector3d.componentIn (Frame3d.yDirection frame) vector\r\n    , Vector3d.componentIn (Frame3d.zDirection frame) vector\r\n    )\r\n\r\n","type":"Geometry.Types.Frame3d units globalCoordinates localCoordinates -> Vector3d.Vector3d units globalCoordinates -> ( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units )"},{"name":"cross","comment":" Find the cross product of two vectors.\r\n\r\n    firstVector =\r\n        Vector3d.fromComponents\r\n            ( Length.meters 2\r\n            , Length.meters 0\r\n            , Length.meters 0\r\n            )\r\n\r\n    secondVector =\r\n        Vector3d.fromComponents\r\n            ( Length.meters 0\r\n            , Length.meters 3\r\n            , Length.meters 0\r\n            )\r\n\r\n    firstVector |> Vector3d.cross secondVector\r\n    --> Vector3d.fromComponents\r\n    -->     ( Quantity.zero\r\n    -->     , Quantity.zero\r\n    -->     , Area.squareMeters 6\r\n    -->     )\r\n\r\nNote the argument order - `v1 x v2` would be written as\r\n\r\n    v1 |> Vector3d.cross v2\r\n\r\nwhich is the same as\r\n\r\n    Vector3d.cross v2 v1\r\n\r\nbut the _opposite_ of\r\n\r\n    Vector3d.cross v1 v2\r\n\r\n","type":"Vector3d.Vector3d units2 coordinates -> Vector3d.Vector3d units1 coordinates -> Vector3d.Vector3d (Quantity.Product units1 units2) coordinates"},{"name":"direction","comment":" Attempt to find the direction of a vector. In the case of a zero vector,\r\nreturns `Nothing`.\r\n\r\n    Vector3d.fromComponents ( 3, 0, 3 )\r\n        |> Vector3d.direction\r\n    --> Just\r\n    -->     (Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 0)\r\n    -->         (degrees 45)\r\n    -->     )\r\n\r\n    Vector3d.direction Vector3d.zero\r\n    --> Nothing\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Maybe.Maybe (Geometry.Types.Direction3d coordinates)"},{"name":"dot","comment":" Find the dot product of two vectors.\r\n\r\n    firstVector =\r\n        Vector3d.fromComponents\r\n            ( Length.meters 1\r\n            , Length.meters 0\r\n            , Length.meters 2\r\n            )\r\n\r\n    secondVector =\r\n        Vector3d.fromComponents\r\n            ( Length.meters 3\r\n            , Length.meters 4\r\n            , Length.meters 5\r\n            )\r\n\r\n    firstVector |> Vector3d.dot secondVector\r\n    --> Area.squareMeters 13\r\n\r\n","type":"Vector3d.Vector3d units2 coordinates -> Vector3d.Vector3d units1 coordinates -> Quantity.Quantity Basics.Float (Quantity.Product units1 units2)"},{"name":"equalWithin","comment":" Compare two vectors within a tolerance. Returns true if the difference\r\nbetween the two given vectors has magnitude less than the given tolerance.\r\n\r\n    firstVector =\r\n        Vector3d.fromComponents ( 2, 1, 3 )\r\n\r\n    secondVector =\r\n        Vector3d.fromComponents ( 2.0002, 0.9999, 3.0001 )\r\n\r\n    Vector3d.equalWithin 1e-3 firstVector secondVector\r\n    --> True\r\n\r\n    Vector3d.equalWithin 1e-6 firstVector secondVector\r\n    --> False\r\n\r\n","type":"Quantity.Quantity Basics.Float units -> Vector3d.Vector3d units coordinates -> Vector3d.Vector3d units coordinates -> Basics.Bool"},{"name":"from","comment":" Construct a vector from the first given point to the second.\r\n\r\n    startPoint =\r\n        Point3d.fromCoordinates ( 1, 1, 1 )\r\n\r\n    endPoint =\r\n        Point3d.fromCoordinates ( 4, 5, 6 )\r\n\r\n    Vector3d.from startPoint endPoint\r\n    --> Vector3d.fromComponents ( 3, 4, 5 )\r\n\r\n","type":"Geometry.Types.Point3d units coordinates -> Geometry.Types.Point3d units coordinates -> Vector3d.Vector3d units coordinates"},{"name":"fromComponents","comment":" Construct a vector from its X, Y and Z components.\r\n\r\n    vector =\r\n        Vector3d.fromComponents ( 2, 1, 3 )\r\n\r\n","type":"( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units ) -> Vector3d.Vector3d units coordinates"},{"name":"fromComponentsIn","comment":" Construct a vector given its local components within a particular frame:\r\n\r\n    frame =\r\n        Frame3d.atOrigin\r\n            |> Frame3d.rotateAround Axis3d.z\r\n                (Angle.degrees 45)\r\n\r\n    Vector3d.fromComponentsIn frame\r\n        ( Speed.feetPerSecond 1\r\n        , Speed.feetPerSecond 0\r\n        , Speed.feetPerSecond 2\r\n        )\r\n    --> Vector3d.fromComponents\r\n    -->     ( Speed.feetPerSecond 0.7071\r\n    -->     , Speed.feetPerSecond 0.7071\r\n    -->     , Speed.feetPerSecond 2\r\n    -->     )\r\n\r\n","type":"Geometry.Types.Frame3d units globalCoordinates localCoordinates -> ( Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units, Quantity.Quantity Basics.Float units ) -> Vector3d.Vector3d units globalCoordinates"},{"name":"fromRecord","comment":" Construct a unitless `Vector3d` from a record with `Float` fields.\r\n\r\n    Vector3d.fromRecord { x = 2, y = 1, z = 3 }\r\n    --> Vector3d.fromComponents\r\n    -->     ( Quantity.float 2\r\n    -->     , Quantity.float 1\r\n    -->     , Quantity.float 3\r\n    -- >    )\r\n\r\n","type":"{ x : Basics.Float, y : Basics.Float, z : Basics.Float } -> Vector3d.Vector3d Quantity.Unitless coordinates"},{"name":"fromTuple","comment":" Construct a unitless `Vector3d` from a tuple of `Float` values.\r\n\r\n    Vector3d.fromTuple ( 2, 1, 3 )\r\n    --> Vector3d.fromComponents\r\n    -->     ( Quantity.float 2\r\n    -->     , Quantity.float 1\r\n    -->     , Quantity.float 3\r\n    -- >    )\r\n\r\n","type":"( Basics.Float, Basics.Float, Basics.Float ) -> Vector3d.Vector3d Quantity.Unitless coordinates"},{"name":"interpolateFrom","comment":" Construct a vector by interpolating from the first given vector to the\r\nsecond, based on a parameter that ranges from zero to one.\r\n\r\n    startVector =\r\n        Vector3d.fromComponents ( 1, 2, 4 )\r\n\r\n    endVector =\r\n        Vector3d.fromComponents ( 1, 3, 8 )\r\n\r\n    Vector3d.interpolateFrom startVector endVector 0.25\r\n    --> Vector3d.fromComponents ( 1, 2.25, 5 )\r\n\r\nPartial application may be useful:\r\n\r\n    interpolatedVector : Float -> Vector3d\r\n    interpolatedVector =\r\n        Vector3d.interpolateFrom startVector endVector\r\n\r\n    List.map interpolatedVector [ 0, 0.5, 1 ]\r\n    --> [ Vector3d.fromComponents ( 1, 2, 4 )\r\n    --> , Vector3d.fromComponents ( 1, 2, 6 )\r\n    --> , Vector3d.fromComponents ( 1, 2, 8 )\r\n    --> ]\r\n\r\nYou can pass values less than zero or greater than one to extrapolate:\r\n\r\n    interpolatedVector -0.5\r\n    --> Vector3d.fromComponents ( 1, 2, 2 )\r\n\r\n    interpolatedVector 1.25\r\n    --> Vector3d.fromComponents ( 1, 2, 9 )\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Vector3d.Vector3d units coordinates -> Basics.Float -> Vector3d.Vector3d units coordinates"},{"name":"length","comment":" Get the length (magnitude) of a vector.\r\n\r\n    Vector3d.length (Vector3d.fromComponents ( 2, 1, 2 ))\r\n    --> 3\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"lengthAndDirection","comment":" Attempt to find the length and direction of a vector. In the case of a zero\r\nvector, returns `Nothing`.\r\n\r\n    vector =\r\n        Vector3d.fromComponents ( 3, 0, 3 )\r\n\r\n    Vector3d.lengthAndDirection vector\r\n    --> Just\r\n    -->     ( 4.2426\r\n    -->     , Direction3d.fromAzimuthAndElevation\r\n    -->         (degrees 0)\r\n    -->         (degrees 45)\r\n    -->     )\r\n\r\n    Vector3d.lengthAndDirection Vector3d.zero\r\n    --> Nothing\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Maybe.Maybe ( Quantity.Quantity Basics.Float units, Geometry.Types.Direction3d coordinates )"},{"name":"lexicographicComparison","comment":" Compare two `Vector3d` values lexicographically: first by X component, then\r\nby Y, then by Z. Can be used to provide a sort order for `Vector3d` values.\r\n","type":"Vector3d.Vector3d units coordinates -> Vector3d.Vector3d units coordinates -> Basics.Order"},{"name":"minus","comment":" Find the difference between two vectors (the first vector minus the second).\r\n\r\n    firstVector =\r\n        Vector3d.fromComponents ( 5, 6, 7 )\r\n\r\n    secondVector =\r\n        Vector3d.fromComponents ( 1, 1, 1 )\r\n\r\n    Vector3d.difference firstVector secondVector\r\n    --> Vector3d.fromComponents ( 4, 5, 6 )\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Vector3d.Vector3d units coordinates -> Vector3d.Vector3d units coordinates"},{"name":"mirrorAcross","comment":" Mirror a vector across a plane.\r\n\r\n    vector =\r\n        Vector3d.fromComponents ( 1, 2, 3 )\r\n\r\n    Vector3d.mirrorAcross Plane3d.xy vector\r\n    --> Vector3d.fromComponents ( 1, 2, -3 )\r\n\r\n    Vector3d.mirrorAcross Plane3d.yz vector\r\n    --> Vector3d.fromComponents ( -1, 2, 3 )\r\n\r\n","type":"Geometry.Types.Plane3d units coordinates -> Vector3d.Vector3d units coordinates -> Vector3d.Vector3d units coordinates"},{"name":"normalize","comment":" Normalize a vector to have a length of one. Zero vectors are left as-is.\r\n\r\n    vector =\r\n        Vector3d.fromComponents ( 3, 0, 4 )\r\n\r\n    Vector3d.normalize vector\r\n    --> Vector3d.fromComponents ( 0.6, 0, 0.8 )\r\n\r\n    Vector3d.normalize Vector3d.zero\r\n    --> Vector3d.zero\r\n\r\n**Warning**: `Vector3d.direction` is safer since it forces you to explicitly\r\nconsider the case where the given vector is zero. `Vector3d.normalize` is\r\nprimarily useful for cases like generating WebGL meshes, where defaulting to a\r\nzero vector for degenerate cases is acceptable, and the overhead of something\r\nlike\r\n\r\n    Vector3d.direction vector\r\n        |> Maybe.map Direction3d.toVector\r\n        |> Maybe.withDefault Vector3d.zero\r\n\r\n(which is functionally equivalent to `Vector3d.normalize vector`) is too high.\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Vector3d.Vector3d Quantity.Unitless coordinates"},{"name":"on","comment":" Construct a 3D vector lying _on_ a sketch plane by providing a 2D vector\r\nspecified in XY coordinates _within_ the sketch plane.\r\n\r\n    vector2d =\r\n        Vector2d.fromComponents ( 2, 3 )\r\n\r\n    Vector3d.on SketchPlane3d.xy vector2d\r\n    --> Vector3d.fromComponents ( 2, 3, 0 )\r\n\r\n    Vector3d.on SketchPlane3d.yz vector2d\r\n    --> Vector3d.fromComponents ( 0, 2, 3 )\r\n\r\n    Vector3d.on SketchPlane3d.zx vector2d\r\n    --> Vector3d.fromComponents ( 3, 0, 2 )\r\n\r\nA slightly more complex example:\r\n\r\n    tiltedSketchPlane =\r\n        SketchPlane3d.xy\r\n            |> SketchPlane3d.rotateAround Axis3d.x\r\n                (degrees 45)\r\n\r\n    Vector3d.on tiltedSketchPlane <|\r\n        Vector2d.fromComponents ( 1, 1 )\r\n    --> Vector3d.fromComponents ( 1, 0.7071, 0.7071 )\r\n\r\n","type":"Geometry.Types.SketchPlane3d units coordinates3d coordinates2d -> Vector2d.Vector2d units coordinates2d -> Vector3d.Vector3d units coordinates3d"},{"name":"perpendicularTo","comment":" Construct an arbitrary vector perpendicular to the given vector. The exact\r\nlength and direction of the resulting vector are not specified, but it is\r\nguaranteed to be perpendicular to the given vector and non-zero (unless the\r\ngiven vector is itself zero).\r\n\r\n    Vector3d.perpendicularTo\r\n        (Vector3d.fromComponents ( 3, 0, 0 ))\r\n    --> Vector3d.fromComponents ( 0, 0, -3 )\r\n\r\n    Vector3d.perpendicularTo\r\n        (Vector3d.fromComponents ( 1, 2, 3 ))\r\n    --> Vector3d.fromComponents ( 0, -3, 2 )\r\n\r\n    Vector3d.perpendicularTo Vector3d.zero\r\n    --> Vector3d.zero\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Vector3d.Vector3d units coordinates"},{"name":"placeIn","comment":" Take a vector defined in local coordinates relative to a given reference\r\nframe, and return that vector expressed in global coordinates.\r\n\r\n    vector =\r\n        Vector3d.fromComponents ( 2, 0, 3 )\r\n\r\n    Vector3d.placeIn rotatedFrame vector\r\n    --> Vector3d.fromComponents ( 1.732, 1, 3 )\r\n\r\n","type":"Geometry.Types.Frame3d units globalCoordinates localCoordinates -> Vector3d.Vector3d units localCoordinates -> Vector3d.Vector3d units globalCoordinates"},{"name":"plus","comment":" Find the sum of two vectors.\r\n\r\n    firstVector =\r\n        Vector3d.fromComponents ( 1, 2, 3 )\r\n\r\n    secondVector =\r\n        Vector3d.fromComponents ( 4, 5, 6 )\r\n\r\n    Vector3d.sum firstVector secondVector\r\n    --> Vector3d.fromComponents ( 5, 7, 9 )\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Vector3d.Vector3d units coordinates -> Vector3d.Vector3d units coordinates"},{"name":"projectInto","comment":" Project a vector into a given sketch plane. Conceptually, this finds the\r\n[orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nof the vector onto the plane and then expresses the projected vector in 2D\r\nsketch coordinates.\r\n\r\n    vector =\r\n        Vector3d.fromComponents ( 2, 1, 3 )\r\n\r\n    Vector3d.projectInto SketchPlane3d.xy vector\r\n    --> Vector2d.fromComponents ( 2, 1 )\r\n\r\n    Vector3d.projectInto SketchPlane3d.yz vector\r\n    --> Vector2d.fromComponents ( 1, 3 )\r\n\r\n    Vector3d.projectInto SketchPlane3d.zx vector\r\n    --> Vector2d.fromComponents ( 3, 2 )\r\n\r\n","type":"Geometry.Types.SketchPlane3d units coordinates coordinates2d -> Vector3d.Vector3d units coordinates -> Vector2d.Vector2d units coordinates2d"},{"name":"projectOnto","comment":" Project a vector [orthographically](https://en.wikipedia.org/wiki/Orthographic_projection)\r\nonto a plane. Conceptually, this means splitting the original vector into a\r\nportion parallel to the plane (perpendicular to the plane's normal direction)\r\nand a portion perpendicular to it (parallel to its normal direction), then\r\nreturning the parallel (in-plane) portion.\r\n\r\n    vector =\r\n        Vector3d.fromComponents ( 2, 1, 3 )\r\n\r\n    Vector3d.projectOnto Plane3d.xy vector\r\n    --> Vector3d.fromComponents ( 2, 1, 0 )\r\n\r\n    Vector3d.projectOnto Plane3d.xz vector\r\n    --> Vector3d.fromComponents ( 2, 0, 3 )\r\n\r\n","type":"Geometry.Types.Plane3d units coordinates -> Vector3d.Vector3d units coordinates -> Vector3d.Vector3d units coordinates"},{"name":"projectionIn","comment":" Find the projection of a vector in a particular direction. Conceptually,\r\nthis means splitting the original vector into a portion parallel to the given\r\ndirection and a portion perpendicular to it, then returning the parallel\r\nportion.\r\n\r\n    vector =\r\n        Vector3d.fromComponents ( 1, 2, 3 )\r\n\r\n    Vector3d.projectionIn Direction3d.x vector\r\n    --> Vector3d.fromComponents ( 1, 0, 0 )\r\n\r\n    Vector3d.projectionIn Direction3d.z vector\r\n    --> Vector3d.fromComponents ( 0, 0, 3 )\r\n\r\n","type":"Geometry.Types.Direction3d coordinates -> Vector3d.Vector3d units coordinates -> Vector3d.Vector3d units coordinates"},{"name":"relativeTo","comment":" Take a vector defined in global coordinates, and return it expressed in\r\nlocal coordinates relative to a given reference frame.\r\n\r\n    vector =\r\n        Vector3d.fromComponents ( 2, 0, 3 )\r\n\r\n    Vector3d.relativeTo rotatedFrame vector\r\n    --> Vector3d.fromComponents ( 1.732, -1, 3 )\r\n\r\n","type":"Geometry.Types.Frame3d units globalCoordinates localCoordinates -> Vector3d.Vector3d units globalCoordinates -> Vector3d.Vector3d units localCoordinates"},{"name":"reverse","comment":" Reverse the direction of a vector, negating its components.\r\n\r\n    Vector3d.reverse (Vector3d.fromComponents ( 1, -3, 2 ))\r\n    --> Vector3d.fromComponents ( -1, 3, -2 )\r\n\r\n(This could have been called `negate`, but `reverse` is more consistent with\r\nthe naming used in other modules.)\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Vector3d.Vector3d units coordinates"},{"name":"rotateAround","comment":" Rotate a vector around a given axis by a given angle (in radians).\r\n\r\n    vector =\r\n        Vector3d.fromComponents ( 2, 0, 1 )\r\n\r\n    Vector3d.rotateAround Axis3d.x (degrees 90) vector\r\n    --> Vector3d.fromComponents ( 2, -1, 0 )\r\n\r\n    Vector3d.rotateAround Axis3d.z (degrees 45) vector\r\n    --> Vector3d.fromComponents ( 1.4142, 1.4142, 1 )\r\n\r\n","type":"Geometry.Types.Axis3d units coordinates -> Angle.Angle -> Vector3d.Vector3d units coordinates -> Vector3d.Vector3d units coordinates"},{"name":"scaleBy","comment":" Scale the length of a vector by a given scale.\r\n\r\n    Vector3d.fromComponents ( 1, 2, 3 )\r\n        |> Vector3d.scaleBy 3\r\n    --> Vector3d.fromComponents ( 3, 6, 9 )\r\n\r\n(This could have been called `multiply` or `times`, but `scaleBy` was chosen as\r\na more geometrically meaningful name and to be consistent with the `scaleAbout`\r\nname used in other modules.)\r\n\r\n","type":"Basics.Float -> Vector3d.Vector3d units coordinates -> Vector3d.Vector3d units coordinates"},{"name":"squaredLength","comment":" Get the squared length of a vector. `squaredLength` is slightly faster than\r\n`length`, so for example\r\n\r\n    Vector3d.squaredLength vector > tolerance * tolerance\r\n\r\nis equivalent to but slightly more efficient than\r\n\r\n    Vector3d.length vector > tolerance\r\n\r\nsince the latter requires a square root under the hood. In many cases, however,\r\nthe speed difference will be negligible and using `length` is much more\r\nreadable!\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Quantity.Quantity Basics.Float (Quantity.Squared units)"},{"name":"toRecord","comment":" Convert a unitless `Vector3d` to a record with `Float` fields.\r\n\r\n    vector =\r\n        Vector3d.fromComponents\r\n            ( Quantity.float 2\r\n            , Quantity.float 1\r\n            , Quantity.float 3\r\n            )\r\n\r\n    Vector3d.toRecord vector\r\n    --> { x = 2, y = 1, z = 3 }\r\n\r\n","type":"Vector3d.Vector3d Quantity.Unitless coordinates -> { x : Basics.Float, y : Basics.Float, z : Basics.Float }"},{"name":"toTuple","comment":" Convert a unitless `Vector3d` to a tuple of `Float` values.\r\n\r\n    vector =\r\n        Vector3d.fromComponents\r\n            ( Quantity.float 2\r\n            , Quantity.float 1\r\n            , Quantity.float 3\r\n            )\r\n\r\n    Vector3d.toTuple vector\r\n    --> ( 2, 1, 3 )\r\n\r\n","type":"Vector3d.Vector3d Quantity.Unitless coordinates -> ( Basics.Float, Basics.Float, Basics.Float )"},{"name":"withLength","comment":" Construct a vector with the given length in the given direction.\r\n\r\n    Vector3d.withLength 5 Direction3d.y\r\n    --> Vector3d.fromComponents ( 0, 5, 0 )\r\n\r\n","type":"Quantity.Quantity Basics.Float units -> Geometry.Types.Direction3d coordinates -> Vector3d.Vector3d units coordinates"},{"name":"xComponent","comment":" Get the X component of a vector.\r\n\r\n    Vector3d.fromComponents ( 1, 2, 3 )\r\n        |> Vector3d.xComponent\r\n    --> 1\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"yComponent","comment":" Get the Y component of a vector.\r\n\r\n    Vector3d.fromComponents ( 1, 2, 3 )\r\n        |> Vector3d.yComponent\r\n    --> 2\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"zComponent","comment":" Get the Z component of a vector.\r\n\r\n    Vector3d.fromComponents ( 1, 2, 3 )\r\n        |> Vector3d.zComponent\r\n    --> 3\r\n\r\n","type":"Vector3d.Vector3d units coordinates -> Quantity.Quantity Basics.Float units"},{"name":"zero","comment":" The zero vector.\r\n\r\n    Vector3d.zero\r\n    --> Vector3d.fromComponents ( 0, 0, 0 )\r\n\r\n","type":"Vector3d.Vector3d units coordinates"}],"binops":[]},{"name":"VoronoiDiagram2d","comment":" For any given set of distinct (non-equal) points in 2D, there is a finite\r\nregion around each point such that anywhere in the region is closer to that\r\npoint than to any other point. These are the called the Voronoi regions of each\r\npoint, and the collection of the Voronoi regions for a set of points is called\r\nthe [Voronoi diagram](https://en.wikipedia.org/wiki/Voronoi_diagram) of those\r\npoints.\r\n\r\n![Voronoi diagram](https://ianmackenzie.github.io/elm-geometry/1.2.0/VoronoiDiagram2d/VoronoiDiagram.png)\r\n\r\nAlthough some Voronoi regions will be infinite in size, if they are all clipped\r\nto a particular bounding box then they will all be finite, convex polygons. This\r\nmodule therefore provides functionality for:\r\n\r\n  - Building Voronoi diagrams from sets of points or arbitrary vertices (so\r\n    you can associate colors, IDs or other data with points)\r\n  - Adding new points/vertices to an existing Voronoi diagram\r\n  - Clipping a Voronoi diagram to a particular bounding box to get a list of\r\n    polygons with their associated points/vertices\r\n\r\nThe returned polygons can then be used in various interesting ways:\r\n\r\n  - Use to do interesting geographical analyses (for example, what are the areas\r\n    covered by different fire stations?)\r\n  - Use as an invisible hover target in SVG to highlight corresponding points:\r\n    highlighting a given point when the mouse is over its Voronoi polygon is one\r\n    way to highlight the point nearest the mouse\r\n\r\nThe current implementation is somewhat inefficient, but there are plans to speed\r\nit up in the future (without requiring any changes to the API).\r\n\r\n@docs VoronoiDiagram2d, Error\r\n\r\n\r\n# Construction\r\n\r\nConstructing a Voronoi diagram from points/vertices is currently an O(n^2)\r\noperation but should be O(n log n) in the future.\r\n\r\n@docs empty\r\n\r\n@docs fromPoints, fromVerticesBy\r\n\r\n\r\n# Modification\r\n\r\nInserting a point into a Voronoi diagram is currently an O(n) operation but\r\nshould be O(log n) in the future.\r\n\r\n@docs insertPoint, insertVertexBy\r\n\r\n\r\n# Properties\r\n\r\n@docs vertices, polygons\r\n\r\n\r\n# Conversion\r\n\r\nA Voronoi diagram of a set or vertices is [the dual](https://en.wikipedia.org/wiki/Delaunay_triangulation#Relationship_with_the_Voronoi_diagram)\r\nof the Delaunay triangulation of those vertices. As a result, it is possible to\r\nconvert back and forth between the two.\r\n\r\n@docs fromDelaunayTriangulation, toDelaunayTriangulation\r\n\r\n","unions":[{"name":"Error","comment":" An error type indicating that the two given vertices have the same position.\r\n","args":["vertex"],"cases":[["CoincidentVertices",["vertex","vertex"]]]},{"name":"VoronoiDiagram2d","comment":" A 2D Voronoi diagram of a set of vertices.\r\n","args":["vertex","units","coordinates"],"cases":[]}],"aliases":[],"values":[{"name":"empty","comment":" An empty Voronoi diagram with no vertices or faces.\r\n","type":"VoronoiDiagram2d.VoronoiDiagram2d vertex units coordinates"},{"name":"fromDelaunayTriangulation","comment":" Construct a Voronoi diagram from a Delaunay triangulation. Complexity should\r\nbe O(n) in the vast majority of cases but may be O(n log n) in pathological\r\ncases.\r\n","type":"DelaunayTriangulation2d.DelaunayTriangulation2d vertex units coordinates -> VoronoiDiagram2d.VoronoiDiagram2d vertex units coordinates"},{"name":"fromPoints","comment":" Construct a Voronoi diagram from an array of points. The points must all be\r\ndistinct; if any two points are equal, you will get an `Err CoincidentVertices`.\r\n","type":"Array.Array (Point2d.Point2d units coordinates) -> Result.Result (VoronoiDiagram2d.Error (Point2d.Point2d units coordinates)) (VoronoiDiagram2d.VoronoiDiagram2d (Point2d.Point2d units coordinates) units coordinates)"},{"name":"fromVerticesBy","comment":" Construct a Voronoi diagram from an array of vertices of arbitrary type, by\r\nsupplying a function that returns the position of each vertex as a `Point2d`.\r\nFor example, if you had\r\n\r\n    types alias Vertex =\r\n        { position = Point2d\r\n        , color = String\r\n        }\r\n\r\nand\r\n\r\n    vertices : Array Vertex\r\n    vertices =\r\n        ...\r\n\r\nthen you would use\r\n\r\n    VoronoiDiagram2d.fromVerticesBy .position vertices\r\n\r\nThe vertices must all be distinct; if any two have the same position, you will\r\nget an `Err CoincidentVertices`.\r\n\r\n","type":"(vertex -> Point2d.Point2d units coordinates) -> Array.Array vertex -> Result.Result (VoronoiDiagram2d.Error vertex) (VoronoiDiagram2d.VoronoiDiagram2d vertex units coordinates)"},{"name":"insertPoint","comment":" Add a new point into an existing Voronoi diagram. It must not be equal to\r\nany existing point; if it is, you will get an `Err CoincidentVertices`.\r\n","type":"Point2d.Point2d units coordinates -> VoronoiDiagram2d.VoronoiDiagram2d (Point2d.Point2d units coordinates) units coordinates -> Result.Result (VoronoiDiagram2d.Error (Point2d.Point2d units coordinates)) (VoronoiDiagram2d.VoronoiDiagram2d (Point2d.Point2d units coordinates) units coordinates)"},{"name":"insertVertexBy","comment":" Add a new vertex into an existing Voronoi diagram, by supplying a function\r\nto get the position of the vertex. The vertex must not have the same position as\r\nany existing vertex; if it is, you will get an `Err CoincidentVertices`.\r\n","type":"(vertex -> Point2d.Point2d units coordinates) -> vertex -> VoronoiDiagram2d.VoronoiDiagram2d vertex units coordinates -> Result.Result (VoronoiDiagram2d.Error vertex) (VoronoiDiagram2d.VoronoiDiagram2d vertex units coordinates)"},{"name":"polygons","comment":" Convert a Voronoi diagram to a list of polygons, by clipping each (possibly\r\ninfinite/unbounded) Voronoi region to the given bounding box. Each item in the\r\nreturned list will be an input vertex with its corresponding (clipped) Voronoi\r\nregion.\r\n\r\nIf the bounding box contains all vertices, then there will be an entry in the\r\nlist for every vertex. However, if some vertices fall outside the given\r\nbounding box, then it is possible that their Voronoi region is also entirely\r\noutside the bounding box, in which case they will have no entry in the\r\nreturned list.\r\n\r\nComplexity should be O(n) in the vast majority of cases but may be O(n log n)\r\nin pathological cases (such as 1000 points on a circle surrounding a single\r\ncenter point, in which case the Voronoi region for the center point will be\r\na polygon with 1000 edges).\r\n\r\n","type":"BoundingBox2d.BoundingBox2d units coordinates -> VoronoiDiagram2d.VoronoiDiagram2d vertex units coordinates -> List.List ( vertex, Polygon2d.Polygon2d units coordinates )"},{"name":"toDelaunayTriangulation","comment":" Convert a Voronoi diagram to a Delaunay triangulation. This is a simple\r\naccessor, so complexity is O(1).\r\n","type":"VoronoiDiagram2d.VoronoiDiagram2d vertex units coordinates -> DelaunayTriangulation2d.DelaunayTriangulation2d vertex units coordinates"},{"name":"vertices","comment":" Get the vertices of a Voronoi diagram. If the diagram was constructed by\r\ncalling `fromPoints` or `fromVerticesBy`, then the returned vertex array will\r\nsimply be the array that was passed in. If any vertices were added using\r\n`insertPoint` or `insertVertexBy`, then they will be appended to the end of the\r\narray. This is a simple accessor, so complexity is O(1).\r\n","type":"VoronoiDiagram2d.VoronoiDiagram2d vertex units coordinates -> Array.Array vertex"}],"binops":[]}]